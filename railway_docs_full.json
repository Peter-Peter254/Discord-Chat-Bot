[
  {
    "url": "https://docs.railway.app",
    "title": "Railway Docs",
    "content": "Railway Documentation\nFind user guides, quickstarts, tutorials, use cases, deploy templates, functions and more.\nHow Railway Works\nUnderstand what Railway offers, including the main components of the platform.\nGuides\nExplore our guides to learn how to configure or enable a specific feature on the platform.\nQuickstarts\nDeploy in minutes. Jump into our quickstart guide or deploy with your favorite stack below.\nTutorials\nStep-by-step guides on common developer scenarios.\n Your stack, your way\nUse your favorite language and framework\nNext.js\nNuxt\nLaravel\nDjango\nRails\nRemix\nRocket\nPhoenix\nView all frameworks \nâ†’\n Deploy an app in minutes\nQuickly set up a project with popular templates\nMetabase\nWordpress\nCal\nStrapi\nElasticsearch\nUmami\nMinIO\nTimescale\nView all templates \nâ†’\nHow to Contribute\nâ€†â€†â€†â€”â€†â€†\nEach page footer contains an \"\nEdit on GitHub\n\" Link. Change the markdown, make a pull request, and we'll merge it!\nDocs Repo\nJoin our Discord Server \nCheck out the Changelog\nFollow @Railway on X\nLearn on @Railway TV"
  },
  {
    "url": "https://docs.railway.app/community/the-conductor-program",
    "title": "The Conductor Program | Railway Docs",
    "content": "The Conductor Program\nThe Conductor Program brings together the amazing people who make Railway's community special. Conductors shepherd the experience for our 45K+ community members. They are the bridge between the Railway team and our thriving community.\n\n\nThis program aims to foster collaboration and help our Conductors grow.\n\n\nWhat Do Conductors Do?\n\n\nOur Conductors spend time in Discord and the Central Station answering questions, sharing tips, and making sure everyone can use Railway successfully.\n\n\nHere are a few key ways they contribute -\n\n\n\n\n\n\nProviding community support through \nDiscord\n and the \nCentral Station\n.\n\n\n\n\n\n\nMaintaining a healthy and welcoming community atmosphere while moderating our channels and templates.\n\n\n\n\n\n\nContributing to Railway's open-source projects through improvements and new features.\n\n\n\n\n\n\nCreating a direct feedback loop between users and the Railway team.\n\n\n\n\n\n\nThrough these activities, Conductors ensure everyone can use Railway successfully while helping to build a collaborative and supportive community environment.\n\n\nReady to Become a Conductor?\n\n\nAre you passionate about helping others and love being part of Railway's community? We're always excited to welcome new Conductors who share our enthusiasm for community engagement!\n\n\nHere's what we look for in potential Conductors -\n\n\n\n\n\n\nHave demonstrated experience with Railway's platform and services.\n\n\n\n\n\n\nShow a consistent track record of helping others in our community.\n\n\n\n\n\n\nMaintain professional and friendly communication.\n\n\n\n\n\n\nAre active participants in our Discord and Central Station.\n\n\n\n\n\n\nDemonstrate strong technical problem-solving abilities.\n\n\n\n\n\n\nThe ideal Conductor combines technical expertise with mentorship skills to help our community thrive!\n\n\nApply Now\n\n\nConductor Benefits\n\n\nBeing a Conductor comes with several exciting perks and rewards to recognize your valuable contributions to the community.\n\n\nAs part of the program, conductors will receive -\n\n\n\n\n\n\n100% off discount for the Hobby plan's subscription and resource costs.\n\n\n\n\n\n\nCash payouts for solving complex issues for users.\n\n\n\n\n\n\nThe opportunity to earn payouts for OSS contributions (\nCLI\n, \nNixpacks\n, \nDocs\n, etc).\n\n\n\n\n\n\nFirst access to \ntemplate bounties\n.\n\n\n\n\n\n\nLetters of recommendation for educational institutions and employer references.\n\n\n\n\n\n\nModeration status on \nDiscord\n and the \nCentral Station\n.\n\n\n\n\n\n\nAccess to a team workspace shared with other Conductors.\n\n\n\n\n\n\nA direct line to the team via the private Conductor only channel.\n\n\n\n\n\n\nYour choice of \nRailway Swag\n.\n\n\n\n\n\n\nAnd to top it all off, each quarter we reward our most outstanding conductor with a pizza party! ðŸŽ‰\n\n\nConductor Participation\n\n\nWe believe in fostering an active and supportive Conductor program that enables everyone to make meaningful contributions. To help keep our community vibrant, we conduct friendly quarterly check-ins with all Conductors.\n\n\nAs a Conductor, you'll contribute regularly in these key areas -\n\n\n\n\n\n\nCommunity Engagement\n\n\n\n\n\n\nBeing an active, welcoming presence in community channels.\n\n\n\n\n\n\nBuilding connections with fellow community members.\n\n\n\n\n\n\nJoining community conversations and sharing experiences.\n\n\n\n\n\n\nLooking out for the community by making sure discussions stay positive and helpful.\n\n\n\n\n\n\n\n\n\n\nSupport Activities\n\n\n\n\n\n\nHelping others in \nDiscord\n and the \nCentral Station\n.\n\n\n\n\n\n\nShowing consistent engagement by regularly contributing to meaningful solutions across all Railway platforms.\n\n\n\n\n\n\n\n\n\n\nOpen Source Contributions\n\n\n\n\n\n\nContributing through either small improvements or substantial feature additions.\n\n\n\n\n\n\nNew features should address community-requested needs with demonstrated user demand.\n\n\n\n\n\n\nBug fixes should focus on issues affecting multiple users.\n\n\n\n\n\n\n\n\n\n\nWe understand that maintaining consistent participation across these areas requires dedication and time. As part of our commitment to supporting Conductors, we have quarterly check-ins to discuss your experience and ensure you have everything needed to succeed.\n\n\nWhile we aim for regular engagement, we recognize that life circumstances and priorities can change. If participation becomes limited, we may need to transition members out of the program during our bi-annual review. However, our door always remains open â€“ former Conductors are welcome to rejoin the program when their schedule better accommodates regular participation!\nPrev\n \nMigrate from DigitalOcean\nEdit this file on GitHub\nOn This Page\nWhat Do Conductors Do?\nReady to Become a Conductor?\nConductor Benefits\nConductor Participation"
  },
  {
    "url": "https://docs.railway.app/deploy/deployments",
    "title": "Deployments | Railway Docs",
    "content": "Deployments\nLet's configure your deployments!\n\n\nNow that you understand how to tailor your builds if necessary, let's get into the various ways you can control how your services are deployed and run.  Like builds, when you deploy a service, Railway will apply some defaults that can easily be overridden when necessary.\n\n\nDeployment Concepts\n\n\nDeployment Controls\nDeployments are attempts to build and run your code.  Railway provides controls for changing the default run behavior, and for acting on existing deployments, for example rolling back to a previous deployment or restarting a service.\nAuto Deploys\nIf you have deployed from your GitHub repo, we will automatically build and deploy your code when you push a change to the connected branch.\nRegional Deployments\nBy default, services are deployed to your \npreferred region\n. To optimize performance for your users in other parts of the world, we offer regional deployments.\nScaling\nScaling your application has never been so easy.  Vertical auto-scaling is performed without any configuration on your part.  Horizontal scaling is made possible with replicas.\nHealthchecks\nHealthchecks can be configured on your services to control when a new deployment is deemed healthy and ready for connections.\nMonorepos\nUsing a monorepo?  We do too!  To deploy your monorepo, you'll need to let us know how your repo is structured using the various configuration options.\nScheduled Jobs\nScheduled Jobs, or Cron Jobs, are pieces of code that are executed on a schedule.  You'll find it's easy to schedule a job to run, using our Cron Schedule configuration.\nUsage Optimization\nGive yourself some peace of mind by using the various controls to tighten your usage.  You can set Usage Limits and configure your deployments to auto-sleep when inactive.\n\n\nDive into the next pages to learn how to configure these items.\nPrev\n \nDockerfiles\nNext\n \nPre-Deploy Command\nEdit this file on GitHub\nOn This Page\nDeployment Concepts"
  },
  {
    "url": "https://docs.railway.app/deploy/healthchecks",
    "title": "Healthchecks | Railway Docs",
    "content": "Healthchecks\nHealthchecks can be used to guarantee zero-downtime \ndeployments\n of your \nservice\n by ensuring the new version is live and able to handle requests.\n\n\nHow it Works\n\n\nWhen a new deployment is triggered for a service, if a healthcheck endpoint is configured, Railway will query the endpoint until it receives an HTTP \n200\n response.  Only then will the new deployment be made active and the previous deployment inactive.\n\n\nNote About Continuous Monitoring\n\n\nThe healthcheck endpoint is currently \nnot intended for continuous monitoring\n as it is only called at the start of the deployment, to ensure it is healthy prior to routing traffic to it.\n\n\nIf you are looking for a quick way to setup continuous monitoring of your service(s), check out the \nUptime Kuma template\n in our template marketplace.\n\n\nHealthcheck Timeout\n\n\nThe default timeout on healthchecks is 300 seconds (5 minutes). If your application fails to serve a \n200\n status code during this allotted time, the deploy will be marked as failed.\n\n\nThis timeout is configurable in the service settings.\n\n\nSupport\n\n\nFor information on how to configure healthchecks, click \nhere\n.\nPrev\n \nDockerfiles\nNext\n \nBackups\nEdit this file on GitHub\nOn This Page\nHow it Works\nNote About Continuous Monitoring\nHealthcheck Timeout\nSupport"
  },
  {
    "url": "https://docs.railway.app/dynamic/reference/errors/enotfound-redis-railway-internal",
    "title": "ENOTFOUND redis.railway.internal | Railway Docs",
    "content": "ENOTFOUND redis.railway.internal\nWhat This Error Means\n\n\nThe error code \nENOTFOUND\n means that your application could not resolve the \nredis.railway.internal\n hostname to an IP address when trying to connect to the Redis database.\n\n\nWhy This Error Can Occur\n\n\nThis error can occur for a few different reasons, but the main reason is because your application uses the \nioredis\n package to connect to the Redis database, or uses a package that uses ioredis as a dependency such as \nbullmq\n.\n\n\nBy default, ioredis will only do an IPv4 (A record) lookup for the \nredis.railway.internal\n hostname.\n\n\nThat presents a problem given that Railway's private network uses only IPv6 (AAAA records).\n\n\nThe lookup will fail because the A records for \nredis.railway.internal\n do not exist.\n\n\nSome other reasons that this error can occur would be -\n\n\n\n\n\n\nYour application and Redis database are in different projects.\n\n\n\n\n\n\nYou are trying to connect to a Redis database locally with the private hostname and port.\n\n\n\n\n\n\nFor either of these reasons, the issue arises because the private network is scoped to a single environment within a \nproject\n, and would not be accessible from your local machine or other projects.\n\n\nIf the Redis database is in the same project as your application, and you are not trying to connect to a Redis database locally, \nioredis\n is the likely cause of the error.\n\n\nSolutions\n\n\nThe solution depends on the package you are using to connect to the Redis database, though the solution is the same for both.\n\n\nioredis\n\n\nUsing ioredis directly in your application\n\n\nioredis\n has an option to do a dual stack lookup, which will try to resolve the \nredis.railway.internal\n hostname using both IPv4 and IPv6 addresses (A and AAAA records).\n\n\nTo enable this, in your \nREDIS_URL\n environment variable, you can set the \nfamily\n to \n0\n to enable dual stack lookup.\n\n\nimport\n Redis \nfrom\n \n'ioredis'\n;\n\n\n\n\nconst\n redis \n=\n \nnew\n \nRedis\n(\nprocess\n.\nenv\n.\nREDIS_URL\n \n+\n \n'?family=0'\n)\n;\n\n\n\n\nconst\n ping \n=\n \nawait\n redis\n.\nping\n(\n)\n;\n\n\nUsing bullmq\n\n\nSimilarly, for \nbullmq\n since it uses \nioredis\n as a dependency, you can set the \nfamily\n option to \n0\n in your connection object.\n\n\nimport\n \n{\n Queue \n}\n \nfrom\n \n\"bullmq\"\n;\n\n\n\n\nconst\n redisURL \n=\n \nnew\n \nURL\n(\nprocess\n.\nenv\n.\nREDIS_URL\n)\n;\n\n\n\n\nconst\n queue \n=\n \nnew\n \nQueue\n(\n\"Queue\"\n,\n \n{\n\n\n    \nconnection\n:\n \n{\n\n\n        \nfamily\n:\n \n0\n,\n\n\n        \nhost\n:\n redisURL\n.\nhostname\n,\n\n\n        \nport\n:\n redisURL\n.\nport\n,\n\n\n        \nusername\n:\n redisURL\n.\nusername\n,\n\n\n        \npassword\n:\n redisURL\n.\npassword\n\n    \n}\n\n\n}\n)\n;\n\n\n\n\nconst\n jobs \n=\n \nawait\n queue\n.\ngetJobs\n(\n)\n;\n\n\n\n\nconsole\n.\nlog\n(\njobs\n)\n;\n\n\nOther packages\n\n\nAbove we covered the two most common packages that can cause this error, but there are other packages that use \nioredis\n as a dependency that may also cause this error.\n\n\nIf you are using a package that uses \nioredis\n as a dependency, you can try to find a way to set the \nfamily\n option to \n0\n either in your connection object or in your \nREDIS_URL\n environment variable. Similar to the examples above.\n\n\nRedis database in a different project\n\n\nCreate a \nnew Redis database\n in the same \nproject\n as your application, and connect it to the Redis database using the private network as shown in the examples above.\n\n\nRead about best pracices to get the most out of the platform \nhere\n.\n\n\nConnecting to a Redis database locally\n\n\nThe easiest way to connect to a Redis database locally is to use the public network.\n\n\nYou can do this is by using the \nREDIS_PUBLIC_URL\n environment variable to connect to the Redis database.\n\n\nimport\n Redis \nfrom\n \n'ioredis'\n;\n\n\n\n\nconst\n redis \n=\n \nnew\n \nRedis\n(\nprocess\n.\nenv\n.\nREDIS_PUBLIC_URL\n)\n;\n\n\n\n\nconst\n ping \n=\n \nawait\n redis\n.\nping\n(\n)\n;\nNext\n \nHome\nEdit this file on GitHub\nOn This Page\nWhat This Error Means\nWhy This Error Can Occur\nSolutions\nioredis\nUsing ioredis directly in your application\nUsing bullmq\nOther packages\nRedis database in a different project\nConnecting to a Redis database locally"
  },
  {
    "url": "https://docs.railway.app/dynamic/reference/errors/nixpacks-was-unable-to-generate-a-build-plan",
    "title": "Nixpacks Was Unable to Generate a Build Plan for This App | Railway Docs",
    "content": "Nixpacks Was Unable to Generate a Build Plan for This App\nWhat This Error Means\n\n\nRailway uses \nNixpacks\n to analyze your application's files to generate a container image for your application.\n\n\nSeeing the \nNixpacks was unable to generate a build plan for this app\n error means that Nixpacks was unable to corelate your application's files with a supported build plan.\n\n\nA build plan is a set of pre defined instructions that Nixpacks uses to build and run your application on the Railway platform.\n\n\nA list of supported build plans can be found \nhere\n under the \nLanguage Support\n section.\n\n\nWhy This Error Can Occur\n\n\nThis error can occur for a variety of reasons, here are some common ones and what the failed build logs could look like for each scenario -\n\n\n\n\n\n\nYou are attempting to deploy a monorepo.\n\n\nThe contents of the app directory are:\n\n\n\n/frontend\n\n/backend\n\n\nNixpacks doesn't know which directory you want to deploy from.\n\n\n\n\n\n\nYour application's files and or directory structure do not match any of the supported build plans.\n\n\nThe contents of the app directory are:\n\n\n\nweb.py\n\nrequirements.txt\n\n\nThis is obviously Python, a supported language, but Nixpacks doesn't know exactly to do with just a \nweb.py\n file since it was never explicitly programmed to handle this.\n\n\n\n\n\n\nYour application is using a language or framework that is not supported by Nixpacks.\n\n\nThe contents of the app directory are:\n\n\n\nmain.nim\n\nnimble.nimble\n\n\nThis is \nNim\n, but unfortunately, Nixpacks doesn't have a build plan for Nim.\n\n\n\n\n\n\nPossible Solutions\n\n\nMonorepo Without Root Directory\n\n\nIf you are attempting to deploy a monorepo, you will need to set a \nroot directory\n in your \nservice settings\n under the source repository section.\n\n\nFor a comprehensive guide on how to deploy a monorepo, please refer to our \nDeploying a Monorepo\n guide.\n\n\nUnsupported Project Layout or Directory Structure\n\n\nWhile you may be using a language or framework that is supported by Nixpacks, the project layout or directory structure of your application may not be natively supported.\n\n\nFor example, if you are using Python but Python was not automatically detected, you can write your own \nbuild plan\n.\n\n\nIn a \nnixpacks.toml\n file -\n\n\nproviders\n \n=\n \n[\n\"python\"\n]\n \n# Tell Nixpacks to use the Python build plan\n\n\n\n\n[\nstart\n]\n\n\ncmd\n \n=\n \n\"python web.py\"\n \n# Tell Nixpacks to start your web.py file\n\n\nOf course, this is just an example, but you can see how you can write your own build plan to support your application.\n\n\nSupported Languages (Providers) can be found \nhere\n under the \nLanguage Support\n section.\n\n\nIf writing your own build plan is not an option, you can try to deploy your application using a \nDockerfile\n.\n\n\nLanguage or Framework Not Supported\n\n\nIf you believe your application should be supported, please \ncreate an issue\n on the Nixpacks GitHub repository.\n\n\nTo unblock yourself, you can try to deploy your application using a \nDockerfile\n.\n\n\nIf your project contains a \nDockerfile\n Railway will automatically use it to build your application.\n\n\nRead more about \nusing a Dockerfile\n.\nNext\n \nHome\nEdit this file on GitHub\nOn This Page\nWhat This Error Means\nWhy This Error Can Occur\nPossible Solutions\nMonorepo Without Root Directory\nUnsupported Project Layout or Directory Structure\nLanguage or Framework Not Supported"
  },
  {
    "url": "https://docs.railway.app/dynamic/tutorials/github-actions-runners",
    "title": "GitHub Actions Self Hosted Runners | Railway Docs",
    "content": "GitHub Actions Self Hosted Runners\n\n\nDeploying \nGitHub Actions Self Hosted Runners\n on Railway is an excellent way to run your own CI infrastructure because you only \npay for what you use\n. With self-hosted runners, you also unlock the ability to cache expensive and time-consuming dependencies (\nnode_modules\n, \ncargo\n, etc.) or large git repositories. Best of all, Railway's built-in \nreplicas\n means you can scale your runners horizontally, or even distribute them to different regions with just a click and redeploy. You'll save build times and costs over using standard runners, \nAND\n you'll unlock more sophistocated workflows to streamline building your app.\n\n\nIn this guide you'll learn:\n\n\n\n\nThe basics to deploy a GitHub Actions Self Hosted Runner on Railway.\n\n\nHow to authenticate self-hosted runners on Railway with your GitHub Organization or Enterprise.\n\n\nHow to scale up \nreplicas\n to serve bigger Actions workloads.\n\n\nBest Practices for configuring your self-hosted runners on Railway.\n\n\n\n\nQuickstart:\n \nDeploy your self-hosted Runners with our Railway template\n.\n\n\nDeploy a GitHub self-hosted runner on Railway\n\n\n\n\n\n\nNavigate to the \nGitHub Actions self-hosted Runner Template\n. You'll notice the template requires an \nACCESS_TOKEN\n. This token, along with our \nRUNNER_SCOPE\n will determine \nwhere\n our self-hosted runners get registered on GitHub. Thankfully, this template supports self registration of your runners -- which means you can dynamically scale up or down the number of runners you have just by adjusting your \nreplicas\n!\n\n\n\n\n\n\nSet your \nRUNNER_SCOPE\n to \norg\n. We want to set up our self-hosted runners to register with a GitHub Organization, so any repositories within our organization can use the same pool of runners. This is super useful because you don't have to set up permissions for every single repository!\n\n\n\n\n\n\nIf you have a GitHub Enterprise, you can similarly set up your runners using an \nACCESS_TOKEN\n, you just need to set your \nRUNNER_SCOPE\n as \nent\n instead.\n\n\nIf you need additional configuration, then you can simply \nadd a variable to your Service\n.\n\n\nSetup a GitHub ACCESS_TOKEN\n\n\nFor this guide, we will create a new \nGitHub Fine-Grained Personal Access Token\n. These are modern personal access tokens that obey the \nprinciple of least priviledge\n, making them easy to secure, revoke, and audit!\n\n\nNote:\n You need to have Admin access to the organization for which you are making the \nACCESS_TOKEN\n.\n\n\n\n\n\n\nCreate a new fine-grained personal access token. \nNavigate to your Settings -> Developer Settings -> Personal Access Token -> Fine-grained tokens -> Generate New Token\n\n\nSet the Resource owner as your Organization. Alternatively, if you are using a \nent\n \nRUNNER_SCOPE\n, select your Enterprise.\n\n\nSet Expiration\n\n\nUnder Permissions, Select Organization Permissions -> Self Hosted Runners -> Read and Write (If Enterprise, select Enterprise instead).\n\n\nClick Generate. Save your \nACCESS_TOKEN\n in a safe place! You won't see it again. (Save it in a Password Vault as an API Key!)\n\n\nDONE. You don't need any other permissions!\n\n\n\n\nScaling up your Railway Self Hosted Runners\n\n\n\n\n\n\nNavigate to the Settings tab of your Service to the Region area.\n\n\nChange the number next to your region from \n1\n to your desired number of replicas.\n\n\nClick Deploy.\n\n\nDone! Your new replicas will automatically spin up and register themselves with GitHub.\n\n\n\n\nView Your Registered Self Hosted Runners\n\n\n\n\nYou can view all your runners by navigating to your organization's Actions -> Runners page at \nhttps://github.com/organizations/(your-organization-name)/settings/actions/runners?page=1\n\n\nRouting Actions Jobs\n\n\nYou can route jobs by simply changing the \nLABELS\n variable. By default, we include the \nrailway\n label on runners you make through the \nTemplate\n. \nLABELS\n is a comma (no spaces) delimited list of all the labels you want to appear on that runner. This enables you to \nroute jobs\n with the specificity that your workflows need, while still allowing you to make runners available for your entire Organization.\n\n\nSetting up GitHub Actions workflows for Pull Requests\n\n\nGitHub Actions uses workflow files located in \n.github/workflows/<workflow>.yml\n. You can easily incorporate pre-built steps to get up-and-running quickly.\n\n\n\n\n\n\nWhen you want to run a workflow every time a pull request is opened, set the \non\n key to \npull_request\n in your \n.github/workflows/<workflow>.yml\n.\n\n\n\n\n\n\nSet the \nruns-on\n key when you want to route your workflow job to a particular runner. Use a comma delimited list for greater specificity. For example, a \n[self-hosted, linux, x86, railway]\n workflow needs to match all labels to an appropriate runner in order to route the job correctly.\n\n\n\n\n\n\nExample GitHub Actions Workflow\n\n\nIf you've never made a workflow before, here is a basic out-of-the-box example of a NuxtJS project using Bun to execute an \neslint\n check.\n\n\nname: eslint check\n\n\non:\n  pull_request:\n    branches:\n      - main\n\npermissions:\n  contents: read\n\njobs:\n  build:\n    name: Check\n    runs-on: [self-hosted, railway]\n\n    steps:\n      - name: Checkout\n        uses: actions/checkout@v4\n        with:\n          token: ${{ secrets.GITHUB_TOKEN }}\n\n      - name: Install bun\n        uses: oven-sh/setup-bun@v2\n\n      - name: Set up Node\n        uses: actions/setup-node@v4\n        with:\n          node-version: 22\n\n      - name: Cache Files\n        uses: actions/cache@v4\n        with:\n          path: |\n            ~/.bun/install/cache\n            path: ${{ github.workspace }}/**/node_modules\n            path: ${{ github.workspace }}/**/.nuxt\n          key: ${{ runner.os }}-bun-${{ hashFiles('**/bun.lock', 'nuxt.config.ts', 'app.config.ts', 'app.vue') }}\n\n      - name: Install packages\n        run: bun install --prefer-offline\n\n      - name: Lint\n        run: bun run lint\n\n\nBest Practices\n\n\n\n\n\n\nOnly use private repositories and disable forks:\n Make sure when using self-hosted runners, that you only attach them to private repositories. A known attack vector is for a malicious actor to fork a public repository and then exfiltrate your private keys from your self-hosted runners by executing workflows on them. Disabling forks can also mitigate this attack, and it's a good idea in general for locking down security on your repositories!\n\n\n\n\n\n\nSeal your \nACCESS_KEY\n:\n While all variables are encrypted on Railway, you can prevent prying eyes (including your future self) from ever viewing your API Key. Navigate to the Variables tab and next to the \nACCESS_KEY\n variable click the three-dots-menu \n...\n -> \nSeal\n. Make sure your \nACCESS_KEY\n is stored in a secure Password Vault before doing this!\n\n\n\n\n\n\nSecurity Harden your self-hosted Runners:\n \nSecurity Hardening\n will make your runners robust and prevent any concerns about your build infrastructure. GitHub's \ndetailed guide\n can help you secure secrets, authentication, auditing, and managing your runners. Similarly \ndduzgun-security\n and \nWiz\n both have excellent guides to securing your runners that are worth your time.\n\n\n\n\n\n\nKnown Limitations\n\n\n\n\n\n\nBecause Railway containers are non-priveleged, GitHub Workflows that \nbuild-and-then-mount\n containers on the same host (i.e. Docker-in-Docker) will fail.\n\n\n\n\n\n\nUsing the Serverless Setting on this Service is \nnot\n recommended and will result in idle runners disconnecting from GitHub and needing to reauthenticate. GitHub Runners have a 50 second HTTP longpoll which keeps them alive. While the runners in this template can automatically reauth with an \nACCESS_TOKEN\n it will result in unnecessary offline / abandoned runners. If you want your runners to deauthenticate and spin down, consider using ephemeral runners instead.\n\n\n\n\n\n\nTroubleshooting self-hosted runner communication\n\n\n\n\nA self-hosted runner connects to GitHub to receive job assignments and to download new versions of the runner application. The self-hosted runner uses an HTTPS long poll that opens a connection to GitHub for 50 seconds, and if no response is received, it then times out and creates a new long poll. The application must be running on the machine to accept and run GitHub Actions jobs.\n\n\n\n\nGitHub's \ndocumentation details all of the different endpoints\n your self-hosted runner needs to communicate with. If you are operating in a \nGitHub Allow List\n environment you must add your self-hosted runners IP Address to this allow list for communication to work.\n\n\nIf you are using a \nproxy server\n, refer to GitHub's documentation on configuring your self-hosted runner. You can simply add the required environment variables by adding them to the Variables tab of your Service.\n\n\nCost Comparison\n\n\nOn Railway you only \npay for what you use\n, so you'll find your GitHub workflows are significantly cheaper. For this guide we tested over ~2,300 1 minute builds on Railway self-hosted runners and our usage costs were \n$1.80\n compared to \nGitHub's Estimated Hosted Runner\n cost of \n$18.40\n for the same workload. Even better? We had 10x Railway replicas with 32 vCPU and 32GB RAM for this test, meaning that our actions workflows would never slow down.\n\n\nOn other platforms you pay for the \nmaximum available\n vCPUs and Memory. On Railway, you're only paying for usage, or in the below screenshot, the filled in purple area. This enables your workloads to still burst up to the \nmaximum available\n resources you have configured, with no tradeoffs on cost.\n\n\nNext\n \nHome\nEdit this file on GitHub\nOn This Page\nDeploy a GitHub self-hosted runner on Railway\nSetup a GitHub ACCESS_TOKEN\nScaling up your Railway Self Hosted Runners\nView Your Registered Self Hosted Runners\nRouting Actions Jobs\nSetting up GitHub Actions workflows for Pull Requests\nExample GitHub Actions Workflow\nBest Practices\nKnown Limitations\nTroubleshooting self-hosted runner communication\nCost Comparison"
  },
  {
    "url": "https://docs.railway.app/guides/angular",
    "title": "Deploy an Angular App | Railway Docs",
    "content": "Deploy an Angular App\nAngular\n is a JavaScript web framework that empowers developers to build fast and reliable applications. It is designed to work at any scale, keep large teams productive and is proven in some of Google's largest web apps such as \nGoogle fonts\n and \nGoogle Cloud\n.\n\n\nThis guide covers how to deploy an Angular app to Railway in four ways:\n\n\n\n\nOne-click deploy from a template\n\n\nFrom a GitHub repository\n\n\nUsing the CLI\n\n\nUsing a Dockerfile\n\n\n\n\nNow, let's create an Angular app!\n\n\nCreate an Angular App\n\n\nNote:\n If you already have an Angular app locally or on GitHub, you can skip this step and go straight to the \nDeploy Angular App on Railway\n.\n\n\nTo create a new Angular app, ensure that you have \nNode\n and \nAngular CLI\n installed on your machine.\n\n\nRun the following command in your terminal to create a new Angular app:\n\n\nng new gratitudeapp\n\n\nYou'll be presented with some config options in the prompts for your project.\n\n\n\n\nSelect \nCSS\n\n\nSelect \nYes\n for enabling Server-Side Rendering (SSR) and Static Site Generation (SSG)\n\n\nSelect \nYes\n for enabling Server Routing and App Engine APIs (Developer Preview)\n\n\n\n\nRun the Angular App locally\n\n\nNext, \ncd\n into the directory and run the app.\n\n\nnpm\n start\n\n\nOpen your browser and go to \nhttp://localhost:4200\n to see your app.\n\n\nModify Start Script\n\n\nBefore deploying, we need to update the \npackage.json\n file.\n\n\nAngular builds the project into the \ndist\n directory. For server-side rendered apps, the server starts with the command: \nnode dist/gratitudeapp/server/server.mjs\n as defined in the scripts section below:\n\n\n\"scripts\"\n:\n \n{\n\n\n    \n\"ng\"\n:\n \n\"ng\"\n,\n\n\n    \n\"start\"\n:\n \n\"ng serve\"\n,\n\n\n    \n\"build\"\n:\n \n\"ng build\"\n,\n\n\n    \n\"watch\"\n:\n \n\"ng build --watch --configuration development\"\n,\n\n\n    \n\"test\"\n:\n \n\"ng test\"\n,\n\n\n    \n\"serve:ssr:gratitudeapp\"\n:\n \n\"node dist/gratitudeapp/server/server.mjs\"\n\n\n  \n}\n,\n\n\n\n\nThe development server starts with \nnpm start\n.\n\n\nThe production server runs with \nnpm run serve:ssr:gratitudeapp\n.\n\n\n\n\nSince Railway relies on the \nbuild\n and \nstart\n scripts to automatically build and launch applications, we need to update the \nstart\n script to ensure it runs the production server correctly.\n\n\nYour scripts section should look like this:\n\n\n...\n\n\n\"scripts\"\n:\n \n{\n\n\n    \n\"ng\"\n:\n \n\"ng\"\n,\n\n\n    \n\"dev\"\n:\n \n\"ng serve\"\n,\n\n\n    \n\"build\"\n:\n \n\"ng build\"\n,\n\n\n    \n\"watch\"\n:\n \n\"ng build --watch --configuration development\"\n,\n\n\n    \n\"test\"\n:\n \n\"ng test\"\n,\n\n\n    \n\"start\"\n:\n \n\"node dist/gratitudeapp/server/server.mjs\"\n\n\n  \n}\n,\n\n\n...\n\n\nNow, we are good to go!\n\n\nDeploy the Angular App to Railway\n\n\nRailway offers multiple ways to deploy your Angular app, depending on your setup and preference.\n\n\nOne-Click Deploy from a Template\n\n\nIf youâ€™re looking for the fastest way to get started, the one-click deploy option is ideal.\n\n\nClick the button below to begin:\n\n\n\n\nWe highly recommend that \nyou eject from the template after deployment\n to create a copy of the repo on your GitHub account.\n\n\nNote:\n You can also choose from a \nvariety of Angular app templates\n created by the community.\n\n\nDeploy from the CLI\n\n\n\n\nInstall the Railway CLI\n:\n\n\n\n\nInstall the CLI\n and \nauthenticate it\n using your Railway account.\n\n\n\n\n\n\nInitialize a Railway Project\n:\n\n\n\n\nRun the command below in your Angular app directory.\n\n\nrailway init\n\n\n\n\nFollow the prompts to name your project.\n\n\nAfter the project is created, click the provided link to view it in your browser.\n\n\n\n\n\n\nDeploy the Application\n:\n\n\n\n\nUse the command below to deploy your app:\n\n\nrailway up\n\n\n\n\nThis command will scan, compress and upload your app's files to Railway. Youâ€™ll see real-time deployment logs in your terminal.\n\n\nOnce the deployment completes, go to \nView logs\n to check if the service is running successfully.\n\n\n\n\n\n\nSet Up a Public URL\n:\n\n\n\n\nNavigate to the \nNetworking\n section under the \nSettings\n tab of your new service.\n\n\nClick \nGenerate Domain\n to create a public URL for your app.\n\n\n\n\n\n\n\n\n\n\nDeploy from a GitHub Repo\n\n\nTo deploy an Angular app to Railway directly from GitHub, follow the steps below:\n\n\n\n\nCreate a New Project on Railway\n:\n\n\n\n\nGo to \nRailway\n to create a new project.\n\n\n\n\n\n\nDeploy from GitHub\n:\n\n\n\n\nSelect \nDeploy from GitHub repo\n and choose your repository.\n\n\n\n\nIf your Railway account isnâ€™t linked to GitHub yet, youâ€™ll be prompted to do so.\n\n\n\n\n\n\n\n\n\n\nDeploy the App\n:\n\n\n\n\nClick \nDeploy\n to start the deployment process.\n\n\nOnce the deployed, a Railway \nservice\n will be created for your app, but it wonâ€™t be publicly accessible by default.\n\n\n\n\n\n\nVerify the Deployment\n:\n\n\n\n\nOnce the deployment completes, go to \nView logs\n to check if the server is running successfully.\n\n\n\n\n\n\nSet Up a Public URL\n:\n\n\n\n\nNavigate to the \nNetworking\n section under the \nSettings\n tab of your new service.\n\n\nClick \nGenerate Domain\n to create a public URL for your app.\n\n\n\n\n\n\n\n\nUse a Dockerfile\n\n\n\n\nCreate a \nDockerfile\n in the \ngratitudeapp\n or Angular app's root directory.\n\n\nAdd the content below to the \nDockerfile\n:\n\n\n# Use the Node alpine official image\n\n\n# https://hub.docker.com/_/node\n\n\nFROM\n node:lts-alpine\n\n\n\n\n# Create and change to the app directory.\n\n\nWORKDIR\n /app\n\n\n\n\n# Copy the files to the container image\n\n\nCOPY\n package*.json ./\n\n\n\n\n# Install packages\n\n\nRUN\n npm ci\n\n\n\n\n# Copy local code to the container image.\n\n\nCOPY\n . ./\n\n\n\n\n# Build the app.\n\n\nRUN\n npm run build\n\n\n\n\n# Serve the app\n\n\nCMD\n [\n\"npm\"\n, \n\"run\"\n, \n\"start\"\n]\n\n\n\n\nEither deploy via the CLI or from GitHub.\n\n\n\n\nRailway automatically detects the \nDockerfile\n, \nand uses it to build and deploy the app.\n\n\nNote:\n Railway supports also \ndeployment from public and private Docker images\n.\n\n\nThis guide covers the main deployment options on Railway. Choose the approach that suits your setup, and start deploying your Angular apps seamlessly!\n\n\nNext Steps\n\n\nExplore these resources to learn how you can maximize your experience with Railway:\n\n\n\n\nAdd a Database Service\n\n\nMonitor your app\n\n\nPrev\n \nDjango\nNext\n \nReact\nEdit this file on GitHub\nOn This Page\nCreate an Angular App\nRun the Angular App locally\nModify Start Script\nDeploy the Angular App to Railway\nOne-Click Deploy from a Template\nDeploy from the CLI\nDeploy from a GitHub Repo\nUse a Dockerfile\nNext Steps"
  },
  {
    "url": "https://docs.railway.app/guides/astro",
    "title": "Deploy an Astro App | Railway Docs",
    "content": "Deploy an Astro App\nAstro\n is the web framework for content-driven websites. It's a JavaScript framework optimized for building fast, content-driven websites. It also supports every major UI framework, allowing you to bring in your existing components and benefit from Astro's optimized client build performance.\n\n\nThis guide covers how to deploy an Astro app to Railway in four ways:\n\n\n\n\nOne-click deploy from a template\n.\n\n\nFrom a GitHub repository\n.\n\n\nUsing the CLI\n.\n\n\nUsing a Dockerfile\n.\n\n\n\n\nNow, let's create an Astro app!\n\n\nCreate an Astro App\n\n\nNote:\n If you already have an Astro app locally or on GitHub, you can skip this step and go straight to the \nDeploy Astro Apps on Railway\n.\n\n\nTo create a new Astro app, ensure that you have \nNode\n installed on your machine.\n\n\nRun the following command in your terminal to create a new Astro app:\n\n\nnpm\n create astro@latest\n\n\nFollow the prompts and provide a directory name, such as \nblog\n, where you'd like to set up your app.\n\n\nWhen prompted to choose how you'd like to start your project, select \nUse blog template\n. For TypeScript, choose \nYes\n.\n\n\nFor the remaining options, select the defaults and press Enter. All necessary dependencies will then be installed.\n\n\nA new Astro app will be provisioned for you in the \nblog\n directory.\n\n\nRun the Astro App Locally\n\n\nEnter your project directory using \ncd blog\n.\n\n\nStart the local dev server by running the following command:\n\n\nnpm\n run dev\n\n\nOpen your browser and go to \nhttp://localhost:4321\n to see your app.\n\n\nEnable Server Side Rendering (SSR)\n\n\nAstro has several \nSSR adapters\n. These adapters are used to run your project on the server and handle SSR requests.\n\n\nLet's add the Node adapter to enable SSR in our blog project.\n\n\nRun the command below in your terminal:\n\n\nnpx astro \nadd\n \nnode\n\n\nSelect \nYes\n at the prompt to proceed. The Node adapter will be installed, and our Astro config file will be updated accordingly.\n\n\nOpen up the \nastro.config.mjs\n file:\n\n\n// @ts-check\n\n\nimport\n \n{\n defineConfig \n}\n \nfrom\n \n'astro/config'\n;\n\n\nimport\n mdx \nfrom\n \n'@astrojs/mdx'\n;\n\n\n\n\nimport\n sitemap \nfrom\n \n'@astrojs/sitemap'\n;\n\n\n\n\nimport\n node \nfrom\n \n'@astrojs/node'\n;\n\n\n\n\n// https://astro.build/config\n\n\nexport\n \ndefault\n \ndefineConfig\n(\n{\n\n\n  \nsite\n:\n \n'https://example.com'\n,\n\n\n  \nintegrations\n:\n \n[\nmdx\n(\n)\n,\n \nsitemap\n(\n)\n]\n,\n\n\n  \noutput\n:\n \n'server'\n,\n\n\n\n\n  \nadapter\n:\n \nnode\n(\n{\n\n\n    \nmode\n:\n \n'standalone'\n,\n\n\n  \n}\n)\n,\n\n\n}\n)\n;\n\n\nIn the config file, \noutput\n is set to \nserver\n, meaning every page in the app is server-rendered by default.\n\n\nFor mostly static sites, set \noutput\n to \nhybrid\n. This allows you to add \nexport const prerender = false\n to any file that needs to be server-rendered on demand.\n\n\nModify Start Script and Astro Config\n\n\nAstro builds your project into a \ndist\n directory. In \nstandalone\n mode, a server starts when the server entry point is executed, which is by default located at \n./dist/server/entry.mjs\n.\n\n\nIn this mode, the server handles file serving as well as page and API routes.\n\n\nOpen up the \npackage.json\n file and modify the start script from \nastro dev\n to \nnode ./dist/server/entry.mjs\n.\n\n\n{\n\n\n    \n\"name\"\n:\n \n\"astroblog\"\n,\n\n\n    \n\"type\"\n:\n \n\"module\"\n,\n\n\n    \n\"version\"\n:\n \n\"0.0.1\"\n,\n\n\n    \n\"scripts\"\n:\n \n{\n\n\n        \n\"dev\"\n:\n \n\"astro dev\"\n,\n\n\n        \n\"start\"\n:\n \n\"node ./dist/server/entry.mjs\"\n,\n\n\n        \n\"build\"\n:\n \n\"astro check && astro build\"\n,\n\n\n        \n\"preview\"\n:\n \n\"astro preview\"\n,\n\n\n        \n\"astro\"\n:\n \n\"astro\"\n\n\n    \n}\n,\n\n\n    \n\"dependencies\"\n:\n \n{\n\n\n        \n\"@astrojs/check\"\n:\n \n\"^0.9.4\"\n,\n\n\n        \n\"@astrojs/mdx\"\n:\n \n\"^3.1.8\"\n,\n\n\n        \n\"@astrojs/node\"\n:\n \n\"^8.3.4\"\n,\n\n\n        \n\"@astrojs/rss\"\n:\n \n\"^4.0.9\"\n,\n\n\n        \n\"@astrojs/sitemap\"\n:\n \n\"^3.2.1\"\n,\n\n\n        \n\"astro\"\n:\n \n\"^4.16.6\"\n,\n\n\n        \n\"typescript\"\n:\n \n\"^5.6.3\"\n\n\n    \n}\n\n\n}\n\n\nOpen the \nastro.config.mjs\n file and configure the server to run on host \n0.0.0.0\n by adding the following block inside the \ndefineConfig\n function.\n\n\n...\n\n\nserver\n:\n \n{\n\n\n    \nhost\n:\n \n'0.0.0.0'\n\n\n}\n,\n\n\nYour app needs to listen on either \n0.0.0.0\n or \n::\n to accept traffic. If not configured properly, you'll encounter a 502 error.\n\n\nDeploy the Astro App to Railway\n\n\nRailway offers multiple ways to deploy your Astro app, depending on your setup and preference.\n\n\nOne-Click Deploy From a Template\n\n\nIf youâ€™re looking for the fastest way to get started, the one-click deploy option is ideal.\n\n\nClick the button below to begin:\n\n\n\n\nWe highly recommend that \nyou eject from the template after deployment\n to create a copy of the repo on your GitHub account.\n\n\nNote:\n You can also choose from a \nvariety of Astro app templates\n created by the community.\n\n\nDeploy From the CLI\n\n\n\n\nInstall the Railway CLI\n:\n\n\n\nInstall the CLI\n and \nauthenticate it\n using your Railway account.\n\n\n\n\n\n\nInitialize a Railway Project\n:\n\n\n\nRun the command below in your Vue app directory.\n\nrailway init\n\n\n\n\nFollow the prompts to name your project.\n\n\nAfter the project is created, click the provided link to view it in your browser.\n\n\n\n\n\n\nDeploy the Application\n:\n\n\n\nUse the command below to deploy your app:\n\nrailway up\n\n\n\n\nThis command will scan, compress and upload your app's files to Railway. Youâ€™ll see real-time deployment logs in your terminal.\n\n\nOnce the deployment completes, go to \nView logs\n to check if the service is running successfully.\n\n\n\n\n\n\nSet Up a Public URL\n:\n\n\n\nNavigate to the \nNetworking\n section under the \nSettings\n tab of your new service.\n\n\nClick \nGenerate Domain\n to create a public URL for your app.\n\n\n\n\n\n\n\n\n\n\nDeploy From a GitHub Repo\n\n\nTo deploy an Astro app to Railway directly from GitHub, follow the steps below:\n\n\n\n\nCreate a New Project on Railway\n:\n\n\n\nGo to \nRailway\n to create a new project.\n\n\n\n\n\n\nDeploy from GitHub\n:\n\n\n\nSelect \nDeploy from GitHub repo\n and choose your repository.\n\n\n\nIf your Railway account isnâ€™t linked to GitHub yet, youâ€™ll be prompted to do so.\n\n\n\n\n\n\n\n\n\n\nDeploy the App\n:\n\n\n\nClick \nDeploy\n to start the deployment process.\n\n\nOnce the deployed, a Railway \nservice\n will be created for your app, but it wonâ€™t be publicly accessible by default.\n\n\n\n\n\n\nVerify the Deployment\n:\n\n\n\nOnce the deployment completes, go to \nView logs\n to check if the server is running successfully.\n\n\n\n\n\n\nSet Up a Public URL\n:\n\n\n\nNavigate to the \nNetworking\n section under the \nSettings\n tab of your new service.\n\n\nClick \nGenerate Domain\n to create a public URL for your app.\n\n\n\n\n\n\n\n\nUse a Dockerfile\n\n\n\n\nCreate a \nDockerfile\n in the \nblog\n or Astro app's root directory.\n\n\nAdd the content below to the \nDockerfile\n:\n\n# Use the Node alpine official image\n\n\n# https://hub.docker.com/_/node\n\n\nFROM node:lts-alpine\n\n\n# Create and change to the app directory.\n\n\nWORKDIR /app\n\n\n# Copy the files to the container image\n\n\nCOPY package*.json ./\n\n\n# Install packages\n\n\nRUN \nnpm\n ci\n\n\n\n# Copy local code to the container image.\n\n\nCOPY \n.\n ./\n\n\n\n# Build the app.\n\n\nRUN \nnpm\n run build\n\n\n\n# Serve the app\n\n\nCMD \n[\n\"npm\"\n, \n\"run\"\n, \n\"start\"\n]\n\n\n\n\nEither deploy via the CLI or from GitHub.\n\n\n\n\nRailway automatically detects the \nDockerfile\n, \nand uses it to build and deploy the app.\n\n\nNote:\n Railway supports also \ndeployment from public and private Docker images\n.\n\n\nThis guide covers the main deployment options on Railway. Choose the approach that suits your setup, and start deploying your Astro apps seamlessly!\n\n\nNext Steps\n\n\nExplore these resources to learn how you can maximize your experience with Railway:\n\n\n\n\nAdd a Database Service\n\n\nMonitor your app\n\n\nPrev\n \nSpring Boot\nNext\n \nSvelteKit\nEdit this file on GitHub\nOn This Page\nCreate an Astro App\nRun the Astro App Locally\nEnable Server Side Rendering (SSR)\nModify Start Script and Astro Config\nDeploy the Astro App to Railway\nOne-Click Deploy From a Template\nDeploy From the CLI\nDeploy From a GitHub Repo\nUse a Dockerfile\nNext Steps"
  },
  {
    "url": "https://docs.railway.app/guides/axum",
    "title": "Deploy a Rust Axum App | Railway Docs",
    "content": "Deploy a Rust Axum App\nAxum\n is a web framework for Rust that focuses on ergonomics and modularity. It is designed to work with \ntokio\n and \nhyper\n.\n\n\nThis guide covers how to deploy an Axum app to Railway in four ways:\n\n\n\n\nOne-click deploy from a template\n.\n\n\nFrom a GitHub repository\n.\n\n\nUsing the CLI\n.\n\n\nUsing a Dockerfile\n.\n\n\n\n\nNow, let's create an Axum app! ðŸš€\n\n\nCreate an Axum App\n\n\nNote:\n If you already have an Axum app locally or on GitHub, you can skip this step and go straight to the \nDeploy Axum App to Railway\n.\n\n\nTo create a new Axum app, ensure that you have \nRust\n installed on your machine.\n\n\nRun the following command in your terminal to create a new Axum app:\n\n\ncargo new helloworld --bin\n\n\nThe command creates a new binary-based Cargo project in a \nhelloworld\n directory.\n\n\nNext, \ncd\n into the directory and add \naxum\n and \ntokio\n as dependencies by running the following command:\n\n\ncargo \nadd\n axum\n\ncargo \nadd\n tokio --features full\n\n\nThis will add \naxum\n and \ntokio\n as dependencies, with \ntokio\n configured to use the \"full\" feature, which includes its complete set of capabilities. Youâ€™ll find both dependencies listed in your \nCargo.toml\n file.\n\n\nThese dependencies are required to create a bare minimum axum application.\n\n\nModify the Application File\n\n\nNext, open the app in your IDE and navigate to the \nsrc/main.rs\n file.\n\n\nReplace the content with the code below:\n\n\nuse\n \naxum\n::\n{\n\n\n    \nrouting\n::\nget\n,\n\n\n    \nRouter\n,\n\n\n}\n;\n\n\n\n\n#[tokio::main]\n\n\nasync\n \nfn\n \nmain\n(\n)\n \n{\n\n\n    \n// build our application with a single route\n\n\n    \nlet\n app \n=\n \nRouter\n::\nnew\n(\n)\n.\nroute\n(\n\"/\"\n,\n \nget\n(\nroot\n)\n)\n;\n\n\n\n\n    \n// Get the port number from the environment, default to 3000\n\n\n    \nlet\n port\n:\n \nu16\n \n=\n \nstd\n::\nenv\n::\nvar\n(\n\"PORT\"\n)\n\n\n        \n.\nunwrap_or_else\n(\n|\n_\n|\n \n\"3000\"\n.\nto_string\n(\n)\n)\n \n// Get the port as a string or default to \"3000\"\n\n\n        \n.\nparse\n(\n)\n \n// Parse the port string into a u16\n\n\n        \n.\nexpect\n(\n\"Failed to parse PORT\"\n)\n;\n\n\n\n\n    \n// Create a socket address (IPv6 binding)\n\n\n    \nlet\n address \n=\n \nSocketAddr\n::\nfrom\n(\n(\n[\n0\n,\n \n0\n,\n \n0\n,\n \n0\n,\n \n0\n,\n \n0\n,\n \n0\n,\n \n0\n]\n,\n port\n)\n)\n;\n\n\n    \nlet\n listener \n=\n \ntokio\n::\nnet\n::\nTcpListener\n::\nbind\n(\n&\naddress\n)\n.\nawait\n.\nunwrap\n(\n)\n;\n\n\n\n\n    \n// Run the app with hyper, listening on the specified address\n\n\n    \naxum\n::\nserve\n(\nlistener\n,\n app\n)\n.\nawait\n.\nunwrap\n(\n)\n;\n\n\n}\n\n\n\n\n// basic handler that responds with a static string\n\n\nasync\n \nfn\n \nroot\n(\n)\n \n->\n \n&\n'static\n \nstr\n \n{\n\n\n    \n\"Hello World, from Axum!\"\n\n\n}\n\n\nThe code above sets up a simple web server using the Axum framework and the Tokio async runtime. The server listens on the port gotten from the environment variable, \nPORT\n and defaults to \n3000\n if there's none set.\n\n\nIt defines one route, \n/\n, which is mapped to a handler function called \nroot\n. When a GET request is made to the root path, the handler responds with the static string \"Hello World, from Axum!\".\n\n\nThe Router from Axum is used to configure the route, and \ntokio::net::TcpListener\n binds the server to listen for connections on all available network interfaces (address \n0.0.0.0\n).\n\n\nThe asynchronous runtime, provided by the \n#[tokio::main]\n macro, ensures the server can handle requests efficiently. The \naxum::serve\n function integrates with the Hyper server to actually process requests.\n\n\nRun the Axum App Locally\n\n\nRun the following command in the \nhelloworld\n directory via the terminal:\n\n\ncargo run\n\n\nAll the dependencies will be installed and your app will be launched.\n\n\nOpen your browser and go to \nhttp://localhost:3000\n to see your app.\n\n\nDeploy the Axum App to Railway\n\n\nRailway offers multiple ways to deploy your Axum app, depending on your setup and preference.\n\n\nOne-Click Deploy From a Template\n\n\nIf youâ€™re looking for the fastest way to get started, the one-click deploy option is ideal.\n\n\nClick the button below to begin:\n\n\n\n\nWe highly recommend that \nyou eject from the template after deployment\n to create a copy of the repo on your GitHub account.\n\n\nNote:\n You can also choose from a \nvariety of Axum templates\n created by the community.\n\n\nDeploy From the CLI\n\n\n\n\n\n\nInstall the Railway CLI\n:\n\n\n\n\nInstall the CLI\n and \nauthenticate it\n using your Railway account.\n\n\n\n\n\n\n\n\nInitialize a Railway Project\n:\n\n\n\n\nRun the command below in your Axum app directory.\n\n\nrailway init\n\n\n\n\nFollow the prompts to name your project.\n\n\nAfter the project is created, click the provided link to view it in your browser.\n\n\n\n\n\n\n\n\nDeploy the Application\n:\n\n\n\n\nUse the command below to deploy your app:\n\n\nrailway up\n\n\n\n\nThis command will scan, compress and upload your app's files to Railway. Youâ€™ll see real-time deployment logs in your terminal.\n\n\n\n\n\n\n\n\nVerify the Deployment\n:\n\n\n\n\nOnce the deployment completes, go to \nView logs\n to check if the server is running successfully.\n\n\n\n\nNote:\n During the deployment process, Railway will automatically \ndetect that itâ€™s a Rust app\n.\n\n\n\n\n\n\nSet Up a Public URL\n:\n\n\n\n\nNavigate to the \nNetworking\n section under the \nSettings\n tab of your new service.\n\n\nClick \nGenerate Domain\n to create a public URL for your app.\n\n\n\n\n\n\n\n\n\n\nDeploy From a GitHub Repo\n\n\nTo deploy an Axum app to Railway directly from GitHub, follow the steps below:\n\n\n\n\n\n\nCreate a New Project on Railway\n:\n\n\n\n\nGo to \nRailway\n to create a new project.\n\n\n\n\n\n\n\n\nDeploy from GitHub\n:\n\n\n\n\nSelect \nDeploy from GitHub repo\n and choose your repository.\n\n\n\n\nIf your Railway account isnâ€™t linked to GitHub yet, youâ€™ll be prompted to do so.\n\n\n\n\n\n\n\n\n\n\n\n\nDeploy the App\n:\n\n\n\n\nClick \nDeploy\n to start the deployment process.\n\n\nOnce the deployed, a Railway \nservice\n will be created for your app, but it wonâ€™t be publicly accessible by default.\n\n\n\n\n\n\n\n\nVerify the Deployment\n:\n\n\n\n\nOnce the deployment completes, go to \nView logs\n to check if the server is running successfully.\n\n\n\n\nNote:\n During the deployment process, Railway will automatically \ndetect that itâ€™s a Rust app\n.\n\n\n\n\n\n\nSet Up a Public URL\n:\n\n\n\n\nNavigate to the \nNetworking\n section under the \nSettings\n tab of your new service.\n\n\nClick \nGenerate Domain\n to create a public URL for your app.\n\n\n\n\n\n\n\n\nUse a Dockerfile\n\n\n\n\nCreate a \nDockerfile\n in the \nhelloworld\n or Axum app's root directory.\n\n\nAdd the content below to the \nDockerfile\n:\n\n\nFROM\n lukemathwalker/cargo-chef:latest-rust-1 \nAS\n chef\n\n\n\n\n# Create and change to the app directory.\n\n\nWORKDIR\n /app\n\n\n\n\nFROM\n chef \nAS\n planner\n\n\nCOPY\n . ./\n\n\nRUN\n cargo chef prepare --recipe-path recipe.json\n\n\n\n\nFROM\n chef \nAS\n builder \n\n\nCOPY\n \n--from\n=\nplanner\n /app/recipe.json recipe.json\n\n\n\n\n# Build dependencies - this is the caching Docker layer!\n\n\nRUN\n cargo chef cook --release --recipe-path recipe.json\n\n\n\n\n# Build application\n\n\nCOPY\n . ./\n\n\nRUN\n cargo build --release\n\n\n\n\nCMD\n [\n\"./target/release/helloworld\"\n]\n\n\n\n\nEither deploy via the CLI or from GitHub.\n\n\n\n\nRailway automatically detects the \nDockerfile\n, \nand uses it to build and deploy the app.\n\n\nNote:\n Railway supports also \ndeployment from public and private Docker images\n.\n\n\nThis guide covers the main deployment options on Railway. Choose the approach that suits your setup, and start deploying your Axum apps seamlessly!\n\n\nNext Steps\n\n\nExplore these resources to learn how you can maximize your experience with Railway:\n\n\n\n\nAdd a Database Service\n\n\nMonitor your app\n\n\nPrev\n \nRails\nNext\n \nRocket\nEdit this file on GitHub\nOn This Page\nCreate an Axum App\nModify the Application File\nRun the Axum App Locally\nDeploy the Axum App to Railway\nOne-Click Deploy From a Template\nDeploy From the CLI\nDeploy From a GitHub Repo\nUse a Dockerfile\nNext Steps"
  },
  {
    "url": "https://docs.railway.app/guides/beego",
    "title": "Deploy a Beego App | Railway Docs",
    "content": "Deploy a Beego App\nBeego\n is a high-performance, open-source web framework designed for building robust applications in Go (Golang). It is used for rapid development of enterprise apps, including RESTful APIs, web apps and backend services.\n\n\nThis guide covers how to deploy a Beego app to Railway in four ways:\n\n\n\n\nOne-click deploy from a template\n.\n\n\nFrom a GitHub repository\n.\n\n\nUsing the CLI\n.\n\n\nUsing a Dockerfile\n.\n\n\n\n\nNow, let's create a Beego app!\n\n\nCreate a Beego App\n\n\nNote:\n If you already have a Beego app locally or on GitHub, you can skip this step and go straight to the \nDeploy Beego App to Railway\n.\n\n\nTo create a new Beego app, ensure that you have \nGo\n and \nBee tool\n installed on your machine.\n\n\nRun the following command in your terminal to create a new Beego app and install all dependencies:\n\n\nbee new helloworld\n\ncd\n helloworld\n\ngo mod tidy\n\n\nA new Beego app will be provisioned for you in the \nhelloworld\n directory.\n\n\nConfigure Database\n\n\nRun \ngo get github.com/lib/pq\n in your terminal to install the Go Postgres driver.\n\n\nCreate a database, \nhelloworld_dev\n in your local Postgres instance.\n\n\nOpen the \nmain.go\n file and modify the content to the code below:\n\n\npackage\n main\n\n\n\nimport\n \n(\n\n\n\t\n\"fmt\"\n\n\n\t\n_\n \n\"helloworld/routers\"\n\n\n\n\n\t\n_\n \n\"github.com/lib/pq\"\n\n\n\n\n\t\n\"github.com/beego/beego/v2/client/orm\"\n\n\n\tbeego \n\"github.com/beego/beego/v2/server/web\"\n\n\n)\n\n\n\n\n// Users -\n\n\ntype\n Users \nstruct\n \n{\n\n\n\tID        \nint\n    \n`orm:\"column(id)\"`\n\n\n\tFirstName \nstring\n \n`orm:\"column(first_name)\"`\n\n\n\tLastName  \nstring\n \n`orm:\"column(last_name)\"`\n\n\n}\n\n\n\n\nfunc\n \ninit\n(\n)\n \n{\n\n\n\t\n// set default database\n\n\n\torm\n.\nRegisterDriver\n(\n\"postgres\"\n,\n orm\n.\nDRPostgres\n)\n\n\n\n\n\t\n// set default database\n\n\n\torm\n.\nRegisterDataBase\n(\n\"default\"\n,\n \n\"postgres\"\n,\n \n\"postgres://unicodeveloper:@localhost/helloworld_dev?sslmode=disable\"\n)\n\n\n\n\n\t\n// register model\n\n\n\torm\n.\nRegisterModel\n(\nnew\n(\nUsers\n)\n)\n\n\n\n\n\t\n// create table\n\n\n\torm\n.\nRunSyncdb\n(\n\"default\"\n,\n \nfalse\n,\n \ntrue\n)\n\n\n}\n\n\n\n\nfunc\n \nmain\n(\n)\n \n{\n\n\n\to \n:=\n orm\n.\nNewOrm\n(\n)\n\n\n\n\n\t\n// Create a slice of Users to insert\n\n\n\tusers \n:=\n \n[\n]\nUsers\n{\n\n\n\t\t\n{\nFirstName\n:\n \n\"John\"\n,\n LastName\n:\n \n\"Doe\"\n}\n,\n\n\n\t\t\n{\nFirstName\n:\n \n\"Jane\"\n,\n LastName\n:\n \n\"Doe\"\n}\n,\n\n\n\t\t\n{\nFirstName\n:\n \n\"Railway\"\n,\n LastName\n:\n \n\"Deploy Beego\"\n}\n,\n\n\n\t\n}\n\n\n\n\n\t\n// Iterate over the slice and insert each user\n\n\n\t\nfor\n \n_\n,\n user \n:=\n \nrange\n users \n{\n\n\n\t\tid\n,\n err \n:=\n o\n.\nInsert\n(\n&\nuser\n)\n\n\n\t\t\nif\n err \n!=\n \nnil\n \n{\n\n\n\t\t\tfmt\n.\nPrintf\n(\n\"Failed to insert user %s %s: %v\\n\"\n,\n user\n.\nFirstName\n,\n user\n.\nLastName\n,\n err\n)\n\n\n\t\t\n}\n \nelse\n \n{\n\n\n\t\t\tfmt\n.\nPrintf\n(\n\"Inserted user ID: %d, Name: %s %s\\n\"\n,\n id\n,\n user\n.\nFirstName\n,\n user\n.\nLastName\n)\n\n\n\t\t\n}\n\n\n\t\n}\n\n\n\n\n\tbeego\n.\nRun\n(\n)\n\n\n}\n\n\nReplace this \npostgres://username:@localhost/helloworld_dev?sslmode=disable\n with the appropriate URL for your local Postgres database.\n\n\nCode Summary\n:\n\n\n\n\nThe Users struct defines the schema for the users table in the database.\n\n\nThe \ninit()\n function registers the Postgres driver, registers the Users model, and automatically creates the users table in the database. If any errors occur while inserting users, they are logged.\n\n\nThe \nmain()\n function creates an ORM instance, defines sample user data (first name and last name), inserts the data into the users table, and starts the Beego web server to serve your app.\n\n\n\n\nRun the Beego App Locally\n\n\nTo start your app, run:\n\n\nbee run\n\n\nOnce the app is running, open your browser and navigate to \nhttp://localhost:8080\n to view it in action.\n\n\nIn your terminal, youâ€™ll see logs indicating that the user data is being inserted. Head over to your database, and you should see the users table populated with the seeded data.\n\n\nPrepare Beego App for Deployment\n\n\n\n\nOpen the \nconf/app.conf\n file and add an environment variable, \nDATABASE_URL\n to it.\n\n\n\n\ndb_url \n=\n $\n{\nDATABASE_URL\n}\n\n\n\n\nHead over to the \nmain.go\n file and make some modifications to the way we retrieve the Postgres database url. The \ninit()\n function should look like this:\n\n\n\n\nfunc\n \ninit\n(\n)\n \n{\n\n\n\t\n// set default database\n\n\n\torm\n.\nRegisterDriver\n(\n\"postgres\"\n,\n orm\n.\nDRPostgres\n)\n\n\n\n\n\t\n// set default database\n\n\n\tdbURL\n,\n err \n:=\n beego\n.\nAppConfig\n.\nString\n(\n\"db_url\"\n)\n\n\n\t\nif\n err \n!=\n \nnil\n \n{\n\n\n\t\tlog\n.\nFatal\n(\n\"Error getting database URL: \"\n,\n err\n)\n\n\n\t\n}\n\n\n\n\n\torm\n.\nRegisterDataBase\n(\n\"default\"\n,\n \n\"postgres\"\n,\n dbURL\n)\n\n\n\n\n\t\n// register model\n\n\n\torm\n.\nRegisterModel\n(\nnew\n(\nUsers\n)\n)\n\n\n\n\n\t\n// create table\n\n\n\torm\n.\nRunSyncdb\n(\n\"default\"\n,\n \nfalse\n,\n \ntrue\n)\n\n\n}\n\n\nDeploy the Beego App to Railway\n\n\nRailway offers multiple ways to deploy your Beego app, depending on your setup and preference.\n\n\nOne-Click Deploy From a Template\n\n\nIf youâ€™re looking for the fastest way to get started, the one-click deploy option is ideal.\n\n\nClick the button below to begin:\n\n\n\n\nWe highly recommend that \nyou eject from the template after deployment\n to create a copy of the repo on your GitHub account.\n\n\nNote:\n You can also choose from a \nvariety of Beego app templates\n created by the community.\n\n\nDeploy From the CLI\n\n\n\n\nInstall the Railway CLI\n:\n\n\n\n\nInstall the CLI\n and \nauthenticate it\n using your Railway account.\n\n\n\n\n\n\nInitialize a Railway Project\n:\n\n\n\n\nRun the command below in your Beego app directory.\n\n\nrailway init\n\n\n\n\nFollow the prompts to name your project.\n\n\nAfter the project is created, click the provided link to view it in your browser.\n\n\n\n\n\n\nAdd a Postgres Database Service\n:\n\n\n\n\nRun \nrailway add -d postgres\n.\n\n\nHit \nEnter\n to add it to your project.\n\n\nA database service will be added to your Railway project.\n\n\n\n\n\n\nAdd a Service and Environment Variable\n:\n\n\n\n\nRun \nrailway add\n.\n\n\nSelect \nEmpty Service\n from the list of options.\n\n\nIn the \nEnter a service name\n prompt, enter \napp-service\n.\n\n\nIn the \nEnter a variable\n prompt, enter \nDATABASE_URL=${{Postgres.DATABASE_URL}}\n.\n\n\n\n\nThe value, \n${{Postgres.DATABASE_URL}}\n, references the URL of your new Postgres database. Learn more about \nreferencing service variables\n.\n\n\n\n\n\n\n\n\nNote:\n Explore the \nRailway CLI reference\n for a variety of options.\n\n\nDeploy the Application\n:\n\n\n\n\nRun \nrailway up\n to deploy your app.\n\n\n\n\nThis command will scan, compress and upload your app's files to Railway. Youâ€™ll see real-time deployment logs in your terminal.\n\n\n\n\n\n\nOnce the deployment is complete, we can proceed to generate a domain for the app service.\n\n\n\n\n\n\nSet Up a Public URL\n:\n\n\n\n\nRun \nrailway domain\n to generate a public URL for your app.\n\n\nVisit the new URL to see your app live in action!\n\n\n\n\n\n\n\n\n\n\nDeploy From a GitHub Repo\n\n\nTo deploy a Beego app to Railway directly from GitHub, follow the steps below:\n\n\n\n\n\n\nCreate a New Project on Railway\n:\n\n\n\n\nGo to \nRailway\n to create a new project.\n\n\n\n\n\n\n\n\nDeploy from GitHub\n:\n\n\n\n\nSelect \nDeploy from GitHub repo\n and choose your repository.\n\n\n\n\nIf your Railway account isnâ€™t linked to GitHub yet, youâ€™ll be prompted to do so.\n\n\n\n\n\n\n\n\n\n\n\n\nAdd Environment Variables and Provision a Database Service\n:\n\n\n\n\nClick \nAdd Variables\n, but hold off on adding anything just yet. First, proceed with the next step.\n\n\nRight-click on the Railway project canvas or click the \nCreate\n button, then select \nDatabase\n and choose \nAdd PostgreSQL\n.\n\n\n\n\nThis will create and deploy a new PostgreSQL database for your project.\n\n\n\n\n\n\nOnce the database is deployed, you can return to adding the necessary environment variables:\n\n\n\n\nDATABASE_URL\n: Set the value to \n${{Postgres.DATABASE_URL}}\n (this references the URL of your new Postgres database). Learn more about \nreferencing service variables\n.\n\n\n\n\n\n\n\n\n\n\n\n\nDeploy the App Service\n:\n\n\n\n\nClick \nDeploy\n on the Railway project canvas to apply your changes.\n\n\n\n\n\n\n\n\nVerify the Deployment\n:\n\n\n\n\nOnce the deployment completes, go to \nView logs\n to check if the server is running successfully.\n\n\n\n\nNote:\n During the deployment process, Railway will automatically \ndetect that itâ€™s a Go app\n.\n\n\n\n\n\n\nSet Up a Public URL\n:\n\n\n\n\nNavigate to the \nNetworking\n section under the \nSettings\n tab of your new service.\n\n\nClick \nGenerate Domain\n to create a public URL for your app.\n\n\n\n\n\n\n\n\nUse a Dockerfile\n\n\n\n\nCreate a \nDockerfile\n in the Beego app's root directory.\n\n\nAdd the content below to the \nDockerfile\n:\n\n\n# Use the Go 1.22 official image\n\n\n# https://hub.docker.com/_/golang\n\n\nFROM\n golang:1.22\n\n\n\n\n# Create and change to the app directory.\n\n\nWORKDIR\n /app\n\n\n\n\n# Copy local code to the container image.\n\n\nCOPY\n . ./\n\n\n\n\n# Install project dependencies\n\n\nRUN\n go mod download\n\n\n\n\n# Build the app\n\n\nRUN\n go build -o app\n\n\n\n\n# Run the service on container startup.\n\n\nENTRYPOINT\n [\n\"./app\"\n]\n\n\n\n\nEither deploy via the CLI or from GitHub.\n\n\n\n\nRailway automatically detects the \nDockerfile\n, \nand uses it to build and deploy the app.\n\n\nNote:\n Railway supports also \ndeployment from public and private Docker images\n.\n\n\nThis guide covers the main deployment options on Railway. Choose the approach that suits your setup, and start deploying your Beego apps seamlessly!\n\n\nNext Steps\n\n\nExplore these resources to learn how you can maximize your experience with Railway:\n\n\n\n\nAdd a Database Service\n\n\nMonitor your app\n\n\nPrev\n \nFlask\nNext\n \nGin\nEdit this file on GitHub\nOn This Page\nCreate a Beego App\nConfigure Database\nRun the Beego App Locally\nPrepare Beego App for Deployment\nDeploy the Beego App to Railway\nOne-Click Deploy From a Template\nDeploy From the CLI\nDeploy From a GitHub Repo\nUse a Dockerfile\nNext Steps"
  },
  {
    "url": "https://docs.railway.app/guides/build-a-database-service",
    "title": "Build a Database Service | Railway Docs",
    "content": "Build a Database Service\nRailway's platform primitives allow you to build any type of service your system requires, including database services.  This guide aims to guide you through the essential features to build your own database service.\n\n\nFor the purpose of this guide, we will use the official \nPostgres image\n as an example.\n\n\nService Source\n\n\nAs discussed in the \nServices guide\n, a crucial step in creating a service is \ndefining a source\n from which to deploy.\n\n\nTo deploy the official Postgres image, we'll simply enter postgres into the Source Image field:\n\n\n\n\nVolumes\n\n\nAttach a \nvolume\n to any service, to keep your data safe between deployments.  For the Postgres image, the default mount path is \n/var/lib/postgresql/data\n.\n\n\nJust attach a volume to the service you created, at the mount path:\n\n\n\n\nEnvironment Variables\n\n\nNow, all you need to do is configure the appropriate \nenvironment variables\n to let the Postgres image know how to run:\n\n\n\n\nNote the \nDATABASE_URL\n is configured with TCP Proxy variables, but you can also connect to the database service over the private network.  More information below.\n\n\nConnecting\n\n\nPrivate Network\n\n\nTo connect to your database service from other services in your project, you can use the \nprivate network\n.  For a postgres database service listening on port \n5432\n, you can use a connection string like this -\n\n\npostgresql://postgres:password@postgres.railway.internal:5432/railway\n\n\nTCP Proxy\n\n\nIf you'd like to expose the database over the public network, you'll need to set up a \nTCP Proxy\n, to proxy public traffic to the Postgres port \n5432\n:\n\n\n\n\nConclusion\n\n\nThat's all it takes to spin up a Postgres service in Railway directly from the official Postgres image.  Hopefully this gives you enough direction to feel comfortable exploring other database images to deploy.\n\n\nRemember you can also deploy from a Dockerfile which would generally involve the same features and steps.  For an example of a Dockerfile that builds a custom image with the official Postgres image as base, take a look at \nRailway's SSL-enabled Postgres image repo\n.\n\n\nTemplate Marketplace\n\n\nNeed inspiration or looking for a specific database?  Our \nTemplate Marketplace\n already includes solutions for many different database services.  You might even find a template for the database you need!\n\n\nHere are some suggestions to check out -\n\n\n\n\n\n\nMinio\n\n\n\n\n\n\nClickHouse\n\n\n\n\n\n\nDragonfly\n\n\n\n\n\n\nChroma\n\n\n\n\n\n\nElastic Search\n\n\n\n\nPrev\n \nDatabases\nNext\n \nPostgreSQL\nEdit this file on GitHub\nOn This Page\nService Source\nVolumes\nEnvironment Variables\nConnecting\nPrivate Network\nTCP Proxy\nConclusion\nTemplate Marketplace"
  },
  {
    "url": "https://docs.railway.app/guides/build-configuration",
    "title": "Build Configuration | Railway Docs",
    "content": "Build Configuration\nRailway will build and deploy your code with zero configuration, but when necessary, there are several ways to configure this behavior to suit your needs.\n\n\nRailpack\n\n\nThis feature is in beta.\n\n\nRailpack\n is a new builder\ndeveloped by Railway that produces smaller image sizes and supports all versions\nof packages. It is currently in beta and can be enabled from your service\nsettings.\n\n\nFind the full list of configuration options in the \nRailpack\ndocs\n.\n\n\nNixpacks Options\n\n\nRailway uses \nNixpacks\n to build your code. It has a variety of options that can be configured with \nenvironment variables\n which can be defined in your services settings. These include things like:\n\n\n\n\nInstall/build/start commands\n\n\nNix/Apt packages to install\n\n\nDirectories to cache\n\n\n\n\nFor a full list of these options, please view the \nNixpacks docs\n.\n\n\nYou can find a complete list of languages we support out of the box \nhere\n.\n\n\nCustomize the Build Command\n\n\nUsing the default Nixpacks builder, you can customize the build command that is run from within your service settings.\n\n\n\n\nFor those familiar with Nixpacks, this gets set as the \n--build-cmd\n argument during the Nixpacks build.\n\n\nSet the Root Directory\n\n\nThe root directory defaults to \n/\n but can be changed for various use-cases like\n\nmonorepo\n projects.\n\n\n\n\nWhen specified, all build and deploy\ncommands will operate within the defined root directory.\n\n\nNote:\n The \nRailway Config File\n does not follow the \nRoot Directory\n path. You have to specify the absolute path for the \nrailway.json\n or \nrailway.toml\n file.\n\n\nConfigure Watch Paths\n\n\nWatch paths are \ngitignore-style\n patterns\nthat can be used to trigger a new deployment based on what file paths have\nchanged.\n\n\n\n\nFor example, a monorepo might want to only trigger builds if files are\nchanged in the \n/packages/backend\n directory.\n\n\nWhen specified, any changes that\ndon't match the patterns will skip creating a new deployment. Multiple patterns\ncan be combined, one per line.\n\n\nNote, if a Root Directory is provided, patterns still operate from \n/\n. For a root directory of \n/app\n, \n/app/**.js\n would be used as a pattern to match files in the new root.\n\n\nHere are a few examples of common use-cases:\n\n\n# Match all TypeScript files under src/\n\n/src/**/*.ts\n\n\n# Match Go files in the root, but not in subdirectories\n\n/*.go\n\n\n# Ignore all Markdown files\n\n**\n!/*.md\n\n\nNote, negations will only work if you include files in a preceding rule.\n\n\nInstall a Specific Package Using Nixpacks\n\n\nWhen using Nixpacks, you can install specific packages by defining them in a nixpacks configuration file. For example:\n\n\n[\nphases.setup\n]\n\n\n    \naptPkgs\n \n=\n \n[\n'wget'\n]\n\n\nSee the \nNixpacks docs\n for more information.\n\n\nBuild Providers\n\n\nWith Nixpacks, we analyze the app source directory and generate a build plan. This determines for which language provider to install packages and runtimes.\n\n\nWithin your Service's settings, under the Builds section, you can define within the multi-select box which Nixpacks language providers you would like to use for your builds. This is useful if you have code that calls libraries that need to be built from another language within your repo.\n\n\n\n\nWhen multiple providers are defined, Railway will build your service with the language providers (in the order you defined) and ensure your binaries are ready to be called. The runtime(s) will then initialize as soon as you start your application.\n\n\nProcfiles\n\n\nIf using Nixpacks, you can override the start command with a \nProcfile\n at the root of your app. Only a single process type is supported at the moment.\n\n\nHTTP servers should use the \nweb\n process type. This process should listen on\nthe \nPORT environment variable\n and will receive\nHTTP traffic.\n\n\nNote: Some buildpacks specify a default start command\n\n\nSpecify a Custom Install Command\n\n\nWe do not expose a way to configure a custom install command in the UI, but you can control this using \nconfig as code\n (see Nixpacks Plan -> Install Command).\n\n\nDisable Build Layer Caching\n\n\nBy default, Railway will cache build layers to provide faster build times. If you have a need to disable this behavior, set the following environment variable in your service:\n\n\nNO_CACHE=1\n\n\nWhy Isn't My Build Using Cache?\n\n\nSince Railway's build system scales up and down in response to demand, cache hit on builds is not guaranteed.\n\n\nIf you have a need for faster builds and rely on build cache to satisfy that requirement, you should consider creating a pipeline to build your own image and deploy your image directly.\nPrev\n \nBuilds\nNext\n \nDockerfiles\nEdit this file on GitHub\nOn This Page\nRailpack\nNixpacks Options\nCustomize the Build Command\nSet the Root Directory\nConfigure Watch Paths\nInstall a Specific Package Using Nixpacks\nBuild Providers\nProcfiles\nSpecify a Custom Install Command\nDisable Build Layer Caching\nWhy Isn't My Build Using Cache?"
  },
  {
    "url": "https://docs.railway.app/guides/builds",
    "title": "Builds | Railway Docs",
    "content": "Builds\nLet's customize the build process.\n\n\nRailway will build and deploy your code with zero configuration, but we make it easy to override this behavior as needed. Now that you're warmed up, let's take a look at how you can adjust how your services are built.\n\n\nThe goal of this section is to guide you through the various ways to customize the build process.\n\n\nBuild Concepts\n\n\nNixpacks\nNixpacks\n takes a source directory and produces an OCI compliant image that can be deployed anywhere. It is the default buildpack used when you deploy on Railway.\nRailpack\nRailpack\n is a new builder developed by Railway that produces smaller image sizes and supports all versions of packages. Currently in beta.\nBuild Configuration\nRailway provides several ways to configure the build process to produce the desired result. If necessary, you have control over the build command, which root directory to build from, when to trigger a build, etc.\nDockerfiles\nDockerfiles welcome! If you already have a build defined in a Dockerfile within your code repository, Railway will automatically use it to build your service.\n\n\nThe following pages will guide you through how to interact with these controls.\nPrev\n \nPrivate Networking\nNext\n \nBuild Configuration\nEdit this file on GitHub\nOn This Page\nBuild Concepts"
  },
  {
    "url": "https://docs.railway.app/guides/cli",
    "title": "Using the CLI | Railway Docs",
    "content": "Using the CLI\nThe Railway Command Line Interface (CLI) lets you interact with your\nRailway project from the command line.\n\n\n\n\nInstalling the CLI\n\n\nThe Railway CLI can be installed via Homebrew, npm, Scoop, or directly from the source.\n\n\nHomebrew (macOS)\n\n\nIn a Terminal, enter the following command:\n\n\nbrew \ninstall\n railway\n\n\nnpm (macOS, Linux, Windows)\n\n\nIn a Terminal, enter the following command:\n\n\nnpm\n i -g @railway/cli\n\n\nThis requires version =>16 of \nNode.js\n.\n\n\nShell Script (macOS, Linux, Windows via WSL)\n\n\nIn a Terminal, enter the following command:\n\n\nbash\n \n<\n(\ncurl\n -fsSL cli.new\n)\n\n\nOn Windows, you should use \nWindows Subsystem for Linux\n\nwith a Bash shell.\n\n\nScoop (Windows)\n\n\nIn a PowerShell terminal, enter the following command:\n\n\nscoop install railway\n\n\nThis installs a native Windows binary (\n.exe\n). To learn more about Scoop,\nsee \nhttps://scoop.sh/\n.\n\n\nPre-built Binaries\n\n\nWe publish \npre-built binaries\n\non our \nGitHub repository\n that you can\ndownload and use directly.\n\n\nFrom Source\n\n\nThe Railway CLI is an open source project on \nGitHub\n.\nYou can build a binary \nfrom source\n\nif you wish.\n\n\nAuthenticating With the CLI\n\n\nBefore you can use the Railway CLI, you must authenticate the CLI to your Railway account:\n\n\nrailway login\n\n\nThis command opens a new tab in your default browser to the \nhttps://railway.com\n\nauthentication page. Follow the instructions to complete the authentication process.\n\n\nManual Login\n\n\nYou can also authenticate manually using a Pairing Code. This can be useful if\nyou're authenticating the CLI inside an environment without a browser (e.g. SSH\nsessions).\n\n\nUse the \n--browserless\n flag to authenticate manually:\n\n\nrailway login --browserless\n\n\nTokens\n\n\nIn situations where user input or interaction isn't possible, such as in CI/CD pipelines, you can set either the \nRAILWAY_TOKEN\n or \nRAILWAY_API_TOKEN\n environment variable, based on your specific requirements as detailed below.\n\n\nA \nProject Token\n is set via the \nRAILWAY_TOKEN\n environment variable.\n\n\nAn \nAccount\n or \nTeam\n Token is set via the \nRAILWAY_API_TOKEN\n environment variable.\n\n\nNote:\n You can only use one type of token at a time. If both are set, the \nRAILWAY_TOKEN\n variable will take precedence.\n\n\nProject Tokens\n\n\nYou can use \nProject Tokens\n to authenticate project-level actions.\n\n\nProject Tokens allow the CLI to access all the project-level actions in the environment set when the token was created.\n\n\nSome actions you can perform with a project token include -\n\n\n\n\nDeploying code - \nrailway up\n\n\nRedeploying a deployment - \nrailway redeploy\n\n\nViewing build and deployment logs - \nrailway logs\n\n\n\n\nSome actions you \ncannot\n perform with a project token include -\n\n\n\n\nCreating a new project - \nrailway init\n\n\nPrinting information about the user - \nrailway whoami\n\n\nLinking to another workspace - \nrailway link\n\n\n\n\nUse the token by setting the \nRAILWAY_TOKEN\n environment variable and then running \nrailway <command>\n.\n\n\nRAILWAY_TOKEN\n=\nXXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX railway up\n\n\nAccount Tokens\n\n\nAccount Tokens come in two types - \nPersonal Account Tokens\n and \nTeam Tokens\n.\n\n\nYou can use Account Tokens to authenticate all CLI actions across all workspaces.\n\n\nHowever, you can only use Team tokens to authenticate actions on projects within the workspace the token was scoped to when it was created.\n\n\nSome actions you can perform with a personal account token include -\n\n\n\n\nCreating a new project - \nrailway init\n\n\nPrinting information about the user - \nrailway whoami\n\n\n\n\nSome actions you \ncannot\n perform with \nTeam Token\n include -\n\n\n\n\nPrinting information about the user - \nrailway whoami\n\n\nLinking to another workspace - \nrailway link\n\n\n\n\nUse the token by setting the \nRAILWAY_API_TOKEN\n environment variable and then running \nrailway <command>\n.\n\n\nRAILWAY_API_TOKEN\n=\nXXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX railway \nwhoami\n\n\nCommon Examples of CLI Usage\n\n\nBelow are some of the most commonly used CLI commands. Find a complete list of CLI commands in the \nCLI API reference page\n.\n\n\nLink to a Project\n\n\nTo associate a project and environment with your current directory:\n\n\n\n\n# Link to a project\n\n\nrailway \nlink\n\n\nThis prompts you to select a team, project, and environment to associate with\nyour current directory. Any future commands will be run against this project and environment.\n\n\nLink to a Service\n\n\nAssociate a service in a project and environment with your current directory:\n\n\n# Link to a service\n\n\nrailway \nservice\n\n\nThis links your current directory with the chosen service.\n\n\nCreate a Project\n\n\nCreate a new project directly from the command line.\n\n\n# Create a new project\n\n\nrailway init\n\n\nThis prompts you to name your project and select a team to create the project in.\n\n\nLocal Development\n\n\nRun code locally with the same environment variables as your Railway project.\n\n\n# Run <cmd> locally with the same environment variables as your Railway project\n\n\nrailway run \n<\ncmd\n>\n\n\nFor example, to run your Node.js project with your remote environment variables:\n\n\n# Run your Node.js project with your remote environment variables\n\n\nrailway run \nnpm\n start\n\n\nLocal Shell\n\n\nOpen a new local shell with Railway environment variables. Similar to \nrailway run\n but opens a new shell.\n\n\n# Open a new shell with Railway environment variables\n\n\nrailway shell\n\n\nEnvironments\n\n\nProjects might have multiple environments, but by default the CLI links to the \nproduction\n environment.\nYou can change the linked environment with the \nenvironment\n command.\n\n\n# Change the linked environment\n\n\nrailway environment\n\n\nDeploy\n\n\nDeploy the linked project directory (if running from a subdirectory, the project root is still deployed).\n\n\n# Show build logs\n\n\nrailway up\n\n\n\n# Return immediately after uploading\n\n\nrailway up --detach\n\n\nIf there are multiple services within your project, the CLI will prompt you for a service to deploy to.\n\n\nAdd Database Service\n\n\nProvision database services for a project.\n\n\nrailway \nadd\n\n\nPrompts you to select one or more databases to provision for your project.\n\n\nLogout\n\n\nrailway \nlogout\n\n\nContributing\n\n\nOur CLI is open source. Contribute to the development of the Railway CLI by opening an issue or Pull Request on our \nGitHub Repo\n.\n\n\nYou can see the full documentation of the CLI API here.\nPrev\n \nEnvironments\nNext\n \nJoin Priority Boarding!\nEdit this file on GitHub\nOn This Page\nInstalling the CLI\nHomebrew (macOS)\nnpm (macOS, Linux, Windows)\nShell Script (macOS, Linux, Windows via WSL)\nScoop (Windows)\nPre-built Binaries\nFrom Source\nAuthenticating With the CLI\nManual Login\nTokens\nProject Tokens\nAccount Tokens\nCommon Examples of CLI Usage\nLink to a Project\nLink to a Service\nCreate a Project\nLocal Development\nLocal Shell\nEnvironments\nDeploy\nAdd Database Service\nLogout\nContributing"
  },
  {
    "url": "https://docs.railway.app/guides/config-as-code",
    "title": "Using Config as Code | Railway Docs",
    "content": "Using Config as Code\nRailway supports defining the configuration for a single deployment in a file\nalongside your code in a \nrailway.toml\n or \nrailway.json\n file.\n\n\nEverything in the build and deploy sections of the service settings page can be specified in this configuration file.\n\n\nThe settings in the dashboard will not be updated with the settings defined in\ncode. Configuration defined in code will always override values from the\ndashboard.\n\n\nToml vs Json\n\n\nThe format you use for your config-as-code (toml or json) file is entirely dependent on preference, and the resulting behavior in Railway is the same no matter which you choose.\n\n\nFor example, these configuration definitions are equivalent:\n\n\n[\nbuild\n]\n\n\nbuilder\n \n=\n \n\"nixpacks\"\n\n\nbuildCommand\n \n=\n \n\"echo building!\"\n\n\n\n\n[\ndeploy\n]\n\n\npreDeployCommand\n \n=\n \n[\n\"npm run db:migrate\"\n]\n\n\nstartCommand\n \n=\n \n\"echo starting!\"\n\n\nhealthcheckPath\n \n=\n \n\"/\"\n\n\nhealthcheckTimeout\n \n=\n \n100\n\n\nrestartPolicyType\n \n=\n \n\"never\"\n\n\n\n\n\n\n\n\n\n\n\n\n--\nA \nrailway.toml\n file\n{\n\n\n  \n\"$schema\"\n:\n \n\"https://railway.com/railway.schema.json\"\n,\n\n\n  \n\"build\"\n:\n \n{\n\n\n    \n\"builder\"\n:\n \n\"nixpacks\"\n,\n\n\n    \n\"buildCommand\"\n:\n \n\"echo building!\"\n\n\n    \n}\n,\n\n\n  \n\"deploy\"\n:\n \n{\n\n\n    \n\"preDeployCommand\"\n:\n \n[\n\"npm run db:migrate\"\n]\n,\n\n\n    \n\"startCommand\"\n:\n \n\"echo starting!\"\n,\n\n\n    \n\"healthcheckPath\"\n:\n \n\"/\"\n,\n\n\n    \n\"healthcheckTimeout\"\n:\n \n100\n,\n\n\n    \n\"restartPolicyType\"\n:\n \n\"never\"\n\n\n    \n}\n\n\n}\nA \nrailway.json\n file\n\n\nJSON Schema\n\n\nYou can find an always up-to-date \nJSON schema\n at \nrailway.com/railway.schema.json\n.\n\n\nIf you include it in your \nrailway.json\n file, many editors (e.g. VSCode) will provide autocomplete and documentation.\n\n\n{\n\n\n  \n\"$schema\"\n:\n \n\"https://railway.com/railway.schema.json\"\n\n\n}\n\n\nUnderstanding Config Source\n\n\nOn a service's deployment details page, all the settings that a deployment went out with are shown.\n\n\nFor settings that come from a configuration file, there is a file icon. Hovering over the icon will show exactly what part of the file the values originated from.\n\n\n\n\nUsing a Custom Config as Code File\n\n\nYou can use a custom config file by setting it on the service settings page. The file is relative to your app source.\n\n\n\n\nConfigurable Settings\n\n\nFind a list of all of the configurable settings in the \nconfig as code reference page\n.\nPrev\n \nManage Variables\nNext\n \nGetting Started\nEdit this file on GitHub\nOn This Page\nToml vs Json\nJSON Schema\nUnderstanding Config Source\nUsing a Custom Config as Code File\nConfigurable Settings"
  },
  {
    "url": "https://docs.railway.app/guides/create",
    "title": "Create a Template | Railway Docs",
    "content": "Create a Template\nCreating a template allows you to capture your infrastructure in a reusable and distributable format.\n\n\nBy defining services, environment configuration, network settings, etc., you lay the foundation for others to deploy the same software stack with the click of a button.\n\n\nIf you \npublish your template\n to the \nmarketplace\n, you can even \ncollect a kickback\n from the usage of it!\n\n\nHow to Create a Template\n\n\nYou can either create a template from scratch or base it off of an existing project.\n\n\nStarting from Scratch\n\n\nTo create a template from scratch, head over to the \ntemplate composer\n then add and configure your services:\n\n\n\n\n\n\nAdd a service by clicking the \nAdd New\n button in the top right-hand corner, or through the command palette (\nCMD + K\n -> \n+ New Service\n)\n\n\n\n\n\n\nSelect the service source (GitHub repo or Docker Image)\n\n\n\n\n\n\nConfigure the service variables and settings\n\n\n\n\n\n\n\n\nOnce you've added your services, click \nCreate Template\n\n\n\n\n\n\nYou will be taken to your templates page where you can copy the template URL to share with others\n\n\n\n\n\n\nNote that your template will not be available on the template marketplace, nor will be eligible for a kickback, until you \npublish\n it.\n\n\nPrivate Repo Support\n\n\nIt's now possible to specify a private GitHub repo when creating a template.\n\n\nThis feature is intended for use among \nTeams\n and \nOrganizations\n. Users supporting a subscriber base may also find this feature helpful to distribute closed-source code.\n\n\nTo deploy a template that includes a private repo, look for the \nGitHub\n panel in the \nAccount Integrations\n section of \nGeneral Settings\n. Then select the \nEdit Scope\n option to grant Railway access to the desired private repos.\n\n\n\n\nIf you do not see the \nEdit Scope\n option, you may still need to connect GitHub to your Railway account.\n\n\nConvert a Project Into a Template\n\n\nYou can also convert an existing project into a ready-made Template for other users.\n\n\n\n\nFrom your project page, click \nSettings\n in the right-hand corner of the canvas\n\n\nScroll down until you see \nGenerate Template from Project\n\n\nClick \nCreate Template\n\n\n\n\n\n\n\n\nYou will be taken to the template composer page, where you should confirm the settings and finalize the template creation\n\n\n\n\nConfiguring Services\n\n\nConfiguring services using the \ntemplate composer\n is very similar to building a live project in the canvas.\n\n\nOnce you add a new service and select the source, you can configure the following to enable successful deploys for template users:\n\n\n\n\nVariables tab\n\n\n\n\nAdd required \nVariables\n.\n\nUse \nreference variables\n where possible for a better quality template\n\n\n\n\n\n\nSettings tab\n\n\n\n\nAdd a \nRoot Directory\n (Helpful for monorepos)\n\n\nEnable Public Networking\n with TCP Proxy or HTTP\n\n\nSet a custom \nStart command\n\n\nAdd a \nHealthcheck Path\n\n\n\n\n\n\nAdd a volume\n\n\n\n\nTo add a volume to a service, right-click on the service, select Attach Volume, and specify the \nVolume mount path\n\n\n\n\n\n\n\n\nSpecifying a Branch\n\n\nTo specify a particular GitHub branch to deploy, simply enter the full URL to the desired branch in the Source Repo configuration.  For example -\n\n\n\n\nThis will deploy the \nmain\n branch:  \nhttps://github.com/railwayapp-templates/postgres-ssl\n\n\nThis will deploy the \nnew\n branch:  \nhttps://github.com/railwayapp-templates/postgres-ssl/tree/new\n\n\n\n\nTemplate Variable Functions\n\n\nTemplate variable functions allow you to dynamically generate variables (or parts of a variable) on demand when the template is deployed.\n\n\n\n\nWhen a template is deployed, all template variable functions are executed and the result replaces the \n${{ ... }}\n in the variable.\n\n\nUse template variables to generate a random password for a database, or to generate a random string for a secret.\n\n\nThe current template variable functions are:\n\n\n\n\n\n\nsecret(length?: number, alphabet?: string)\n: Generates a random secret (32 chars by default).\n\n\nTip:\n You can generate Hex or Base64 secrets by constructing the appropriate alphabet and length.\n\n\n\n\nopenssl rand -base64 16\n â†’ \n${{secret(22, \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/\")}}==\n\n\nopenssl rand -base64 32\n â†’ \n${{secret(43, \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/\")}}=\n\n\nopenssl rand -base64 64\n â†’ \n${{secret(86, \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/\")}}==\n\n\nopenssl rand -hex 16\n â†’ \n${{secret(32, \"abcdef0123456789\")}}\n\n\nopenssl rand -hex 32\n â†’ \n${{secret(64, \"abcdef0123456789\")}}\n\n\nopenssl rand -hex 64\n â†’ \n${{secret(128, \"abcdef0123456789\")}}\n\n\n\n\nOr even generate a UUIDv4 string -\n\n\n${{secret(8, \"0123456789abcdef\")}}-${{secret(4, \"0123456789abcdef\")}}-4${{secret(3, \"0123456789abcdef\")}}-${{secret(1, \"89ab\")}}${{secret(3, \"0123456789abcdef\")}}-${{secret(12, \"0123456789abcdef\")}}\n\n\n\n\n\n\nrandomInt(min?: number, max?: number)\n: Generates a random integer between min and max (defaults to 0 and 100)\n\n\n\n\n\n\nManaging Your Templates\n\n\nYou can see all of your templates on your \nWorkspace's Template page\n. Templates are separated into Personal and Published templates.\n\n\nYou can edit, publish/unpublish and delete templates.\n\n\nPrev\n \nTemplates\nNext\n \nBest Practices\nEdit this file on GitHub\nOn This Page\nHow to Create a Template\nStarting from Scratch\nPrivate Repo Support\nConvert a Project Into a Template\nConfiguring Services\nSpecifying a Branch\nTemplate Variable Functions\nManaging Your Templates"
  },
  {
    "url": "https://docs.railway.app/guides/cron-jobs",
    "title": "Running a Scheduled Job | Railway Docs",
    "content": "Running a Scheduled Job\nScheduled Jobs, or Cron Jobs, allow you to start a service on a defined schedule.\n\n\nServices configured as cron jobs are expected to execute a task, and terminate as soon as that task is finished, leaving no open resources.\n\n\nConfiguring a Cron Job\n\n\nTo configure a cron job -\n\n\n\n\nSelect a service and go to the Settings section.\n\n\nWithin \"Cron Schedule\", input a \ncrontab expression\n.\n\n\nOnce the setting is saved, the service will run according to the cron schedule.\n\n\n\n\nFind more information about cron jobs, including examples of cron expressions, in the \nreference page for Cron Jobs\n.\n\n\nWhy Isn't My Cron Running as Scheduled?\n\n\nAn important requirement of a service that runs as a Cron, is that it terminates on completion and leaves no open resources.  If the code that runs in your Cron service does not exit, subsequent executions of the Cron will be skipped.\n\n\nIf you see that a previous execution of your Cron service has a status of \nActive\n, the execution is still running and any new executions will not be run.\n\n\nFor more information on Service execution requirements, see the \nService Execution Requirements\n section of the Cron Jobs reference.\nPrev\n \nMonorepo\nNext\n \nOptimize Usage\nEdit this file on GitHub\nOn This Page\nConfiguring a Cron Job\nWhy Isn't My Cron Running as Scheduled?"
  },
  {
    "url": "https://docs.railway.app/guides/database-view",
    "title": "Using the Database View | Railway Docs",
    "content": "Using the Database View\nBaked into the four, one-click database templates that Railway provides, is a Database Management Interface, this allows you to perform common actions on your Database such as viewing and editing the contents of your database services in Railway.\n\n\nSQL Interfaces\n\n\n\n\nFor MySQL and Postgres, Railway displays the tables contained within an instance by default; this is called the Table View.\n\n\nShift-clicking on one or multiple tables exposes additional options such as the ability to delete the table(s).\n\n\nCreating a Table\n\n\n\n\nUnder the Table View, clicking the Create Table button at the bottom right of the interface navigates users to the Create Table interface.\n\n\nFor each column a user wants to add to the database, the interface accepts a \nname\n, \ntype\n, \ndefault_value\n and \nconstraints\n. Depending on the SQL database that is used, valid types and constraints may vary.\n\n\nViewing and Editing Entries\n\n\nWhen a table is clicked, the interface navigates into the Entries View.\n\n\nUnder the Entries View, selecting an existing entry exposes the ability to edit the entry. When button that allows one to add entries to the table.\n\n\n\n\nAdd SQL Column\n\n\nSelecting the add column in the entries view opens a modal that prompts you to add a new column to the table.\n\n\nNoSQL Interfaces\n\n\nFor non-structured data, Railway has interfaces that permit users to add and edit data within the service.\n\n\nRedis View\n\n\n\n\nWith Redis, Railway displays the keys contained within a database instance by default.\n\n\nMongoDB Document View\n\n\nWith MongoDB, Railway displays a list of document collections. Users can add additional collections or add/edit documents within the collection.\n\n\nAdding MongoDB Databases\n\n\n\n\nWithin the Collections View, clicking the plus icon next to the top dropdown allows you to create a new Database.\nPrev\n \nMongoDB\nNext\n \nMonitoring\nEdit this file on GitHub\nOn This Page\nSQL Interfaces\nCreating a Table\nViewing and Editing Entries\nAdd SQL Column\nNoSQL Interfaces\nRedis View\nMongoDB Document View\nAdding MongoDB Databases"
  },
  {
    "url": "https://docs.railway.app/guides/databases",
    "title": "Database Services | Railway Docs",
    "content": "Database Services\nReady for databases?\n\n\nRailway's platform primitives are built with flexibility in mind, allowing you to build any type of service your system requires, including database services.\n\n\nFeature Highlights\n\n\nEssential Features\nRailway has developed some essential features for enabling any type of database service to run in Railway - Volumes for persisting your data, and TCP Proxy for facilitating communication to your database from the internet.\nDatabase Templates\nNot only is our Template Marketplace filled with many different database service templates, but Railway also maintains several templates for some of the most popular databases out there - PostgreSQL, MySQL, MongoDB, and Redis.\n\n\nUse the next few pages to understand how to build your own database service or how to use the templates available.\n\n\nNote that the Railway-provided databases are still considered unmanaged services, meaning you will need to take the appropriate steps to ensure they are optimized for your usecase.\nPrev\n \nOptimize Usage\nNext\n \nBuild a Database Service\nEdit this file on GitHub\nOn This Page\nFeature Highlights"
  },
  {
    "url": "https://docs.railway.app/guides/deploy",
    "title": "Deploy a Template | Railway Docs",
    "content": "Deploy a Template\nTemplates allow you to deploy a fully configured project that is automatically\nconnected to infrastructure.\n\n\nYou can find featured templates on our \ntemplate marketplace\n.\n\n\nTemplate Deployment Flow\n\n\nTo deploy a template -\n\n\n\n\nFind a template from the marketplace and click \nDeploy Now\n\n\nIf necessary, configure the required variables, and click \nDeploy\n\n\nUpon deploy, you will be taken to your new project containing the template service(s)\n\n\n\n\nServices are deployed directly from the defined source in the template configuration\n\n\nAfter deploy, you can find the service source by going to the service's settings tab\n\n\nShould you need to make changes to the source code, you will need to \neject from the template repo\n to create your own copy.  See next section for more detail.\n\n\n\n\n\n\n\n\nNote:  You can also deploy templates into existing projects, by clicking \n+ New\n from your project canvas and selecting \nTemplate\n.\n\n\nEject from Template Repository\n\n\nAs of March 2024, the default behavior for deploying templates, is to attach to and deploy directly from the template repository.  Therefore, you will not automatically get a copy of the repository on deploy.  Follow the steps below to create a repository for yourself.\n\n\nBy default, services deployed from a template are attached to and deployed directly from the template repository.  In some cases, you may want to have your own copy of the template repository.\n\n\nFollow these steps to eject from the template repository and create a mirror in your own GitHub account.\n\n\n\n\nIn the \nservice settings\n, under Source, find the \nUpstream Repo\n setting\n\n\nClick the \nEject\n button\n\n\nSelect the appropriate GitHub organization to create the new repository\n\n\nClick \nEject service\n\n\n\n\nUpdatable Templates\n\n\nWhen you deploy any services from a template based on a GitHub repo, every time you visit the project in Railway, we will check to see if the project it is based on has been updated by its creator.\n\n\nIf it has received an upstream update, we will create a branch on the GitHub repo that was created when deploying the template, allowing for you to test it out within a PR deploy.\n\n\nIf you are happy with the changes, you can merge the pull request, and we will automatically deploy it to your production environment.\n\n\nIf you're curious, you can read more about how we built updatable templates in this \nblog post\n\n\nNote: This feature only works for services based on GitHub repositories.  At this time, we do not have a mechanism to check for updates to Docker images from which services may be sourced.\nPrev\n \nPublish and Share\nNext\n \nPublic API\nEdit this file on GitHub\nOn This Page\nTemplate Deployment Flow\nEject from Template Repository\nUpdatable Templates"
  },
  {
    "url": "https://docs.railway.app/guides/deployment-actions",
    "title": "Deployment Actions | Railway Docs",
    "content": "Deployment Actions\nVarious actions can be taken on Deployments from within the Service -> Deployments tab and clicking on the three dots at the end of a previous deployment.\n\n\n\n\nRollback\n\n\nRollback to previous deployments if mistakes were made.  To perform a rollback, click the three dots at the end of a previous deployment, you will then be asked to confirm your rollback.\n\n\n\n\nA deployment rollback will revert to the previously successful deployment. Both the Docker\nimage and custom variables are restored during the rollback process.\n\n\nNote: Deployments older than 2 weeks cannot be restored via rollback due to Railway's 2 week image retention policy.\n\n\nRedeploy\n\n\nA successful, failed, or crashed deployment can be re-deployed by clicking the three dots at the end of a previous deployment.\n\n\n\n\nThis will create an new deployment with the exact same code and build/deploy configuration.\n\n\nNote: To trigger a deployment from the latest commit, use the Command Pallette: \nCMD + K\n -> \"Deploy Latest Commit\".  This will deploy the latest commit from the \nDefault\n branch in GitHub.\n\n\nCurrently, there is no way to force a deploy from a branch other than the Default without \nconnecting it in your service settings\n.\n\n\nCancel\n\n\nUsers can cancel deployments in progress by clicking the three dots at the end\nof the deployment tab and select Abort deployment. This will cancel the\ndeployment in progress.\n\n\nRemove\n\n\nIf a deployment is completed, you can remove it by clicking the three dots\nat the end of the deployment tab and select Remove. This will remove the\ndeployment and stop any further project usage.\n\n\nRestart a Crashed Deployment\n\n\nWhen a Deployment is \nCrashed\n, it is no longer running because the underlying process exited with a non-zero exit code - if your deployment exits successfully (exit code 0), the status will remain \nSuccess\n.\n\n\nRailway automatically restarts crashed Deployments up to 10 times (depending on your \nRestart Policy\n). After this limit is reached, your deployment status is changed to \nCrashed\n and notifying webhooks & emails are sent to the project's members.\n\n\nRestart a \nCrashed\n Deployment by visiting your project and clicking on the \"Restart\" button that appears in-line on the Deployment:\n\n\n\n\nRestarting a crashed Deployment restores the exact image containing the code & configuration of the original build. Once the Deployment is back online, its status will change back to \nSuccess\n.\n\n\nYou can also click within a deployment and using the Command Palette restart a deployment at any state.\n\n\nStartup Order\n\n\nYou can control the order your services start up with \nReference Variables\n.\nWhen one service references another, it will be deployed after the service it is referencing when\napplying a \nstaged change\n or \nduplicating an environment\n.\n\n\nAn example of when this is useful is deploying an API service that depends on a \nPostgreSQL database\n.\nPrev\n \nStart Command\nNext\n \nGitHub Autodeploys\nEdit this file on GitHub\nOn This Page\nRollback\nRedeploy\nCancel\nRemove\nRestart a Crashed Deployment\nStartup Order"
  },
  {
    "url": "https://docs.railway.app/guides/deployments",
    "title": "Deployments | Railway Docs",
    "content": "Deployments\nLet's configure your deployments!\n\n\nNow that you understand how to tailor your builds if necessary, let's get into the various ways you can control how your services are deployed and run.  Like builds, when you deploy a service, Railway will apply some defaults that can easily be overridden when necessary.\n\n\nDeployment Concepts\n\n\nDeployment Controls\nDeployments are attempts to build and run your code.  Railway provides controls for changing the default run behavior, and for acting on existing deployments, for example rolling back to a previous deployment or restarting a service.\nAuto Deploys\nIf you have deployed from your GitHub repo, we will automatically build and deploy your code when you push a change to the connected branch.\nRegional Deployments\nBy default, services are deployed to your \npreferred region\n. To optimize performance for your users in other parts of the world, we offer regional deployments.\nScaling\nScaling your application has never been so easy.  Vertical auto-scaling is performed without any configuration on your part.  Horizontal scaling is made possible with replicas.\nHealthchecks\nHealthchecks can be configured on your services to control when a new deployment is deemed healthy and ready for connections.\nMonorepos\nUsing a monorepo?  We do too!  To deploy your monorepo, you'll need to let us know how your repo is structured using the various configuration options.\nScheduled Jobs\nScheduled Jobs, or Cron Jobs, are pieces of code that are executed on a schedule.  You'll find it's easy to schedule a job to run, using our Cron Schedule configuration.\nUsage Optimization\nGive yourself some peace of mind by using the various controls to tighten your usage.  You can set Usage Limits and configure your deployments to auto-sleep when inactive.\n\n\nDive into the next pages to learn how to configure these items.\nPrev\n \nDockerfiles\nNext\n \nPre-Deploy Command\nEdit this file on GitHub\nOn This Page\nDeployment Concepts"
  },
  {
    "url": "https://docs.railway.app/guides/django",
    "title": "Deploy a Django App | Railway Docs",
    "content": "Deploy a Django App\nDjango\n is a powerful Python web framework that simplifies web development by providing ready-to-use tools for rapid development and clean design.\n\n\nItâ€™s free, open-source, and comes with a range of features to streamline tasks like authentication, routing, and database management, so developers can focus on building their applications without handling everything from scratch.\n\n\nCreate a Django App\n\n\nNote:\n If you already have a Django app locally or on GitHub, you can skip this step and go straight to the \nDeploy Django App on Railway\n.\n\n\nTo create a new Django app, ensure that you have \nPython\n and \nDjango\n installed on your machine.\n\n\nFollow the steps below to set up the project in a directory.\n\n\nCreate a virtual environment\n\n\npython -m venv \nenv\n\n\nActivate the virtual environment\n\n\nsource\n env/bin/activate\n\n\nNote:\n For windows developers, run it as \nenv\\Scripts\\activate\n in your terminal.\n\n\nInstall Django\n\n\npython -m pip \ninstall\n django\n\n\nOnce everything is set up, run the following command in your terminal to provision a new Django project:\n\n\ndjango-admin startproject liftoff\n\n\nThis command will create a new Django project named \nliftoff\n.\n\n\nNext, \ncd\n into the directory and run \npython manage.py runserver\n to start your project.\n\n\nOpen your browser and go to \nhttp://127.0.0.1:8000\n to see the project. You'll see the Django welcome page with a \"The install worked successfully! Congratulations!\" paragraph.\n\n\nNote:\n You'll see a red notice about unapplied migration(s). You can ignore them for now. We'll run them when we deploy the project.\n\n\nNow that your app is running locally, letâ€™s move on to make some changes and install some dependencies before deployment.\n\n\nConfigure Database, Static Files & Dependencies\n\n\n\n\nInstall the following packages within the \nliftoff\n directory, where you can see the \nmanage.py\n file.\n\n\n\n\npython -m pip \ninstall\n gunicorn whitenoise psycopg\n[\nbinary,pool\n]\n\n\nwhitenoise\n is a Python package for serving static files directly from your web app. It serves compressed content and sets far-future cache headers on content that won't change.\n\n\ngunicorn\n is a production ready web server.\n\n\npyscog\n is python package that allows Django work with Postgresql.\n\n\n\n\nImport the \nos\n module:\n\n\n\n\nOpen the \nliftoff/settings.py\n file located in the inner \nliftoff\n directory (the one containing the main project settings).\n\n\nAt the top of the file, add the following line to import the \nos\n module, placing it just before the \nPath\n import:\n\n\nimport\n os\n\nfrom\n pathlib \nimport\n Path\n\n\n\n\nConfigure the database and run migrations:\n\n\n\n\nA fresh Django project uses SQLite by default, but we need to switch to PostgreSQL.\n\n\nCreate a database named \nliftoff_dev\n in your local Postgres instance.\n\n\nOpen the \nliftoff/settings.py\n file. In the Database section, replace the existing configuration with:\n\n\n# Database\n\n\n# https://docs.djangoproject.com/en/5.1/ref/settings/#databases\n\n\n\n\n# Set default values for the environment variables if theyâ€™re not already set\n\n\nos\n.\nenviron\n.\nsetdefault\n(\n\"PGDATABASE\"\n,\n \n\"liftoff_dev\"\n)\n\n\nos\n.\nenviron\n.\nsetdefault\n(\n\"PGUSER\"\n,\n \n\"username\"\n)\n\n\nos\n.\nenviron\n.\nsetdefault\n(\n\"PGPASSWORD\"\n,\n \n\"\"\n)\n\n\nos\n.\nenviron\n.\nsetdefault\n(\n\"PGHOST\"\n,\n \n\"localhost\"\n)\n\n\nos\n.\nenviron\n.\nsetdefault\n(\n\"PGPORT\"\n,\n \n\"5432\"\n)\n\n\n\n\nDATABASES \n=\n \n{\n\n\n    \n'default'\n:\n \n{\n\n\n        \n'ENGINE'\n:\n \n'django.db.backends.postgresql'\n,\n\n\n        \n'NAME'\n:\n os\n.\nenviron\n[\n\"PGDATABASE\"\n]\n,\n\n\n        \n'USER'\n:\n os\n.\nenviron\n[\n\"PGUSER\"\n]\n,\n\n\n        \n'PASSWORD'\n:\n os\n.\nenviron\n[\n\"PGPASSWORD\"\n]\n,\n\n\n        \n'HOST'\n:\n os\n.\nenviron\n[\n\"PGHOST\"\n]\n,\n\n\n        \n'PORT'\n:\n os\n.\nenviron\n[\n\"PGPORT\"\n]\n,\n\n\n    \n}\n\n\n}\n\n\nReplace the values of \nPGUSER\n, \nPGPASSWORD\n with your local credentials.\n\n\nRun \npython manage.py migrate\n in your terminal to apply the database migrations. Once it completes successfully, check your database. You should see the auth and other Django tables created.\n\n\n\n\nStatic files configuration:\n\n\n\n\nWe'll configure Django to serve static files using \nWhiteNoise\n.\n\n\nOpen \nliftoff/settings.py\n and configure the static files settings:\n\n\nSTATIC_URL \n=\n \n'static/'\n\n\n\n\nSTATIC_ROOT \n=\n os\n.\npath\n.\njoin\n(\nBASE_DIR\n,\n \n\"staticfiles\"\n)\n\n\nSTATICFILES_DIRS \n=\n \n[\nos\n.\npath\n.\njoin\n(\nBASE_DIR\n,\n \n\"static\"\n)\n]\n\n\nAdd the WhiteNoise middleware in the \nMIDDLEWARE\n section, just below the \nsecurity middleware\n:\n\n\nMIDDLEWARE \n=\n \n[\n\n\n    \n'django.middleware.security.SecurityMiddleware'\n,\n\n\n    \n'whitenoise.middleware.WhiteNoiseMiddleware'\n,\n\n\n    \n'django.contrib.sessions.middleware.SessionMiddleware'\n,\n\n\n    \n'django.middleware.common.CommonMiddleware'\n,\n\n\n    \n'django.middleware.csrf.CsrfViewMiddleware'\n,\n\n\n    \n'django.contrib.auth.middleware.AuthenticationMiddleware'\n,\n\n\n    \n'django.contrib.messages.middleware.MessageMiddleware'\n,\n\n\n    \n'django.middleware.clickjacking.XFrameOptionsMiddleware'\n,\n\n\n]\n\n\n\n\nUpdate \nALLOWED_HOSTS\n settings:\n\n\n\n\nALLOWED_HOSTS \n=\n \n[\n\"*\"\n]\n\n\nThis setting represents the list of all the host/domain names our Django project can serve.\n\n\n\n\nCreate a \nstatic\n folder:\n\n\n\n\nInside your \nliftoff\n directory, create a static folder where all static assets will reside.\n\n\n\n\nCreate a \nrequirements.txt\n file:\n\n\n\n\nTo track all the dependencies for deployment, create a \nrequirements.txt\n file:\n\n\npip freeze \n>\n requirements.txt\n\n\nNote:\n It's only safe to run the command above in a virtual environment, else it will freeze all python packages installed on your system.\n\n\nWith these changes, your Django app is now ready to be deployed to Railway!\n\n\nDeploy Django App on Railway\n\n\nRailway offers multiple ways to deploy your Django app, depending on your setup and preference. Choose any of the following methods:\n\n\n\n\nOne-click deploy from a template\n.\n\n\nUsing the CLI\n.\n\n\nFrom a GitHub repository\n.\n\n\n\n\nOne-Click Deploy From a Template\n\n\nIf youâ€™re looking for the fastest way to get started, the one-click deploy option is ideal. It sets up a Django app along with a Postgres database.\n\n\nClick the button below to begin:\n\n\n\n\nAfter deploying, we recommend that you \neject from the template\n to create a copy of the repository under your own GitHub account. This will give you full control over the source code and project.\n\n\nDeploy From the CLI\n\n\nTo deploy the Django app using the Railway CLI, please follow the steps:\n\n\n\n\nInstall the Railway CLI\n:\n\n\n\n\nInstall the CLI\n and \nauthenticate it\n using your Railway account.\n\n\n\n\n\n\nInitialize a Railway Project\n:\n\n\n\n\nRun the command below in your Django app directory.\n\n\nrailway init\n\n\n\n\nFollow the prompts to name your project.\n\n\nAfter the project is created, click the provided link to view it in your browser.\n\n\n\n\n\n\nDeploy the Application\n:\n\n\n\n\nUse the command below to deploy your app:\n\n\nrailway up\n\n\n\n\nThis command will scan, compress and upload your app's files to Railway. Youâ€™ll see real-time deployment logs in your terminal.\n\n\n\n\nNote:\n You'll encounter an error about the PGDATABASE environment not set. Don't worry, we'll fix that in the next steps.\n\n\nAdd a Database Service\n:\n\n\n\n\nRun \nrailway add\n.\n\n\nSelect \nPostgreSQL\n by pressing space and hit \nEnter\n to add it to your project.\n\n\nA database service will be added to your Railway project.\n\n\n\n\n\n\nConfigure Environment Variables\n:\n\n\n\n\nGo to your app service \nVariables\n section and add the following:\n\n\n\n\nPGDATABASE\n: Set the value to \n${{Postgres.PGDATABASE}}\n (this references the Postgres database name). Learn more about \nreferencing service variables\n.\n\n\nPGUSER\n: Set the value to \n${{Postgres.PGUSER}}\n\n\nPGPASSWORD\n: Set the value to \n${{Postgres.PGPASSWORD}}\n\n\nPGHOST\n: Set the value to \n${{Postgres.PGHOST}}\n\n\nPGPORT\n: Set the value to \n${{Postgres.PGPORT}}\n\n\n\n\n\n\nUse the \nRaw Editor\n to add any other required environment variables in one go.\n\n\n\n\n\n\nRedeploy the App Service\n:\n\n\n\n\nClick \nDeploy\n on the app service on the Railway dashboard to apply your changes.\n\n\n\n\n\n\nVerify the Deployment\n:\n\n\n\n\nOnce the deployment completes, go to \nView logs\n to check if the server is running successfully.\n\n\n\n\n\n\nSet Up a Public URL\n:\n\n\n\n\nNavigate to the \nNetworking\n section under the \nSettings\n tab of your new service.\n\n\nClick \nGenerate Domain\n to create a public URL for your app.\n\n\n\n\n\n\n\n\n\n\nDeploy From a GitHub Repo\n\n\nTo deploy the Django app to Railway, start by pushing the app to a GitHub repo. Once thatâ€™s set up, follow the steps below to complete the deployment process.\n\n\n\n\n\n\nCreate a New Project on Railway\n:\n\n\n\n\nGo to \nRailway\n to create a new project.\n\n\n\n\n\n\n\n\nDeploy from GitHub\n:\n\n\n\n\nSelect \nDeploy from GitHub repo\n and choose your repository.\n\n\n\n\nIf your Railway account isnâ€™t linked to GitHub yet, youâ€™ll be prompted to do so.\n\n\n\n\n\n\n\n\n\n\n\n\nAdd Environment Variables\n:\n\n\n\n\nClick \nAdd Variables\n and configure all the necessary environment variables for your app.\n\n\n\n\nPGDATABASE\n: Set the value to \n${{Postgres.PGDATABASE}}\n (this references the Postgres database name). Learn more about \nreferencing service variables\n.\n\n\nPGUSER\n: Set the value to \n${{Postgres.PGUSER}}\n\n\nPGPASSWORD\n: Set the value to \n${{Postgres.PGPASSWORD}}\n\n\nPGHOST\n: Set the value to \n${{Postgres.PGHOST}}\n\n\nPGPORT\n: Set the value to \n${{Postgres.PGPORT}}\n\n\n\n\n\n\n\n\nNote:\n We don't have the Postgres Database service yet. We'll add that soon.\n\n\n\n\n\n\nAdd a Database Service\n:\n\n\n\n\nRight-click on the Railway project canvas or click the \nCreate\n button.\n\n\nSelect \nDatabase\n.\n\n\nSelect \nAdd PostgreSQL\n from the available databases.\n\n\n\n\nThis will create and deploy a new Postgres database service for your project.\n\n\n\n\n\n\n\n\n\n\n\n\nDeploy the App\n:\n\n\n\n\nClick \nDeploy\n to start the deployment process and apply all changes.\n\n\nOnce deployed, a Railway \nservice\n will be created for your app, but it wonâ€™t be publicly accessible by default.\n\n\n\n\n\n\n\n\nVerify the Deployment\n:\n\n\n\n\nOnce the deployment completes, go to \nView logs\n to check if the server is running successfully.\n\n\n\n\nNote:\n During the deployment process, Railway will automatically \ndetect that itâ€™s a Django app\n.\n\n\n\n\n\n\nSet Up a Public URL\n:\n\n\n\n\nNavigate to the \nNetworking\n section under the \nSettings\n tab of your new service.\n\n\nClick \nGenerate Domain\n to create a public URL for your app.\n\n\n\n\n\n\n\n\nThis guide covers the main deployment options on Railway. Choose the approach that suits your setup, and start deploying your Django apps effortlessly!\n\n\nNote:\n The next step shows how to configure and run your Django app along with Celery and Celery beat.\n\n\nSet Up Database, Migrations, Celery Beat and Celery\n\n\nThis setup deploys your Django app on Railway, ensuring that your database, scheduled tasks (crons)--Celery Beat, and queue workers (Celery) are all fully operational.\n\n\nThe deployment structure follows a \"majestic monolith\" architecture, where the entire Django app is managed as a single codebase but split into four separate services on Railway:\n\n\n\n\nApp Service\n: Handles HTTP requests and user interactions.\n\n\nCron Service\n: Manages scheduled tasks (e.g., sending emails or running reports) using Celery Beat.\n\n\nWorker Service\n: Processes background jobs from the queue using Celery.\n\n\nDatabase Service\n: Stores and retrieves your application's data.\n\n\n\n\n\n\nMy Monolith Django app\n\n\nNote:\n This guide follows the assumption that you have installed Celery and Celery Beat in your app, the broker uses Redis and you already have a Postgres database service provisioned for your app as shown earlier.\n\n\nPlease follow these steps to get it setup on Railway:\n\n\n\n\nCreate a Redis Database service on the \nProject Canvas\n by clicking the \nCreate\n button. Then select \nDatabase\n and choose \nAdd Redis\n.\n\n\n\n\nClick on \nDeploy\n.\n\n\n\n\n\n\nCreate a new service on the \nProject Canvas\n by clicking the \nCreate\n button. Then select \nEmpty service\n.\n\n\n\n\nName the service \nApp Service\n, and click on \nSettings\n to configure it.\n\n\n\n\nNote:\n If you followed the guide from the beginning, simply rename the existing service to \nApp Service\n.\n\n\n\n\n\n\nConnect your GitHub repo to the  \nSource Repo\n in the \nSource\n section.\n\n\nGo to the top of the service and click on \nVariables\n.\n\n\nAdd all the necessary environment variables required for the Django app especially the ones listed below.\n\n\n\n\nREDIS_URL\n: Set the value to \n${{Postgres.REDIS_URL}}\n\n\nPGUSER\n: Set the value to \n${{Postgres.PGUSER}}\n\n\nPGPASSWORD\n: Set the value to \n${{Postgres.PGPASSWORD}}\n\n\nPGHOST\n: Set the value to \n${{Postgres.PGHOST}}\n\n\nPGPORT\n: Set the value to \n${{Postgres.PGPORT}}\n\n\nPGDATABASE\n: Set the value to \n${{Postgres.PGDATABASE}}\n (this references the Postgres database name). Learn more about \nreferencing service variables\n.\n\n\n\n\n\n\nClick \nDeploy\n.\n\n\n\n\n\n\nCreate a new service on the \nProject Canvas\n by clicking the \nCreate\n button. Then select \nEmpty service\n.\n\n\n\n\nName the service \nCron Service\n, and click on \nSettings\n.\n\n\nConnect your GitHub repo to the  \nSource Repo\n in the \nSource\n section.\n\n\nAdd \ncelery -A liftoff beat -l info --concurrency=3\n to the \nCustom Start Command\n in the \nDeploy\n section.\n\n\n\n\nNote:\n \nliftoff\n is the name of the app. You can find the app name in your Django projectâ€™s main folder, typically in the directory containing \nsettings.py\n.\n\n\nThe \n--concurrency=3\n option here means it can process up to 3 tasks in parallel. You can adjust the \nconcurrency level\n based on your system resources. The higher the level, the more memory and resources it consumes.\n\n\n\n\n\n\nHead back to the top of the service and click on  \nVariables\n.\n\n\nAdd all the necessary environment variables especially those highlighted already in step 2.\n\n\nClick \nDeploy\n.\n\n\n\n\n\n\nCreate a new service again on the \nProject Canvas\n.\n\n\n\n\nName the service \nWorker Service\n, and click on \nSettings\n.\n\n\nConnect your GitHub repo to the  \nSource Repo\n in the \nSource\n section.\n\n\nAdd \ncelery -A liftoff worker -l info --concurrency=3\n to the \nCustom Start Command\n in the \nDeploy\n section.\n\n\n\n\nNote:\n \nliftoff\n is the name of the app. You can find the app name in your Django projectâ€™s main folder, typically in the directory containing \nsettings.py\n.\n\n\nThe \n--concurrency=3\n option here means it can process up to 3 tasks in parallel. You can adjust the \nconcurrency level\n based on your system resources. The higher the level, the more memory and resources it consumes.\n\n\n\n\n\n\nHead back to the top of the service and click on \nVariables\n.\n\n\nAdd all the necessary environment variables especially those highlighted already in step 2.\n\n\nClick \nDeploy\n.\n\n\n\n\n\n\n\n\nAt this point, you should have all services deployed and connected to the Postgres and Redis Database service:\n\n\n\n\n\n\nCron Service\n: This service should run Celery Beat Scheduler to manage scheduled tasks.\n\n\n\n\n\n\n\n\nWorker Service\n: This service should be running Celery and ready to process jobs from the queue.\n\n\n\n\n\n\n\n\nApp Service\n: This service should be running and is the only one that should have a public domain, allowing users to access your application.\n\n\n\n\nNote:\n There is a \ncommunity template\n available that demonstrates this deployment approach. You can easily deploy this template and then connect it to your own GitHub repository for your application.\n\n\nNext Steps\n\n\nExplore these resources to learn how you can maximize your experience with Railway:\n\n\n\n\nMonitoring\n\n\nDeployments\n\n\nPrev\n \nSails\nNext\n \nAngular\nEdit this file on GitHub\nOn This Page\nCreate a Django App\nConfigure Database, Static Files & Dependencies\nDeploy Django App on Railway\nOne-Click Deploy From a Template\nDeploy From the CLI\nDeploy From a GitHub Repo\nSet Up Database, Migrations, Celery Beat and Celery\nNext Steps"
  },
  {
    "url": "https://docs.railway.app/guides/dockerfiles",
    "title": "Build from a Dockerfile | Railway Docs",
    "content": "Build from a Dockerfile\nWe will look for and use a \nDockerfile\n at the service's root if it exists.\n\n\nRailway notifies you when it's using the \nDockerfile\n in the build process with the following message in the logs:\n\n\n==\n==\n==\n==\n==\n==\n==\n==\n==\n==\n==\n==\n==\n\n\nUsing detected Dockerfile\n!\n\n\n==\n==\n==\n==\n==\n==\n==\n==\n==\n==\n==\n==\n==\n\n\nCustom Dockerfile Path\n\n\nBy default, we look for a file named \nDockerfile\n in the root directory.  If you want to use a custom filename or path, you can set a variable defining the path.\n\n\nIn your \nservice variables\n, set a variable named \nRAILWAY_DOCKERFILE_PATH\n to specify the path to the file.\n\n\nFor example, if your Dockerfile was called \nDockerfile.origin\n, you would specify it like this:\n\n\nRAILWAY_DOCKERFILE_PATH\n=\nDockerfile.origin\n\n\nIf your Dockerfile is in another directory, specify it like this:\n\n\nRAILWAY_DOCKERFILE_PATH\n=\n/build/Dockerfile\n\n\nUse Config as Code\n\n\nYou can also set your custom Dockerfile path using \nconfig as code\n.\n\n\nUsing Variables at Build Time\n\n\nIf you need to use the environment variables that Railway injects at build time, which include \nvariables that you define\n and \nRailway-provided variables\n, you must specify them in the Dockerfile using the \nARG\n command.\n\n\nFor example:\n\n\n# Specify the variable you need\n\n\nARG\n RAILWAY_SERVICE_NAME\n\n\n# Use the varible\n\n\nRUN\n echo \n$RAILWAY_SERVICE_NAME\n\n\nBe sure to declare your environment variables in the stage they are required in:\n\n\nFROM\n node\n\n\n\n\nARG\n RAILWAY_ENVIRONMENT\n\n\nCache Mounts\n\n\nRailway supports cache mounts in your Dockerfile in the following format:\n\n\n--mount=type=cache,id=s/<service id>-<target path>,target=<target path>\n\n\nReplace \n<service id>\n with the id of the service.\n\n\nTarget Path\n\n\nUnsure of what your target path should be?  Refer to the \nNixpacks source code\n.  Within the providers directory, find the file that aligns with your respective language or runtime, and check for the variable that indicates the CACHE_DIR.\n\n\nExample\n\n\nAs an example, within the \npython provider definition\n, you can see the \nPIP_CACHE_DIR\n is \n/root/.cache/pip\n.\n\n\nSo the mount command is specified like this:\n\n\n--mount=type=cache,id=s/<service id>-/root/cache/pip,target=/root/.cache/pip\n\n\nDocker Compose\n\n\nYou can import services straight from your Docker Compose file! Just drag and drop your Compose file onto your \nproject canvas\n, and your services (and any mounted volumes) will be auto-imported as staged changes. Itâ€™s like magic, but with YAML instead of wands. ðŸª„\n\n\nA quick heads-up: we donâ€™t support every possible Compose config just yet (because Rome wasnâ€™t built in a day). But donâ€™t worry, weâ€™re on it!\nPrev\n \nBuild Configuration\nNext\n \nDeployments\nEdit this file on GitHub\nOn This Page\nCustom Dockerfile Path\nUse Config as Code\nUsing Variables at Build Time\nCache Mounts\nTarget Path\nDocker Compose"
  },
  {
    "url": "https://docs.railway.app/guides/environments",
    "title": "Using Environments | Railway Docs",
    "content": "Using Environments\nRailway supports complex development workflows through environments, giving you isolated instances of all services in a project.\n\n\nCreate an Environment\n\n\n\n\n\n\nSelect \n+ New Environment\n from the environment drop down in the top navigation. You can also go to Settings > Environments.\n\n\n\n\n\n\nChoose which type of environment to create -\n\n\n\n\n\n\nDuplicate Environment\n creates a copy of the selected environment, including services, variables, and configuration.\n\n\nWhen the duplicate environment is created, all services and their configuration will be staged for deployment.\n\nYou must review and approve the \nstaged changes\n before the services deploy.\n\n\n\n\n\n\nEmpty Environment\n creates an empty environment with no services.\n\n\n\n\n\n\n\n\n\n\n\n\nSync Environments\n\n\nYou can easily sync environments to \nimport\n one or more services from one environment into another environment.\n\n\n\n\nEnsure your current environment is the one that should \nreceive\n the synced service(s)\n\n\nClick \nSync\n at the top of the canvas\n\n\nSelect the environment from which to sync changes\n\n\nUpon sync, each service card that has received a change will be tagged \"New\", \"Edited\", \"Removed\"\n\n\nReview the \nstaged changes\n by clicking Details on the staged changes banner\n\n\nClick \"Deploy\" once you are ready to apply the changes and re-deploy\n\n\n\n\n\n\n\n\nEnable PR Environments\n\n\nRailway can spin up a temporary environment whenever you open a Pull Request. To enable PR environments, go to your Project Settings -> Environments tab.\n\n\n\n\nWhen enabled, a temporary environment is spun up to support the Pull Request deploy. These environments are deleted as soon as these PRs are merged or closed.\n\n\nHow Come my GitHub PR Won't Deploy?\n\n\nRailway will not deploy a PR branch from a user who is not in your team or invited to your project without their associated GitHub account.\n\n\nBot PR Environments\n\n\nYou can enable automatic PR environment creation for PRs opened by GitHub bots (Dependabot, Renovatebot) using the \nEnable Bot PR Environments\n toggle on the Environments tab in the Project Settings page.\n\n\n\n\nForked Environments\n\n\nAs of January 2024, forked environments have been deprecated in favor of Isolated Environments with the ability to Sync.\n\n\nAny environments forked prior to this change will remain, however, you must adopt the \nSync Environments\n flow, in order to merge changes into your base environment.\nPrev\n \nVolumes\nNext\n \nCLI\nEdit this file on GitHub\nOn This Page\nCreate an Environment\nSync Environments\nEnable PR Environments\nBot PR Environments\nForked Environments"
  },
  {
    "url": "https://docs.railway.app/guides/express",
    "title": "Deploy an Express App | Railway Docs",
    "content": "Deploy an Express App\nExpress\n is a fast and flexible web application framework for Node.js that provides a simple and minimalistic approach to building web servers and APIs. It is known for its speed and unopinionated nature, allowing developers to structure their applications as they see fit while offering powerful features.\n\n\nThis guide covers how to deploy an Express app to Railway in four ways:\n\n\n\n\nOne-click deploy from a template\n.\n\n\nFrom a GitHub repository\n.\n\n\nUsing the CLI\n.\n\n\nUsing a Dockerfile\n.\n\n\n\n\nNow, let's create an Express app!\n\n\nCreate an Express App\n\n\nNote:\n If you already have an Express app locally or on GitHub, you can skip this step and go straight to the \nDeploy Express App to Railway\n.\n\n\nTo create a new Express app, ensure that you have \nNode\n installed on your machine.\n\n\nCreate a directory, \nhelloworld\n, and \ncd\n into it.\n\n\nRun the following command in your terminal to create a new Express app within the \nhelloworld\n directory:\n\n\nnpx express-generator --view\n=\npug\n\n\nA new Express app will be provisioned for you in the \nhelloworld\n directory using \npug\n as the view engine.\n\n\nRun the Express App locally\n\n\nRun \nnpm install\n to install all the dependencies.\n\n\nNext, start the app by running the following command:\n\n\nnpm\n start\n\n\nLaunch your browser and navigate to \nhttp://localhost:3000\n to view the app.\n\n\nIf you'd prefer to run the app on a different port, simply use the command \nPORT=8080 npm start\n in the terminal.\n\n\nAfterward, you can access the app at \nhttp://localhost:8080\n.\n\n\nAdd and Configure Database\n\n\nNote:\n We will be using Postgres for this app. If you donâ€™t have it installed locally, you can either \ninstall it\n or use a different Node.js database package of your choice.\n\n\n\n\n\n\nCreate a database named \nexpresshelloworld_dev\n.\n\n\n\n\n\n\nInstall the \npg-promise\n package:\n\n\n\n\n\n\nnpm\n i pg-promise\n\n\n\n\nOpen the \nroutes/index.js\n file and modify the content to the code below:\n\n\n\n\nconst\n express \n=\n \nrequire\n(\n'express'\n)\n;\n\n\nconst\n pgp \n=\n \nrequire\n(\n'pg-promise'\n)\n(\n)\n;\n\n\nconst\n db \n=\n \npgp\n(\n'postgres://username:password@127.0.0.1:5432/expresshelloworld_dev'\n)\n;\n\n\nconst\n router \n=\n express\n.\nRouter\n(\n)\n;\n\n\n\n\n/* GET home page. */\n\n\nrouter\n.\nget\n(\n'/'\n,\n \nfunction\n(\nreq\n,\n res\n,\n next\n)\n \n{\n\n\n  db\n.\none\n(\n\"SELECT NOW()\"\n)\n\n\n    \n.\nthen\n(\nfunction\n \n(\ndata\n)\n \n{\n\n\n      \n// Render the page only after receiving the data\n\n\n      res\n.\nrender\n(\n'index'\n,\n \n{\n \ntitle\n:\n \n'Hello World, Railway!'\n,\n \ntimeFromDB\n:\n data\n.\nnow \n}\n)\n;\n\n\n    \n}\n)\n\n\n    \n.\ncatch\n(\nfunction\n \n(\nerror\n)\n \n{\n\n\n      console\n.\nerror\n(\n\"ERROR:\"\n,\n error\n)\n;\n\n\n      \n// If thereâ€™s an error, send a 500 response and do not call res.render\n\n\n      res\n.\nstatus\n(\n500\n)\n.\nsend\n(\n\"Error querying the database\"\n)\n;\n\n\n    \n}\n)\n;\n\n\n}\n)\n;\n\n\n\n\nmodule\n.\nexports \n=\n router\n;\n\n\nThe code above sets up a simple Express app with a route handler for the home page. It uses the \npg-promise\n library to connect to a Postgres database and runs a query to fetch the current time from the database using \nSELECT NOW()\n. Upon receiving the data, it renders the index view with the fetched time, sending it to the client along with a title.\n\n\nIf an error occurs during the database query, the code catches the error, logs it, and sends a 500 status response to the client, indicating that there was an issue querying the database.\n\n\nThe page is only rendered after successfully receiving the database response to ensure proper handling of the data.\n\n\n\n\nOpen the \nviews/index.pug\n file, and update it to display the \ntimeFromDB\n value on the page.\n\n\n\n\nextends layout\n\n\nblock content\n  h1= title\n  p Welcome to #{title}\n  p This is the time retrieved from the database:\n  p #{timeFromDB}\n\n\n\n\nRun the app again to see your changes in action!\n\n\n\n\nPrepare Express App for Deployment\n\n\nIn the \nroutes/index.js\n file, replace the hardcoded Postgres database URL with an environment variable:\n\n\n...\n\n\nconst\n db \n=\n \npgp\n(\nprocess\n.\nenv\n.\nDATABASE_URL\n)\n;\n\n\n...\n\n\nThis allows the app to dynamically pull the correct database configuration from Railway during deployment.\n\n\nDeploy the Express App to Railway\n\n\nRailway offers multiple ways to deploy your Express app, depending on your setup and preference.\n\n\nOne-Click Deploy From a Template\n\n\nIf youâ€™re looking for the fastest way to get started with Express, Pug and connected to a Postgres database, the one-click deploy option is ideal.\n\n\nClick the button below to begin:\n\n\n\n\nFor Express API, here's another template you can begin with:\n\n\n\n\nWe highly recommend that \nyou eject from the template after deployment\n to create a copy of the repo on your GitHub account.\n\n\nNote:\n You can also choose from a \nvariety of Express app templates\n created by the community.\n\n\nDeploy From the CLI\n\n\n\n\nInstall the Railway CLI\n:\n\n\n\nInstall the CLI\n and \nauthenticate it\n using your Railway account.\n\n\n\n\n\n\nInitialize a Railway Project\n:\n\n\n\nRun the command below in your Express app directory.\n\nrailway init\n\n\n\n\nFollow the prompts to name your project.\n\n\nAfter the project is created, click the provided link to view it in your browser.\n\n\n\n\n\n\nAdd a Postgres Database Service\n:\n\n\n\nRun \nrailway add -d postgres\n.\n\n\nHit \nEnter\n to add it to your project.\n\n\nA database service will be added to your Railway project.\n\n\n\n\n\n\nAdd a Service and Environment Variable\n:\n\n\n\nRun \nrailway add\n.\n\n\nSelect \nEmpty Service\n from the list of options.\n\n\nIn the \nEnter a service name\n prompt, enter \napp-service\n.\n\n\nIn the \nEnter a variable\n prompt, enter \nDATABASE_URL=${{Postgres.DATABASE_URL}}\n.\n\n\n\nThe value, \n${{Postgres.DATABASE_URL}}\n, references the URL of your new Postgres database. Learn more about \nreferencing service variables\n.\n\n\n\n\n\n\n\n\nNote:\n Explore the \nRailway CLI reference\n for a variety of options.\n\n\nDeploy the Application\n:\n\n\n\nRun \nrailway up\n to deploy your app.\n\n\n\nThis command will scan, compress and upload your app's files to Railway. Youâ€™ll see real-time deployment logs in your terminal.\n\n\n\n\n\n\nOnce the deployment is complete, we can proceed to generate a domain for the app service.\n\n\n\n\n\n\nSet Up a Public URL\n:\n\n\n\nRun \nrailway domain\n to generate a public URL for your app.\n\n\nVisit the new URL to see your app live in action!\n\n\n\n\n\n\n\n\n\n\nDeploy From a GitHub Repo\n\n\nTo deploy an Express app to Railway directly from GitHub, follow the steps below:\n\n\n\n\n\n\nCreate a New Project on Railway\n:\n\n\n\n\nGo to \nRailway\n to create a new project.\n\n\n\n\n\n\n\n\nDeploy from GitHub\n:\n\n\n\n\nSelect \nDeploy from GitHub repo\n and choose your repository.\n\n\n\nIf your Railway account isnâ€™t linked to GitHub yet, youâ€™ll be prompted to do so.\n\n\n\n\n\n\n\n\n\n\n\n\nAdd Environment Variables and Provision a Database Service\n:\n\n\n\n\nClick \nAdd Variables\n, but hold off on adding anything just yet. First, proceed with the next step.\n\n\nRight-click on the Railway project canvas or click the \nCreate\n button, then select \nDatabase\n and choose \nAdd PostgreSQL\n.\n\n\n\nThis will create and deploy a new PostgreSQL database for your project.\n\n\n\n\n\n\nOnce the database is deployed, you can return to adding the necessary environment variables:\n\n\n\nDATABASE_URL\n: Set the value to \n${{Postgres.DATABASE_URL}}\n (this references the URL of your new Postgres database). Learn more about \nreferencing service variables\n.\n\n\n\n\n\n\n\n\n\n\n\n\nDeploy the App Service\n:\n\n\n\n\nClick \nDeploy\n on the Railway project canvas to apply your changes.\n\n\n\n\n\n\n\n\nVerify the Deployment\n:\n\n\n\n\nOnce the deployment completes, go to \nView logs\n to check if the server is running successfully.\n\n\n\n\nNote:\n During the deployment process, Railway will automatically \ndetect that itâ€™s a Node.js app via Nixpacks\n.\n\n\n\n\n\n\nSet Up a Public URL\n:\n\n\n\n\nNavigate to the \nNetworking\n section under the \nSettings\n tab of your new service.\n\n\nClick \nGenerate Domain\n to create a public URL for your app.\n\n\n\n\n\n\n\n\nUse a Dockerfile\n\n\n\n\nCreate a \nDockerfile\n in the Express app's root directory.\n\n\nAdd the content below to the \nDockerfile\n:\n\n# Use the Node official image\n\n\n# https://hub.docker.com/_/node\n\n\nFROM node:lts\n\n\n# Create and change to the app directory.\n\n\nWORKDIR /app\n\n\n# Copy local code to the container image\n\n\nCOPY \n.\n ./\n\n\n\n# Install packages\n\n\nRUN \nnpm\n ci\n\n\n\n# Serve the app\n\n\nCMD \n[\n\"npm\"\n, \n\"run\"\n, \n\"start\"\n]\n\n\n\n\nEither deploy via the CLI or from GitHub.\n\n\n\n\nRailway automatically detects the \nDockerfile\n, \nand uses it to build and deploy the app.\n\n\nNote:\n Railway supports also \ndeployment from public and private Docker images\n.\n\n\nThis guide covers the main deployment options on Railway. Choose the approach that suits your setup, and start deploying your Express apps seamlessly!\n\n\nNext Steps\n\n\nExplore these resources to learn how you can maximize your experience with Railway:\n\n\n\n\nAdd a Database Service\n\n\nMonitor your app\n\n\nPrev\n \nLanguages & Frameworks\nNext\n \nNest\nEdit this file on GitHub\nOn This Page\nCreate an Express App\nRun the Express App locally\nAdd and Configure Database\nPrepare Express App for Deployment\nDeploy the Express App to Railway\nOne-Click Deploy From a Template\nDeploy From the CLI\nDeploy From a GitHub Repo\nUse a Dockerfile\nNext Steps"
  },
  {
    "url": "https://docs.railway.app/guides/fastapi",
    "title": "Deploy a FastAPI App | Railway Docs",
    "content": "Deploy a FastAPI App\nFastAPI is a modern, fast (high-performance), web framework for building APIs with Python based on standard Python type hints.\n\n\nThis guide covers how to deploy a FastAPI app on Railway in four ways:\n\n\n\n\nOne-click deploy from a template\n.\n\n\nFrom a GitHub repository\n.\n\n\nUsing the CLI\n.\n\n\nUsing a Dockerfile\n.\n\n\n\n\nOne-Click Deploy From a Template\n\n\n\n\nWe highly recommend that \nyou eject from the template after deployment\n to create a copy of the repo on your GitHub account.\n\n\nNote:\n You can also choose from a \nvariety of FastAPI app templates\n created by the community.\n\n\nDeploy From a GitHub Repo\n\n\nTo deploy a FastAPI app on Railway directly from GitHub, follow the steps below:\n\n\n\n\nFork the basic \nFastAPI GitHub repo\n.\n\n\n\n\nIf you already have a GitHub repo you want to deploy, you can skip this step.\n\n\n\n\n\n\nCreate a \nNew Project.\n\n\nClick \nDeploy from GitHub repo\n.\n\n\nSelect the \nfastapi\n or your own GitHub repo.\n\n\n\n\nRailway requires a valid GitHub account to be linked. If your Railway account isn't associated with one, you will be prompted to link it.\n\n\n\n\n\n\nClick \nDeploy Now\n.\n\n\n\n\nOnce the deployment is successful, a Railway \nservice\n will be created for you. By default, this service will not be publicly accessible.\n\n\nTo set up a publicly accessible URL for the service, navigate to the \nNetworking\n section in the \nSettings\n tab of your new service and click on \nGenerate Domain\n.\n\n\n\n\nThe FastAPI app is run via a \nHypercorn server\n as defined by the \nstartCommand\n in the \nrailway.json\n file in the GitHub repository.\n\n\nRailway makes it easy to define deployment configurations for your services directly in your project using a \nrailway.toml or railway.json file\n, alongside your code.\n\n\nDeploy From the CLI\n\n\n\n\nInstall\n and \nauthenticate with the CLI.\n\n\nClone the forked \nfastapi GitHub repo\n and \ncd\n into the directory.\n\n\n\n\nYou can skip this step if you already have an app directory or repo on your machine that you want to deploy.\n\n\n\n\n\n\nRun \nrailway init\n within the app directory to create a new project.\n\n\nRun \nrailway up\n to deploy.\n\n\n\n\nThe CLI will now scan, compress and upload our fastapi app files to Railway's backend for deployment.\n\n\n\n\n\n\n\n\nUse a Dockerfile\n\n\nNote:\n If you already have an app directory or repo on your machine that you want to deploy, you can skip the first two steps.\n\n\n\n\nClone the forked \nfastapi\n repo and \ncd\n into the directory.\n\n\nDelete the \nrailway.json\n file.\n\n\nCreate a \nDockerfile\n in the \nfastapi\n or app's root directory.\n\n\nAdd the content below to the \nDockerfile\n:\n\n\n# Use the Python 3 alpine official image\n\n\n# https://hub.docker.com/_/python\n\n\nFROM python:3-alpine\n\n\n\n# Create and change to the app directory.\n\n\nWORKDIR /app\n\n\n\n# Copy local code to the container image.\n\n\nCOPY \n.\n \n.\n\n\n\n\n# Install project dependencies\n\n\nRUN pip \ninstall\n --no-cache-dir -r requirements.txt\n\n\n\n# Run the web service on container startup.\n\n\nCMD \n[\n\"hypercorn\"\n, \n\"main:app\"\n, \n\"--bind\"\n, \n\"::\"\n]\n\n\n\n\nEither deploy via the CLI or from GitHub.\n\n\n\n\nRailway automatically detects the \nDockerfile\n, \nand uses it to build and deploy the app.\n\n\nNote:\n Railway supports also \ndeployment from public and private Docker images\n.\n\n\nNext Steps\n\n\nExplore these resources to learn how you can maximize your experience with Railway:\n\n\n\n\nAdd a Database Service\n\n\nMonitor your app\n\n\nRunning a Cron Job\n\n\nPrev\n \nFastify\nNext\n \nFlask\nEdit this file on GitHub\nOn This Page\nOne-Click Deploy From a Template\nDeploy From a GitHub Repo\nDeploy From the CLI\nUse a Dockerfile\nNext Steps"
  },
  {
    "url": "https://docs.railway.app/guides/fastify",
    "title": "Deploy a Fastify App | Railway Docs",
    "content": "Deploy a Fastify App\nFastify is a high-performance, low-overhead web framework for Node.js, designed to deliver an exceptional developer experience.\n\n\nThis guide covers how to deploy a Fastify app on Railway in four ways:\n\n\n\n\nOne-click deploy from a template\n.\n\n\nFrom a GitHub repository\n.\n\n\nUsing the CLI\n.\n\n\nUsing a Dockerfile\n.\n\n\n\n\nOne-Click Deploy From a Template\n\n\n\n\nWe highly recommend that \nyou eject from the template after deployment\n to create a copy of the repo on your GitHub account.\n\n\nNote:\n You can also choose from a \nvariety of Fastify app templates\n created by the community.\n\n\nDeploy From a GitHub Repo\n\n\nTo deploy a Fastify app on Railway directly from GitHub, follow the steps below:\n\n\n\n\nFork the basic \nfastify GitHub repo\n.\n\n\n\n\nIf you already have a GitHub repo you want to deploy, you can skip this step.\n\n\n\n\n\n\nCreate a \nNew Project.\n\n\nClick \nDeploy from GitHub repo\n.\n\n\nSelect the \nfastify\n repo or your own GitHub repo.\n\n\n\n\nRailway requires a valid GitHub account to be linked. If your Railway account isn't associated with one, you will be prompted to link it.\n\n\n\n\n\n\nClick \nDeploy Now\n.\n\n\n\n\nOnce the deployment is successful, a Railway \nservice\n will be created for you. By default, this service will not be publicly accessible.\n\n\nTo set up a publicly accessible URL for the service, navigate to the \nNetworking\n section in the \nSettings\n tab of your new service and click on \nGenerate Domain\n.\n\n\n\n\nNote:\n Railway requires that Fastify's \n.listen\n method for the \nhost\n be set to \n::\n. This allows the app to be available over the \npublic\n and \nprivate network\n.\nYou can find this in the \nsample Fastify GitHub repo\n.\n\n\nIf you donâ€™t set it correctly, you may encounter a 502 error page.\n\n\nDeploy From the CLI\n\n\n\n\nInstall\n and \nauthenticate with the CLI.\n\n\nClone the forked \nfastify GitHub repo\n and \ncd\n into the directory.\n\n\n\n\nYou can skip this step if you already have an app directory or repo on your machine that you want to deploy.\n\n\n\n\n\n\nRun \nrailway init\n within the app directory to create a new project.\n\n\nRun \nrailway up\n to deploy.\n\n\n\n\nThe CLI will now scan, compress and upload our fastify app files to Railway's backend for deployment.\n\n\n\n\n\n\n\n\nUse a Dockerfile\n\n\n\n\nClone the forked \nfastify\n repo and \ncd\n into the directory.\n\n\n\n\nYou can skip this step if you already have an app directory or repo on your machine that you want to deploy.\n\n\n\n\n\n\nCreate a \nDockerfile\n in the \nfastify\n or app's root directory.\n\n\nAdd the content below to the \nDockerfile\n:\n\n\n# Use the Node.js 18 alpine official image\n\n\n# https://hub.docker.com/_/node\n\n\nFROM node:18-alpine\n\n\n\n# Create and change to the app directory.\n\n\nWORKDIR /app\n\n\n\n# Copy local code to the container image.\n\n\nCOPY \n.\n \n.\n\n\n\n\n# Install project dependencies\n\n\nRUN \nnpm\n ci\n\n\n\n# Run the web service on container startup.\n\n\nCMD \n[\n\"npm\"\n, \n\"start\"\n]\n\n\n\n\nEither deploy via the CLI or from GitHub.\n\n\n\n\nRailway automatically detects the \nDockerfile\n, \nand uses it to build and deploy the app.\n\n\nNote:\n Railway supports also \ndeployment from public and private Docker images\n.\n\n\nNext Steps\n\n\nExplore these resources to learn how you can maximize your experience with Railway:\n\n\n\n\nAdd a CDN using Amazon CloudFront to your Fastify app\n\n\nAdd a Database Service\n\n\nMonitor your app\n\n\nPrev\n \nNest\nNext\n \nFastAPI\nEdit this file on GitHub\nOn This Page\nOne-Click Deploy From a Template\nDeploy From a GitHub Repo\nDeploy From the CLI\nUse a Dockerfile\nNext Steps"
  },
  {
    "url": "https://docs.railway.app/guides/flask",
    "title": "Deploy a Flask App | Railway Docs",
    "content": "Deploy a Flask App\nFlask\n is a Python micro framework for building web applications.\n\n\nThis guide covers how to deploy a Flask app to Railway in four ways:\n\n\n\n\nOne-click deploy from a template\n.\n\n\nUsing the CLI\n.\n\n\nFrom a GitHub repository\n.\n\n\nUsing a Dockerfile\n.\n\n\n\n\nNow, let's create a Flask app!\n\n\nCreate a Flask App\n\n\nNote:\n If you already have a Flask app locally or on GitHub, you can skip this step and go straight to the \nDeploy Flask App to Railway\n.\n\n\nTo create a new Flask app, ensure that you have \nPython\n and \nFlask\n installed on your machine.\n\n\nFollow the steps blow to set up the project in a directory.\n\n\nCreate a project directory and \ncd\n into it.\n\n\nmkdir\n flaskproject\n\ncd\n flaskproject\n\n\nCreate a virtual environment\n\n\npython -m venv \nenv\n\n\nActivate the virtual environment\n\n\nsource\n env/bin/activate\n\n\nNote:\n For windows developers, run it as \nenv\\Scripts\\activate\n in your terminal.\n\n\nInstall Flask\n\n\npython -m pip \ninstall\n flask\n\n\nNow create a new file, \nhelloworld.py\n in the \nflaskproject\n directory. Add the following content to it:\n\n\nimport\n os\n\nfrom\n flask \nimport\n Flask\n\n\n\napp \n=\n Flask\n(\n__name__\n)\n\n\n\n\n\n\n@app\n.\nroute\n(\n'/'\n)\n\n\ndef\n \nhello\n(\n)\n:\n\n\n    \nreturn\n \n'Hello world, welcome to Railway!'\n\n\n\n\nfrom flask import Flask\n:\n\n\n\n\nThis line imports the Flask class from the Flask framework, which is used to create and manage a web application.\n\n\n\n\n\n\napp = Flask(__name__)\n:\n\n\n\n\nThis line creates an instance of the Flask class and assigns it to the app variable.\n\n\nThe \n__name__\n argument helps Flask identify the location of the application. It's useful for determining resource paths and error reporting.\n\n\n\n\n\n\n@app.route('/')\n:\n\n\n\n\nThe \n@app.route('/')\n decorator sets up a URL route for the app. When the root URL \n(/)\n is accessed, Flask will execute the function immediately below this decorator.\n\n\n\n\n\n\ndef hello():\n\n\n\n\nThe \nhello\n function returns a plain text message, \n\"Hello world, welcome to Railway!\"\n, which is displayed in the browser when the root URL of the app is accessed.\n\n\n\n\n\n\n\n\nRun the Flask App Locally\n\n\nTo run the application, use the \nflask\n command.\n\n\nflask --app helloworld run\n\n\nOpen your browser and go to \nhttp://127.0.0.1:5000\n to see the app running with a local development server.\n\n\nPrepare the Flask App for Deployment\n\n\n\n\nRun the following command to install a production web server, \ngunicorn\n:\n\n\n\n\npip \ninstall\n gunicorn\n\n\nNext, run the following command to serve the app with gunicorn:\n\n\ngunicorn main:app\n\n\n\n\nOpen your browser and go to \nhttp://127.0.0.1:8000\n to see the app running with a production server.\n\n\n\n\nCreate a \nrequirements.txt\n file to store the dependencies of the packages needed to run the app.\n\n\npip freeze \n>\n requirements.txt\n\n\nNote:\n It's only safe to run the command above in a virtual environment, else it will freeze all python packages installed on your system.\n\n\n\n\nFinally, create a \nnixpacks.toml\n file in the root directory of the app. Add the following content to it:\n\n\n\n\n# nixpacks.toml\n\n\n\n\n[\nstart\n]\n\n\ncmd\n \n=\n \n\"gunicorn main:app\"\n\n\nThis setup instructs Railway to use Gunicorn as the server to start the application.\n\n\nNote:\n The \nnixpacks.toml file\n is a configuration file used by Nixpacks, a build system developed and used by Railway, to set up and deploy applications.\n\n\nIn this file, you can specify the instructions for various build and deployment phases, along with environment variables and package dependencies.\n\n\nWith these changes, your Flask app is now ready to be deployed to Railway!\n\n\nDeploy Flask App to Railway\n\n\nRailway offers multiple ways to deploy your Flask app, depending on your setup and preference. Choose any of the following methods:\n\n\n\n\nOne-click deploy from a template\n.\n\n\nUsing the CLI\n.\n\n\nFrom a GitHub repository\n.\n\n\n\n\nOne-Click Deploy From a Template\n\n\n\n\nWe highly recommend that \nyou eject from the template after deployment\n to create a copy of the repo on your GitHub account.\n\n\nNote:\n You can also choose from a \nvariety of Flask app templates\n created by the community.\n\n\nDeploy From the CLI\n\n\n\n\nInstall the Railway CLI\n:\n\n\n\n\nInstall the CLI\n and \nauthenticate it\n using your Railway account.\n\n\n\n\n\n\nInitialize a Railway Project\n:\n\n\n\n\nRun the command below in your Flask app directory.\n\n\nrailway init\n\n\n\n\nFollow the prompts to name your project.\n\n\nAfter the project is created, click the provided link to view it in your browser.\n\n\n\n\n\n\nDeploy the Application\n:\n\n\n\n\nUse the command below to deploy your app:\n\n\nrailway up\n\n\n\n\nThis command will scan, compress and upload your app's files to Railway. Youâ€™ll see real-time deployment logs in your terminal.\n\n\n\n\n\n\nVerify the Deployment\n:\n\n\n\n\nOnce the deployment completes, go to \nView logs\n to check if the server is running successfully.\n\n\n\n\n\n\nSet Up a Public URL\n:\n\n\n\n\nNavigate to the \nNetworking\n section under the \nSettings\n tab of your new service.\n\n\nClick \nGenerate Domain\n to create a public URL for your app.\n\n\n\n\n\n\n\n\n\n\nDeploy From a GitHub Repo\n\n\nTo deploy a Flask app to Railway directly from GitHub, follow the steps below:\n\n\n\n\n\n\nCreate a New Project on Railway\n:\n\n\n\n\nGo to \nRailway\n to create a new project.\n\n\n\n\n\n\n\n\nDeploy from GitHub\n:\n\n\n\n\nSelect \nDeploy from GitHub repo\n and choose your repository.\n\n\n\n\nIf your Railway account isnâ€™t linked to GitHub yet, youâ€™ll be prompted to do so.\n\n\n\n\n\n\n\n\n\n\n\n\nDeploy the App Service\n:\n\n\n\n\nClick \nDeploy\n on the Railway project canvas to apply your changes.\n\n\n\n\n\n\n\n\nVerify the Deployment\n:\n\n\n\n\nOnce the deployment completes, go to \nView logs\n to check if the server is running successfully.\n\n\n\n\nNote:\n During the deployment process, Railway will automatically \ndetect that itâ€™s a Python app\n.\n\n\n\n\n\n\nSet Up a Public URL\n:\n\n\n\n\nNavigate to the \nNetworking\n section under the \nSettings\n tab of your new service.\n\n\nClick \nGenerate Domain\n to create a public URL for your app.\n\n\n\n\n\n\n\n\nUse a Dockerfile\n\n\n\n\nCreate a \nDockerfile\n in the app's root directory.\n\n\nAdd the content below to the \nDockerfile\n:\n\n\n# Use the Python 3 official image\n\n\n# https://hub.docker.com/_/python\n\n\nFROM\n python:3\n\n\n\n\n# Run in unbuffered mode\n\n\nENV\n PYTHONUNBUFFERED=1 \n\n\n\n\n# Create and change to the app directory.\n\n\nWORKDIR\n /app\n\n\n\n\n# Copy local code to the container image.\n\n\nCOPY\n . ./\n\n\n\n\n# Install project dependencies\n\n\nRUN\n pip install --no-cache-dir -r requirements.txt\n\n\n\n\n# Run the web service on container startup.\n\n\nCMD\n [\n\"gunicorn\"\n, \n\"main:app\"\n]\n\n\n\n\nEither deploy via the CLI or from GitHub.\n\n\n\n\nRailway automatically detects the \nDockerfile\n, \nand uses it to build and deploy the app.\n\n\nNote:\n Railway supports also \ndeployment from public and private Docker images\n.\n\n\nNext Steps\n\n\nExplore these resources to learn how you can maximize your experience with Railway:\n\n\n\n\nAdd a Database Service\n\n\nMonitor your app\n\n\nRunning a Cron Job\n\n\nPrev\n \nFastAPI\nNext\n \nBeego\nEdit this file on GitHub\nOn This Page\nCreate a Flask App\nRun the Flask App Locally\nPrepare the Flask App for Deployment\nDeploy Flask App to Railway\nOne-Click Deploy From a Template\nDeploy From the CLI\nDeploy From a GitHub Repo\nUse a Dockerfile\nNext Steps"
  },
  {
    "url": "https://docs.railway.app/guides/foundations",
    "title": "Foundations | Railway Docs",
    "content": "Foundations\nWelcome!  Let's get started building in Railway!\n\n\nTo start, you should be familiar with the core components and features of the platform. Therefore, the goal of this section is to guide you through the steps of laying a solid foundation on which to iterate.\n\n\nCore Components\n\n\nProjects\nA Project is like an application stack, or a system of related components.  Everything needed by the components in the system are encapsulated in a Project, including environments and variables.\nServices\nServices are components that make up the Project - frontend web servers, backend APIs, message queues, databases, etc.  Services can be configured with \nvariables\n, start and run commands, restart policies, \nvolume mounts\n, etc.\nVariables\nVariable management is an essential part of development operations.  Variables can be scoped to both Services and Environments in Railway.\nEnvironments\nEnvironments exist within a Project and are useful for maintaining separation between Production and Development environments.\nCLI\nThe CLI is handy for local development, used for things like running services locally using variables stored in Railway, deploying local code repositories, etc.\n\n\nThe next pages will go through how to create and manage your Projects, Services, Variables, and Environments.  They will also explain how to use Volumes to persist your data and how to install and use the CLI.\n\n\nIf you prefer a crash course, check out our \nQuickstart guide\n!\nPrev\n \nAdvanced Concepts\nNext\n \nProjects\nEdit this file on GitHub\nOn This Page\nCore Components"
  },
  {
    "url": "https://docs.railway.app/guides/gin",
    "title": "Deploy a Gin App | Railway Docs",
    "content": "Deploy a Gin App\nGin\n is a high-performance web framework for Go (Golang) that provides a martini-like API while being significantly fasterâ€”up to 40 timesâ€”due to its use of \nhttprouter\n. It's designed for developers seeking both speed and productivity.\n\n\nThis guide covers how to deploy a Gin app on Railway in four ways:\n\n\n\n\nOne-click deploy from a template\n.\n\n\nFrom a GitHub repository\n.\n\n\nUsing the CLI\n.\n\n\nUsing a Dockerfile\n.\n\n\n\n\nOne-Click Deploy From a Template\n\n\n\n\nWe highly recommend that \nyou eject from the template after deployment\n to create a copy of the repo on your GitHub account.\n\n\nNote:\n You can also choose from a \nvariety of Gin app templates\n created by the community.\n\n\nDeploy From a GitHub Repo\n\n\nTo deploy a Gin app on Railway directly from GitHub, follow the steps below:\n\n\n\n\nFork the basic \nGin GitHub repo\n.\n\n\n\n\nIf you already have a GitHub repo you want to deploy, you can skip this step.\n\n\n\n\n\n\nCreate a \nNew Project.\n\n\nClick \nDeploy from GitHub repo\n.\n\n\nSelect the \ngin\n or your own GitHub repo.\n\n\n\n\nRailway requires a valid GitHub account to be linked. If your Railway account isn't associated with one, you will be prompted to link it.\n\n\n\n\n\n\nClick \nDeploy Now\n.\n\n\n\n\nOnce the deployment is successful, a Railway \nservice\n will be created for you. By default, this service will not be publicly accessible.\n\n\nTo set up a publicly accessible URL for the service, navigate to the \nNetworking\n section in the \nSettings\n tab of your new service and click on \nGenerate Domain\n.\n\n\n\n\nDeploy From the CLI\n\n\n\n\nInstall\n and \nauthenticate with the CLI.\n\n\nClone the forked \ngin GitHub repo\n and \ncd\n into the directory.\n\n\n\n\nYou can skip this step if you already have an app directory or repo on your machine that you want to deploy.\n\n\n\n\n\n\nRun \nrailway init\n within the app directory to create a new project.\n\n\nRun \nrailway up\n to deploy.\n\n\n\n\nThe CLI will now scan, compress and upload our gin app files to Railway's backend for deployment.\n\n\n\n\n\n\n\n\nUse a Dockerfile\n\n\n\n\nClone the forked \ngin\n repo and \ncd\n into the directory.\n\n\n\n\nYou can skip this step if you already have an app directory or repo on your machine that you want to deploy.\n\n\n\n\n\n\nCreate a \nDockerfile\n in the \ngin\n or app's root directory.\n\n\nAdd the content below to the \nDockerfile\n:\n\n\n# Use the Go 1.23 alpine official image\n\n\n# https://hub.docker.com/_/golang\n\n\nFROM\n golang:1.23-alpine\n\n\n\n\n# Create and change to the app directory.\n\n\nWORKDIR\n /app\n\n\n\n\n# Copy go mod and sum files\n\n\nCOPY\n go.mod go.sum ./\n\n\n\n\n# Copy local code to the container image.\n\n\nCOPY\n . ./\n\n\n\n\n# Install project dependencies\n\n\nRUN\n go mod download\n\n\n\n\n# Build the app\n\n\nRUN\n go build -o app\n\n\n\n\n# Run the service on container startup.\n\n\nENTRYPOINT\n [\n\"./app\"\n]\n\n\n\n\nEither deploy via the CLI or from GitHub.\n\n\n\n\nRailway automatically detects the \nDockerfile\n, \nand uses it to build and deploy the app.\n\n\nNote:\n Railway supports also \ndeployment from public and private Docker images\n.\n\n\nNext Steps\n\n\nExplore these resources to learn how you can maximize your experience with Railway:\n\n\n\n\nAdd a Database Service\n\n\nMonitor your app\n\n\nRunning a Cron Job\n\n\nPrev\n \nBeego\nNext\n \nRails\nEdit this file on GitHub\nOn This Page\nOne-Click Deploy From a Template\nDeploy From a GitHub Repo\nDeploy From the CLI\nUse a Dockerfile\nNext Steps"
  },
  {
    "url": "https://docs.railway.app/guides/github-autodeploys",
    "title": "Controlling GitHub Autodeploys | Railway Docs",
    "content": "Controlling GitHub Autodeploys\nServices that are linked to a GitHub repo\n automatically deploy when new commits are detected in the connected branch.\n\n\nConfigure the GitHub Branch for Deployment Triggers\n\n\nTo update the branch that triggers automatic deployments, go to your Service Settings and choose the appropriate trigger branch.\n\n\n\n\nDisable Automatic Deployments\n\n\nTo disable automatic deployment, simply hit \nDisconnect\n in the Service Settings menu.\n\n\nNote: To manually trigger a deployment from the latest commit, use the Command Pallette: \nCMD + K\n -> \"Deploy Latest Commit\".  This will deploy the latest commit from the \nDefault\n branch in GitHub.\n\n\nCurrently, there is no way to force a deploy from a branch other than the Default without connecting it in your service settings.\n\n\nWait for CI\n\n\nPlease make sure you have\n \n\n\naccepted our updated GitHub permissions\n\nrequired for this feature to work.\n\n\nTo ensure Railway waits for your GitHub Actions to run successfully before triggering a new deployment, you should enable \nWait for CI\n.\n\n\nRequirements\n\n\n\n\n\n\nYou must have a GitHub workflow defined in your repository.\n\n\n\n\n\n\nThe GitHub workflow must contain a directive to run on push:\n\n\non:\n\n  push:\n\n    branches:\n\n      - main\n\n\n\n\n\n\nEnabling Wait for CI\n\n\nIf your workflow satisfies the requirements above, you will see the \nWait for CI\n flag in service settings.\n\n\n\n\nToggle this on to ensure Railway waits for your GitHub Actions to run successfully before triggering a new deployment.\n\n\nWhen enabled, deployments will be moved to a \nWAITING\n state while your workflows are running.\n\n\nIf any workflow fails, the deployments will be \nSKIPPED\n.\n\n\nWhen all workflows are successful, deployments will proceed as usual.\nPrev\n \nDeployment Actions\nNext\n \nOptimize Performance\nEdit this file on GitHub\nOn This Page\nConfigure the GitHub Branch for Deployment Triggers\nDisable Automatic Deployments\nWait for CI\nEnabling Wait for CI"
  },
  {
    "url": "https://docs.railway.app/guides/healthchecks",
    "title": "Configure Healthchecks | Railway Docs",
    "content": "Configure Healthchecks\nRailway provides controls for ensuring newly deployed services only receive traffic after they are healthy.\n\n\nConfigure The Healthcheck Path\n\n\nA Healthcheck can be used to guarantee zero-downtime deployments of your web services by ensuring the new version is live and able to handle requests.\n\n\nTo configure a healthcheck:\n\n\n\n\n\n\nEnsure your webserver has an endpoint (e.g. \n/health\n) that will return an HTTP status code of 200 when the application is live and ready.\n\n\n\n\n\n\nUnder your service settings, input your health endpoint.  Railway will wait for this endpoint to serve a \n200\n status code before switching traffic to your new endpoint\n\n\n\n\n\n\nNote:\n Railway does not monitor the healthcheck endpoint after the deployment has gone live.\n\n\nConfigure The Healthcheck Port\n\n\nRailway will inject a \nPORT\n environment variable that your application should \nlisten on\n.\n\n\nThis variable's value is also used when performing health checks on your deployments.\n\n\nIf your application doesn't listen on the \nPORT\n variable, possibly due to using \ntarget ports\n, you can manually set a \nPORT\n \nvariable\n to inform Railway of the port to use for health checks.\n\n\n\n\nNot listening on the \nPORT\n variable or omitting it when using target ports can result in your health check returning a \nservice unavailable\n error.\n\n\nHealthcheck Timeout\n\n\nThe default timeout on healthchecks is by default 300 seconds (5 minutes) - if your application fails to serve a \n200\n status code during this allotted time, the deploy will be marked as failed.\n\n\n\n\nTo increase the timeout, change the number of seconds on the service settings page, or with a \nRAILWAY_HEALTHCHECK_TIMEOUT_SEC\n service variable.\n\n\nServices with Attached Volumes\n\n\nTo prevent data corruption, we prevent multiple deployments from being active and mounted to the same service. This means that there will be a small amount of downtime when re-deploying a service that has a volume attached, even if there is a healthcheck endpoint configured.\n\n\nHealthcheck Hostname\n\n\nRailway uses the hostname \nhealthcheck.railway.app\n when performing healthchecks on your service. This is the domain from which the healthcheck requests will originate.\n\n\nFor applications that restrict incoming traffic based on the hostname, you'll need to add \nhealthcheck.railway.app\n to your list of allowed hosts. This ensures that your application will accept healthcheck requests from Railway.\n\n\nIf your application does not permit requests from that hostname, you may encounter errors during the healthcheck process, such as \"failed with service unavailable\" or \"failed with status 400\".\n\n\nContinuous Healthchecks\n\n\nThe healthcheck endpoint is currently \nnot used for continuous monitoring\n as it is only called at the start of the deployment, to ensure it is healthy prior to routing traffic to it.\n\n\nIf you are looking for a quick way to setup continuous monitoring of your service(s), check out the \nUptime Kuma template\n in our template marketplace.\nPrev\n \nOptimize Performance\nNext\n \nRestart Policy\nEdit this file on GitHub\nOn This Page\nConfigure The Healthcheck Path\nConfigure The Healthcheck Port\nHealthcheck Timeout\nServices with Attached Volumes\nHealthcheck Hostname\nContinuous Healthchecks"
  },
  {
    "url": "https://docs.railway.app/guides/join-priority-boarding",
    "title": "Join Priority Boarding! | Railway Docs",
    "content": "Join Priority Boarding!\nPriority Boarding is Railway's \nbeta program\n and is available to users who have connected their Railway account to Discord.\n\n\nConnect Railway to Discord\n\n\nVisit \nGeneral Settings\n, scroll down to Account Settings, and connect your account to the Railway Discord server.\n\n\n\n\nLet Percy Know\n\n\nOnce connected to Discord, you'll need to let Percy, the Railway Discord bot, know that you'd like to be a part of priority boarding.\n\n\nIn Discord, open up any channel, enter \n/beta\n, and follow the prompts.\n\n\nAlternatively, you can open the command palette using \nCMD + K\n or \nCtrl + K\n, then scroll down to \nUtilities\n, and select the join Priority Boarding button.\n\n\nYou should now have access to the \n#priority-boarding\n channel. You should also see that your Account Settings now display a new Priority Boarding status.\n\n\n\n\nKeep Us Posted\n\n\nFrom this point forward, you'll have Priority Boarding features automatically enabled for your account. We'll notify you of any new features via the \nChangelog\n.\n\n\nWe kindly request that you report any issues you encounter in the \nPriority Boarding Discord channel\n.\n\n\nThat's all there is to it! Thanks for helping improve Railway, and we'll see you in Priority Boarding.\nPrev\n \nCLI\nNext\n \nLanguages & Frameworks\nEdit this file on GitHub\nOn This Page\nConnect Railway to Discord\nLet Percy Know\nKeep Us Posted"
  },
  {
    "url": "https://docs.railway.app/guides/languages-frameworks",
    "title": "Languages & Frameworks | Railway Docs",
    "content": "Languages & Frameworks\nLearn how to deploy your apps quickly on Railway using your preferred languages and frameworks:\n\n\nJavaScript / TypeScript\n\n\n\n\nFastify\n\n\nExpress\n\n\nNext.js\n\n\nNest.js\n\n\nSails\n\n\nReact\n\n\nRemix\n\n\nVue\n\n\nNuxt\n\n\nAstro\n\n\nSvelteKit\n\n\nSolid\n\n\nAngular\n\n\n\n\nPython\n\n\n\n\nFastAPI\n\n\nFlask\n\n\nDjango\n\n\n\n\nPHP\n\n\n\n\nLaravel\n\n\nSymfony\n\n\n\n\nJava\n\n\n\n\nSpring Boot\n\n\n\n\nScala\n\n\n\n\nPlay Framework\n\n\n\n\nGo\n\n\n\n\nBeego\n\n\nGin\n\n\n\n\nRuby\n\n\n\n\nRails\n\n\n\n\nClojure\n\n\n\n\nLuminus\n\n\n\n\nElixir\n\n\n\n\nPhoenix\n\n\nPhoenix with Distillery\n\n\n\n\nRust\n\n\n\n\nAxum\n\n\nRocket\n\n\nPrev\n \nJoin Priority Boarding!\nNext\n \nExpress\nEdit this file on GitHub\nOn This Page\nJavaScript / TypeScript\nPython\nPHP\nJava\nScala\nGo\nRuby\nClojure\nElixir\nRust"
  },
  {
    "url": "https://docs.railway.app/guides/laravel",
    "title": "Deploy a Laravel App | Railway Docs",
    "content": "Deploy a Laravel App\nLaravel\n is a PHP framework designed for web artisans who value simplicity and elegance in their code. It stands out for its clean and expressive syntax, and offers built-in tools to handle many common tasks found in modern web applications, making development smoother and more enjoyable.\n\n\nThis guide covers how to deploy a Laravel app on Railway in three ways:\n\n\n\n\nOne-click deploy from a template\n.\n\n\nFrom a GitHub repository\n.\n\n\nUsing the CLI\n.\n\n\n\n\nOne-Click Deploy From a Template\n\n\n\n\nThis template sets up a basic Laravel application along with a Postgres database on Railway. You can also choose from a \nvariety of Laravel app templates\n created by the community.\n\n\nWe highly recommend that \nyou eject from the template after deployment\n to create a copy of the repo on your GitHub account.\n\n\nDeploy From a GitHub Repo\n\n\nTo deploy a Laravel app on GitHub to Railway, follow the steps below:\n\n\n\n\n\n\nCreate a \nNew Project.\n\n\n\n\n\n\nClick \nDeploy from GitHub repo\n.\n\n\n\n\n\n\nSelect your GitHub repo.\n\n\n\n\nRailway requires a valid GitHub account to be linked. If your Railway account isn't associated with one, you will be prompted to link it.\n\n\n\n\n\n\n\n\nClick \nAdd Variables\n.\n\n\n\n\nAdd all your app environment variables.\n\n\n\n\n\n\n\n\nClick \nDeploy\n.\n\n\n\n\n\n\nOnce the deployment is successful, a Railway \nservice\n will be created for you. By default, this service will not be publicly accessible.\n\n\nNote:\n Railway will automatically detect that it's a Laravel app during \ndeploy and run your app via php-fpm and nginx\n.\n\n\nTo set up a publicly accessible URL for the service, navigate to the \nNetworking\n section in the \nSettings\n tab of your new service and click on \nGenerate Domain\n.\n\n\n\n\nNote\n: \nJump to the \nSet Up Database, Migrations, Crons and Workers\n section\n to learn how to run your Laravel app along with a Postgres(or MySQL) database, cron jobs, and workers.\n\n\nDeploy From the CLI\n\n\nIf you have your Laravel app locally, you can follow these steps:\n\n\n\n\n\n\nInstall\n and \nauthenticate with the Railway CLI.\n\n\n\n\n\n\nRun \nrailway init\n within your Laravel app root directory to create a new project on Railway.\n\n\n\n\nFollow the steps in the prompt to give your project a name.\n\n\n\n\n\n\n\n\nRun \nrailway up\n to deploy.\n\n\n\n\n\n\nThe CLI will now scan, compress and upload our Laravel app files to Railway's backend for deployment.\n\n\n\n\n\n\nYour terminal will display real-time logs as your app is being deployed on Railway.\n\n\n\n\n\n\n\n\n\n\nOnce the deployment is successful, click on \nView logs\n on the recent deployment on the dashboard.\n\n\n\n\nYou'll see that the server is running. However you'll also see logs prompting you to add your env variables.\n\n\n\n\n\n\n\n\nClick on the \nVariables\n section of your service on the Railway dashboard.\n\n\n\n\n\n\nClick on \nRaw Editor\n and add all your app environment variables.\n\n\n\n\n\n\nClick on \nDeploy\n to redeploy your app.\n\n\n\n\n\n\nTo set up a publicly accessible URL for the service, navigate to the \nNetworking\n section in the \nSettings\n tab of your new service and click on \nGenerate Domain\n.\n\n\nNote:\n The next step shows how to run your Laravel app along with a database, migrations, cron jobs, and workers.\n\n\nSet Up Database, Migrations, Crons and Workers\n\n\nThis setup deploys your Laravel app on Railway, ensuring that your database, scheduled tasks (crons), and queue workers are all fully operational.\n\n\nThe deployment structure follows a \"majestic monolith\" architecture, where the entire Laravel app is managed as a single codebase but split into four separate services on Railway:\n\n\n\n\n\n\nApp Service\n: Handles HTTP requests and user interactions.\n\n\n\n\n\n\nCron Service\n: Manages scheduled tasks (e.g., sending emails or running reports).\n\n\n\n\n\n\nWorker Service\n: Processes background jobs from the queue.\n\n\n\n\n\n\nDatabase Service\n: Stores and retrieves your application's data.\n\n\n\n\n\n\n\n\nMy Majestic Monolith Laravel app\n\n\nPlease follow these steps to get started:\n\n\n\n\n\n\nCreate four bash scripts in the root directory of your Laravel app: \nbuild-app.sh\n, \nrun-worker.sh\n, and \nrun-cron.sh\n.\n\n\nThese scripts will contain the commands needed to deploy and run the app, worker, and cron services for your Laravel app on Railway.\n\n\n\n\n\n\nAdd the content below to the \nbuild-app.sh\n file:\n\n\nNote:\n You can add any additional commands to the script that you want to run each time your app service is built.\n\n\n#!/bin/bash\n\n\n# Make sure this file has executable permissions, run `chmod +x build-app.sh`\n\n\n\n\n# Exit the script if any command fails\n\n\nset\n -e\n\n\n\n# Build assets using NPM\n\n\nnpm\n run build\n\n\n\n# Clear cache\n\n\nphp artisan optimize:clear\n\n\n\n# Cache the various components of the Laravel application\n\n\nphp artisan config:cache\n\nphp artisan event:cache\n\nphp artisan route:cache\n\nphp artisan view:cache\n\n\n\n\n\n\nAdd the content below to the \nrun-worker.sh\n file:\n\n\n#!/bin/bash\n\n\n# Make sure this file has executable permissions, run `chmod +x run-worker.sh`\n\n\n\n\n# This command runs the queue worker. \n\n\n# An alternative is to use the php artisan queue:listen command\n\n\nphp artisan queue:work\n\n\n\n\n\n\nAdd the content below to the \nrun-cron.sh\n file:\n\n\n#!/bin/bash\n\n\n# Make sure this file has executable permissions, run `chmod +x run-cron.sh`\n\n\n\n\n# This block of code runs the Laravel scheduler every minute\n\n\nwhile\n \n[\n \ntrue\n \n]\n\n\n    \ndo\n\n\n        \necho\n \n\"Running the scheduler...\"\n\n\n        php artisan schedule:run --verbose --no-interaction \n&\n\n\n        \nsleep\n \n60\n\n\n    \ndone\n\n\n\n\n\n\n\n\n\n\nCreate a Postgres Database service on the \nProject Canvas.\n\n\n\n\nClick on \nDeploy\n.\n\n\n\n\n\n\n\n\nCreate a new service on the \nProject Canvas.\n\n\n\n\n\n\nName the service \nApp service\n, and click on \nSettings\n to configure it.\n\n\n\n\n\n\nConnect your GitHub repo to the  \nSource Repo\n in the \nSource\n section.\n\n\n\n\n\n\nAdd \nchmod +x ./build-app.sh && sh ./build-app.sh\n to the \nCustom Build Command\n in the \nBuild\n section.\n\n\n\n\n\n\nAdd \nphp artisan migrate\n to the \nPre-Deploy Command\n in the \nDeploy\n section.\n\n\n\n\n\n\nHead back to the top of the service and click on \nVariables\n.\n\n\n\n\n\n\nAdd all the necessary environment variables required for the Laravel app especially the ones listed below.\n\n\n\n\n\n\nAPP_KEY\n: Set the value to what you get from the \nphp artisan key:generate\n command.\n\n\n\n\n\n\nDB_CONNECTION\n: Set the value to \npgsql\n.\n\n\n\n\n\n\nQUEUE_CONNECTION\n: Set the value to \ndatabase\n.\n\n\n\n\n\n\nDB_URL\n: Set the value to \n${{Postgres.DATABASE_URL}}\n (this references the URL of your new Postgres database). Learn more about \nreferencing service variables\n.\n\n\n\n\n\n\n\n\n\n\nClick \nDeploy\n.\n\n\n\n\n\n\n\n\n\n\nCreate a new service on the \nProject Canvas\n.\n\n\n\n\n\n\nName the service \ncron service\n, and click on \nSettings\n.\n\n\n\n\n\n\nConnect your GitHub repo to the  \nSource Repo\n in the \nSource\n section.\n\n\n\n\n\n\nAdd \nchmod +x ./run-cron.sh && sh ./run-cron.sh\n to the \nCustom Start Command\n in the \nDeploy\n section.\n\n\n\n\n\n\nHead back to the top of the service and click on  \nVariables\n.\n\n\n\n\n\n\nAdd all the necessary environment variables especially those highlighted already in step 3.\n\n\n\n\n\n\nClick \nDeploy\n.\n\n\n\n\n\n\n\n\n\n\nCreate a new service again on the \nProject Canvas\n.\n\n\n\n\n\n\nName the service \nworker service\n, and click on \nSettings\n.\n\n\n\n\n\n\nConnect your GitHub repo to the  \nSource Repo\n in the \nSource\n section.\n\n\n\n\n\n\nAdd \nchmod +x ./run-worker.sh && sh ./run-worker.sh\n to the \nCustom Start Command\n in the \nDeploy\n section.\n\n\n\n\n\n\nHead back to the top of the service and click on \nVariables\n.\n\n\n\n\n\n\nAdd all the necessary environment variables especially those highlighted already in step 3.\n\n\n\n\n\n\nClick \nDeploy\n.\n\n\n\n\n\n\n\n\n\n\nAt this point, you should have all three services deployed and connected to the Postgres Database service:\n\n\n\n\n\n\nCron Service\n: This service should run the Laravel Scheduler to manage scheduled tasks.\n\n\n\n\n\n\n\n\n\n\nWorker Service\n: This service should be running and ready to process jobs from the queue.\n\n\n\n\n\n\nApp Service\n: This service should be running and is the only one that should have a public domain, allowing users to access your application.\n\n\n\n\n\n\n\n\nApp service\n\n\nNote:\n There is a \ncommunity template\n available that demonstrates this deployment approach. You can easily deploy this template and then connect it to your own GitHub repository for your application.\n\n\nLogging\n\n\nLaravel, by default, writes logs to a directory on disk. However, on Railwayâ€™s ephemeral filesystem, this setup wonâ€™t persist logs.\n\n\nTo ensure logs and errors appear in Railwayâ€™s console or with \nrailway logs\n, update the \nLOG_CHANNEL\n environment variable to \nerrorlog\n. You can set it via the Railway dashboard or CLI as shown:\n\n\nrailway variables --set \n\"LOG_CHANNEL=errorlog\"\n\n\nCan I Deploy with Laravel Sail?\n\n\nYou may be thinking about using \nLaravel Sail\n, which is the standard approach for deploying Laravel applications with Docker. At its core, Sail relies on a \ndocker-compose.yml\n file to manage the environment.\n\n\nHowever, it's important to note that Railway currently does not support Docker Compose.\n\n\nNext Steps\n\n\nExplore these resources to learn how you can maximize your experience with Railway:\n\n\n\n\nMonitoring\n\n\nDeployments\n\n\nPrev\n \nRocket\nNext\n \nSymfony\nEdit this file on GitHub\nOn This Page\nOne-Click Deploy From a Template\nDeploy From a GitHub Repo\nDeploy From the CLI\nSet Up Database, Migrations, Crons and Workers\nLogging\nCan I Deploy with Laravel Sail?\nNext Steps"
  },
  {
    "url": "https://docs.railway.app/guides/logs",
    "title": "Viewing Logs | Railway Docs",
    "content": "Viewing Logs\nAny build or deployment logs emitted to standard output or standard error (e.g. \nconsole.log(...)\n) are captured by Railway to be viewed or searched later.\n\n\nThere are three ways to view logs in Railway.\n\n\n\n\nBuild/Deploy Panel\n â†’ Click on a deployment in the dashboard\n\n\nLog Explorer\n â†’ Click on the Observability tab in the top navigation\n\n\nCLI\n â†’ Run the \nrailway logs\n command\n\n\n\n\nBuild / Deploy Panel\n\n\nLogs for a specific deployment can be viewed by clicking on the deployment in the service window, useful when debugging application failures.\n\n\n\n\nSimilarly, logs for a specific build can be viewed by clicking on the \nBuild Logs\n tab once you have a deployment open.\n\n\n\n\nLog Explorer\n\n\nLogs for the entire environment can be viewed together by clicking the \"Observability\" button in the top navigation. The Log Explorer is useful for debugging more general problems that may span multiple services.\n\n\nThe log explorer also has additional features like selecting a date range or toggling the visibility of specific columns.\n\n\n\n\nCommand Line\n\n\nDeployment logs can also be viewed from the command line to quickly check the current status of the latest deployment. Use \nrailway logs\n to view them.\n\n\n\n\nFiltering Logs\n\n\nRailway supports a custom filter syntax that can be used to query logs.\n\n\nFilter syntax is available for all log types, but some log types have specific attributes.\n\n\nDeployment Logs\n\n\n\n\n\n\n<search term>\n â†’ Filter for a partial substring match\n\n\n\n\n\n\n\"<search term>\"\n â†’ Filter for an exact log message\n\n\n\n\n\n\nreplica:<replica_id>\n â†’ Filter by a specific replica's UUID\n\n\n\n\n\n\n@attribute:value\n â†’ Filter by custom attribute (see structured logs below)\n\n\n\n\n\n\nExamples:\n\n\nFind logs that contain the word \"request\".\n\n\nrequest\n\n\nFind logs that exactly match the message \"request handled\".\n\n\n\"request handled\"\n\n\nFind logs with an error level.\n\n\n@level:error\n\n\nFind logs with a warning level.\n\n\n@level:warn\n\n\nFind logs with an error level and specific text.\n\n\n@level:error AND \"failed to send batch\"\n\n\nFind logs with a specific custom attribute.\n\n\n@customAttribute:value\n\n\nFind logs with a specific array attribute.\n\n\n@arrayAttribute[i]:value\n\n\nEnvironment Logs\n\n\nEnvironment logs allow you to query for logs from the environment they were emitted in.\n\n\nThis means that you can search for logs emitted by all services in an environment at the same time, all in one central location.\n\n\nIn addition to the filters available for deployment logs, an additional filter is available for environment logs:\n\n\n\n\n@service:<service_id>\n â†’ Filter by a specific service's UUID\n\n\n\n\nExamples:\n\n\nFilter out logs from the Postgres database service.\n\n\n-@service:<postgres_service_id>\n\n\nFilter logs from the Postgres database service and the Redis cache service.\n\n\n-@service:<postgres_service_id> AND -@service:<redis_service_id>\n\n\nShow only logs from the Postgres database and Redis cache services.\n\n\n@service:<postgres_service_id> OR @service:<redis_service_id>\n\n\nHTTP Logs\n\n\nHTTP logs use the same filter syntax, but have a specific set of attributes for HTTP-specific data.\n\n\nSome commonly used filters for HTTP logs are:\n\n\n\n\n\n\n@requestId:<request_id>\n â†’ Filter by request ID\n\n\n\n\n\n\n@timestamp:<timestamp>\n â†’ Filter by timestamp (Formatted in RFC3339)\n\n\n\n\n\n\n@method:<method>\n â†’ Filter by method\n\n\n\n\n\n\n@path:<path>\n â†’ Filter by path\n\n\n\n\n\n\n@host:<host>\n â†’ Filter by host\n\n\n\n\n\n\n@httpStatus:<status_code>\n â†’ Filter by HTTP status code\n\n\n\n\n\n\n@responseDetails:<details>\n â†’ Filter by response details (Only populated when the application fails to respond)\n\n\n\n\n\n\n@clientUa:<user_agent>\n â†’ Filter by a specific client's user agent\n\n\n\n\n\n\n@srcIp:<ip>\n â†’ Filter by source IP (The client's IP address that made the request)\n\n\n\n\n\n\n@edgeRegion:<region>\n â†’ Filter by edge region (The region of the edge node that handled the request)\n\n\n\n\n\n\nExamples:\n\n\nFind logs for a specific path.\n\n\n@path:/api/v1/users\n\n\nFind logs for a specific path that returned a 500 error.\n\n\n@path:/api/v1/users AND @httpStatus:500\n\n\nFind logs for a specific path that returned a 500 or 501 error.\n\n\n@path:/api/v1/users AND (@httpStatus:500 OR @httpStatus:501)\n\n\nFind all non-200 responses.\n\n\n-@httpStatus:200\n\n\nFind all requests that originated from or around Europe.\n\n\n@edgeRegion:europe-west4-drams3a\n\n\nFind all requests that originated from a specific IP address.\n\n\n@srcIp:66.33.22.11\n\n\nView In Context\n\n\nOften, when searching for a log, it is useful to see the surrounding logs. To\ndo this, either click the \"Timestamp\" column, or expand any log and click\nthe \"View in Context\" button.\n\n\n\n\nStructured Logs\n\n\nStructured logs are logs emitted in a structured JSON format, useful if you want\nto attach custom metadata to logs or preserve multi-line logs like stack traces.\n\n\nconsole\n.\nlog\n(\nJSON\n.\nstringify\n(\n{\n\n\n  message\n:\n \n\"A minimal structured log\"\n,\n \n// (required) The content of the log\n\n\n  level\n:\n \n\"info\"\n,\n \n// Severity of the log (debug, info, warn, error)\n\n\n  customAttribute\n:\n \n\"value\"\n,\n \n// Custom attributes (query via @name:value)\n\n\n}\n)\n)\n;\n\n\nStructured logs are best generated with a library for your language. For example, the default \nWinston\n. JSON format emits logs in the correct structure by default.\n\n\nLogs with a \nlevel\n field will be coloured accordingly in the log explorer.\n\n\nLogs emitted to \nstderr\n will be converted to \nlevel.error\n and coloured red.\n\n\nExamples\n\n\nHere are a few examples of structured logs.\n\n\nNote:\n The entire JSON log must be emitted on a single line to be parsed correctly.\n\n\n{\n\"level\"\n:\n\"info\"\n,\n\"message\"\n:\n\"A minimal structured log\"\n}\n\n\n{\n\"level\"\n:\n\"error\"\n,\n\"message\"\n:\n\"Something bad happened\"\n}\n\n\n{\n\"level\"\n:\n\"info\"\n,\n\"message\"\n:\n\"New purchase!\"\n,\n\"productId\"\n:\n123\n,\n\"userId\"\n:\n456\n}\n\n\n{\n\"level\"\n:\n\"info\"\n,\n\"message\"\n:\n\"User roles updated\"\n,\n\"roles\"\n:\n[\n\"editor\"\n,\n\"viewer\"\n]\n,\n\"userId\"\n:\n123\n}\n\n\nNormalization Strategy\n\n\nIn order to ensure a consistent query format across Railway services, incoming logs are normalized to the above format automatically.\n\n\n\n\n\n\nNon-structured logs are converted to \n{\"message\":\"...\",\"level\":\"...\"}\n\n\n\n\n\n\nlog.msg\n converted to \nlog.message\n\n\n\n\n\n\nlog.level\n converted to \nlog.severity\n\n\n\n\n\n\nLogs from \nstderr\n are converted to \nlevel.error\n\n\n\n\n\n\nLogs from \nstdout\n are converted to \nlevel.info\n\n\n\n\n\n\nLevels are lowercased and matched to the closest of \ndebug\n, \ninfo\n, \nwarn\n, \nerror\n\n\n\n\nPrev\n \nMonitoring\nNext\n \nObservability\nEdit this file on GitHub\nOn This Page\nBuild / Deploy Panel\nLog Explorer\nCommand Line\nFiltering Logs\nDeployment Logs\nEnvironment Logs\nHTTP Logs\nView In Context\nStructured Logs\nExamples\nNormalization Strategy"
  },
  {
    "url": "https://docs.railway.app/guides/luminus",
    "title": "Deploy a Clojure Luminus App | Railway Docs",
    "content": "Deploy a Clojure Luminus App\nLuminus\n is a Clojure micro-framework based on a set of lightweight libraries. It aims to provide a robust, scalable, and easy to use platform. With Luminus you can focus on developing your app the way you want without any distractions.\n\n\nThis guide covers how to deploy a Luminus app to Railway in four ways:\n\n\n\n\nOne-click deploy from a template\n.\n\n\nFrom a GitHub repository\n.\n\n\nUsing the CLI\n.\n\n\nUsing a Dockerfile\n.\n\n\n\n\nNow, let's create a Luminus app!\n\n\nCreate a Luminus App\n\n\nNote:\n If you already have a Luminus app locally or on GitHub, you can skip this step and go straight to the \nDeploy Luminus App to Railway\n.\n\n\nTo create a new Luminus app, ensure that you have \nJDK\n and \nLeiningen\n installed on your machine.\n\n\nRun the following command in your terminal to create a new Luminus app with Postgres and a production ready server:\n\n\nlein new luminus helloworld +postgres +immutant\n\n\nA new Luminus app will be provisioned for you in the \nhelloworld\n directory with support for PostgreSQL as the database and configures \nImmutant\n as the web server, which is production-ready and optimized for Clojure applications.\n\n\nNote:\n If you use MySQL or another database, you can pass it as an option when trying to create a new app.\n\n\nRun the Luminus App Locally\n\n\nOpen \ndev-config.edn\n and add your Postgres database URL like so:\n\n\n:database-url\n \n\"postgresql://username:password@127.0.0.1:5432/helloworld_dev\"\n\n\n\n\nusername:password\n is your database user and password.\n\n\nhelloworld_dev\n is the database you have created locally.\n\n\n\n\nNext, run \nlein run migrate\n to run the database migrations.\n\n\nFinally, run \nlein run\n to launch your app!\n\n\nOpen your browser and go to \nhttp://localhost:3000\n to see the app.\n\n\nPrepare Clojure Luminus App for Deployment\n\n\n\n\nWe need to add the \nceshire\n library to our dependencies. \ncheshire\n is a popular JSON encoding/decoding library in Clojure.\n\n\n\n\nOpen your \nproject.clj\n file and ensure you have the following under \n:dependencies\n:\n\n\n...\n\n[\ncheshire \n\"5.10.0\"\n]\n\n\nRun the command below in your terminal to ensure it is installed:\n\n\nlein deps\n\n\n\n\nCreate a \nnixpacks.toml\n file in the root directory of the app.\n\n\n\n\nThe \nnixpacks.toml file\n is a configuration file used by Nixpacks, a build system developed and used by Railway, to set up and deploy applications.\n\n\nIn this file, you can specify the instructions for various build and deployment phases, along with environment variables and package dependencies.\n\n\nAdd the following content to the file:\n\n\n# nixpacks.toml\n\n\n\n\n[\nstart\n]\n\n\ncmd\n \n=\n \n\"java -jar $(find ./target -name '*.jar' ! -name '*SNAPSHOT*') migrate && java -jar $(find ./target -name '*.jar' ! -name '*SNAPSHOT*')\"\n\n\nHere, we are specifically instructing Nixpacks to use the following command to start the app.\n\n\nThe command searches for all \n.jar\n files in the \ntarget\n directory (where the standalone JAR file is located after the build), excludes any file with \"SNAPSHOT\" in its name, and passes the selected file to \njava -jar\n to run.\n\n\nIt starts by running the JAR file with the \nmigrate\n option to apply database migrations. Once migrations are complete, it reruns the JAR file to launch the application.\n\n\nDeploy the Luminus App to Railway\n\n\nRailway offers multiple ways to deploy your Clojure app, depending on your setup and preference.\n\n\nOne-Click Deploy From a Template\n\n\nIf youâ€™re looking for the fastest way to get started, the one-click deploy option is ideal.\n\n\nClick the button below to begin:\n\n\n\n\nWe highly recommend that \nyou eject from the template after deployment\n to create a copy of the repo on your GitHub account.\n\n\nNote:\n You can also choose from a \nvariety of Clojure app templates\n created by the community.\n\n\nDeploy From the CLI\n\n\n\n\nInstall the Railway CLI\n:\n\n\n\nInstall the CLI\n and \nauthenticate it\n using your Railway account.\n\n\n\n\n\n\nInitialize a Railway Project\n:\n\n\n\nRun the command below in your Luminus app directory.\n\nrailway init\n\n\n\n\nFollow the prompts to name your project.\n\n\nAfter the project is created, click the provided link to view it in your browser.\n\n\n\n\n\n\nAdd a Postgres Database Service\n:\n\n\n\nRun \nrailway add -d postgres\n.\n\n\nHit \nEnter\n to add it to your project.\n\n\nA database service will be added to your Railway project.\n\n\n\n\n\n\nAdd a Service and Environment Variable\n:\n\n\n\nRun \nrailway add\n.\n\n\nSelect \nEmpty Service\n from the list of options.\n\n\nIn the \nEnter a service name\n prompt, enter \napp-service\n.\n\n\nIn the \nEnter a variable\n prompt, enter \nDATABASE_URL=${{Postgres.DATABASE_URL}}\n.\n\n\n\nThe value, \n${{Postgres.DATABASE_URL}}\n, references the URL of your new Postgres database. Learn more about \nreferencing service variables\n.\n\n\n\n\n\n\n\n\nNote:\n Explore the \nRailway CLI reference\n for a variety of options.\n\n\nDeploy the Application\n:\n\n\n\nRun \nrailway up\n to deploy your app.\n\n\n\nThis command will scan, compress and upload your app's files to Railway. Youâ€™ll see real-time deployment logs in your terminal.\n\n\n\n\n\n\nOnce the deployment is complete, we can proceed to generate a domain for the app service.\n\n\n\n\n\n\nSet Up a Public URL\n:\n\n\n\nRun \nrailway domain\n to generate a public URL for your app.\n\n\nVisit the new URL to see your app live in action!\n\n\n\n\n\n\n\n\n\n\nDeploy From a GitHub Repo\n\n\nTo deploy a Clojure Luminus app to Railway directly from GitHub, follow the steps below:\n\n\n\n\n\n\nCreate a New Project on Railway\n:\n\n\n\n\nGo to \nRailway\n to create a new project.\n\n\n\n\n\n\n\n\nDeploy from GitHub\n:\n\n\n\n\nSelect \nDeploy from GitHub repo\n and choose your repository.\n\n\n\nIf your Railway account isnâ€™t linked to GitHub yet, youâ€™ll be prompted to do so.\n\n\n\n\n\n\n\n\n\n\n\n\nAdd Environment Variables and Provision a Database Service\n:\n\n\n\n\nClick \nAdd Variables\n, but hold off on adding anything just yet. First, proceed with the next step.\n\n\nRight-click on the Railway project canvas or click the \nCreate\n button, then select \nDatabase\n and choose \nAdd PostgreSQL\n.\n\n\n\nThis will create and deploy a new PostgreSQL database for your project.\n\n\n\n\n\n\nOnce the database is deployed, you can return to adding the necessary environment variables:\n\n\n\nDATABASE_URL\n: Set the value to \n${{Postgres.DATABASE_URL}}\n (this references the URL of your new Postgres database). Learn more about \nreferencing service variables\n.\n\n\n\n\n\n\n\n\n\n\n\n\nDeploy the App Service\n:\n\n\n\n\nClick \nDeploy\n on the Railway project canvas to apply your changes.\n\n\n\n\n\n\n\n\nVerify the Deployment\n:\n\n\n\n\nOnce the deployment completes, go to \nView logs\n to check if the server is running successfully.\n\n\n\n\nNote:\n During the deployment process, Railway will automatically \ndetect that itâ€™s a Clojure app\n.\n\n\n\n\n\n\nSet Up a Public URL\n:\n\n\n\n\nNavigate to the \nNetworking\n section under the \nSettings\n tab of your new service.\n\n\nClick \nGenerate Domain\n to create a public URL for your app.\n\n\n\n\n\n\n\n\nUse a Dockerfile\n\n\n\n\nCreate a \nDockerfile\n in the Luminus app's root directory.\n\n\nAdd the content below to the \nDockerfile\n:\n\n# Use the Clojure official image\n\n\n# https://hub.docker.com/_/clojure\n\n\nFROM clojure:temurin-23-lein-bookworm\n\n\n# Create and change to the app directory.\n\n\nWORKDIR /app\n\n\n# Copy local code to the container image.\n\n\nCOPY \n.\n ./\n\n\n\n# Build the app.\n\n\nRUN lein uberjar\n\n\n# Run the app by dynamically finding the standalone JAR file in the target/uberjar directory\n\n\nCMD \n[\n\"sh\"\n, \n\"-c\"\n, \n\"java -jar \n$(\nfind\n target/uberjar -name \n'*.jar'\n \n!\n -name \n'*SNAPSHOT*'\n)\n\"\n]\n\n\n\n\nEither deploy via the CLI or from GitHub.\n\n\n\n\nRailway automatically detects the \nDockerfile\n, \nand uses it to build and deploy the app.\n\n\nNote:\n Railway supports also \ndeployment from public and private Docker images\n.\n\n\nThis guide covers the main deployment options on Railway. Choose the approach that suits your setup, and start deploying your Clojure apps seamlessly!\n\n\nNext Steps\n\n\nExplore these resources to learn how you can maximize your experience with Railway:\n\n\n\n\nAdd a Database Service\n\n\nMonitor your app\n\n\nPrev\n \nSymfony\nNext\n \nPlay\nEdit this file on GitHub\nOn This Page\nCreate a Luminus App\nRun the Luminus App Locally\nPrepare Clojure Luminus App for Deployment\nDeploy the Luminus App to Railway\nOne-Click Deploy From a Template\nDeploy From the CLI\nDeploy From a GitHub Repo\nUse a Dockerfile\nNext Steps"
  },
  {
    "url": "https://docs.railway.app/guides/manage-deployments",
    "title": "Manage Deployments with the Public API | Railway Docs",
    "content": "Manage Deployments with the Public API\nHere are some examples to help you get started managing your deployments using the Public API.\n\n\nFetch Latest Active Deployment\n\n\nThe query below will fetch the latest active deployment for a service for a specific environment.\n\n\nquery\n \ndeployments\n \n{\n\n\n  \ndeployments\n(\n\n\n    \nfirst\n:\n \n1\n\n\n    \ninput\n:\n \n{\n\n\n      \nprojectId\n:\n \n\"\n8df3b1d6-2317-4400-b267-56c4a42eed06\n\"\n\n\n      \nenvironmentId\n:\n \n\"\n9fb4baf0-809a-40ec-af32-751f50890802\n\"\n\n\n      \nserviceId\n:\n \n\"4bd252dc-c4ac-4c2e-a52f-051804292035\"\n\n\n    \n}\n\n\n  \n)\n \n{\n\n\n    \nedges\n \n{\n\n\n      \nnode\n \n{\n\n\n        \nid\n\n\n        \nstaticUrl\n\n\n      \n}\n\n\n    \n}\n\n\n  \n}\n\n\n}\n\n\nRestarting a Deployment\n\n\nThe query below will restart the deployment with the specified \nid\n.\n\n\nmutation\n \ndeploymentRestart\n \n{\n\n\n  \ndeploymentRestart\n(\nid\n:\n \n\"9d5b1306-e22e-4357-9b3f-cc3b97ed8240\"\n)\n\n\n}\nPrev\n \nManage Services\nNext\n \nManage Variables\nEdit this file on GitHub\nOn This Page\nFetch Latest Active Deployment\nRestarting a Deployment"
  },
  {
    "url": "https://docs.railway.app/guides/manage-projects",
    "title": "Manage Projects with the Public API | Railway Docs",
    "content": "Manage Projects with the Public API\nHere are some examples to help you get started managing your projects using the Public API.\n\n\nFetch All Your Projects\n\n\nThe query below will fetch all your personal projects along with all the services, plugins and environment for them.\n\n\nquery\n \nme\n \n{\n\n\n  \nme\n \n{\n\n\n    \nprojects\n \n{\n\n\n      \nedges\n \n{\n\n\n        \nnode\n \n{\n\n\n          \nid\n\n\n          \nname\n\n\n          \nservices\n \n{\n\n\n            \nedges\n \n{\n\n\n              \nnode\n \n{\n\n\n                \nid\n\n\n                \nname\n\n\n              \n}\n\n\n            \n}\n\n\n          \n}\n\n\n          \nplugins\n \n{\n\n\n            \nedges\n \n{\n\n\n              \nnode\n \n{\n\n\n                \nid\n\n\n                \nname\n\n\n              \n}\n\n\n            \n}\n\n\n          \n}\n\n\n          \nenvironments\n \n{\n\n\n            \nedges\n \n{\n\n\n              \nnode\n \n{\n\n\n                \nid\n\n\n                \nname\n\n\n              \n}\n\n\n            \n}\n\n\n          \n}\n\n\n        \n}\n\n\n      \n}\n\n\n    \n}\n\n\n  \n}\n\n\n}\n\n\nDelete a Project\n\n\nThis is a destructive action\n\n\nThe mutation below will delete the project with the specified \nid\n.\n\n\nmutation\n \nprojectDelete\n \n{\n\n\n  \nprojectDelete\n(\nid\n:\n \n\"5e594338-0faa-415f-b2a7-2b5f2d4ec11a\"\n)\n\n\n}\nPrev\n \nPublic API\nNext\n \nManage Services\nEdit this file on GitHub\nOn This Page\nFetch All Your Projects\nDelete a Project"
  },
  {
    "url": "https://docs.railway.app/guides/manage-services",
    "title": "Manage Services with the Public API | Railway Docs",
    "content": "Manage Services with the Public API\nHere are some examples to help you get started managing your services using the Public API.\n\n\nCreate a New Service With a GitHub Repo\n\n\nThe mutation below will create a new service with the specified GitHub repo attached. The response will contain the newly created service.\n\n\nYou can also use \nimage\n inside the \nsource\n to attach a Docker image to the service.\n\n\nmutation\n \nserviceCreate\n \n{\n\n\n  \nserviceCreate\n(\n\n\n    \ninput\n:\n \n{\n\n\n      \nprojectId\n:\n \n\"\n8df3b1d6-2317-4400-b267-56c4a42eed06\n\"\n\n\n      \nsource\n:\n \n{\n \nrepo\n:\n \n\"railwayapp-templates/django\"\n \n}\n\n\n    \n}\n\n\n  \n)\n \n{\n\n\n    \nid\n\n\n  \n}\n\n\n}\nPrev\n \nManage Projects\nNext\n \nManage Deployments\nEdit this file on GitHub\nOn This Page\nCreate a New Service With a GitHub Repo"
  },
  {
    "url": "https://docs.railway.app/guides/manage-variables",
    "title": "Manage Variables with the Public API | Railway Docs",
    "content": "Manage Variables with the Public API\nHere are some examples to help you get started managing your variables using the Public API.\n\n\nFetch Variables For a Service\n\n\nThe query below will fetch all the variables for a service for a specific environment. The response will contain all the variables in a key/value object.\n\n\nYou can omit the \nserviceId\n from this query to fetch the shared variables for the environment.\n\n\nquery\n \nvariables\n \n{\n\n\n  \nvariables\n(\n\n\n    \nprojectId\n:\n \n\"\n8df3b1d6-2317-4400-b267-56c4a42eed06\n\"\n\n\n    \nenvironmentId\n:\n \n\"\n9fb4baf0-809a-40ec-af32-751f50890802\n\"\n\n\n    \nserviceId\n:\n \n\"4bd252dc-c4ac-4c2e-a52f-051804292035\"\n\n\n  \n)\n\n\n}\n\n\nUpsert Variable For a Service\n\n\nThe mutation below will upsert a new variable for the specified service within the specified environment. You can use this to both create and update variables.\n\n\nYou can omit the \nserviceId\n from this mutation to create a shared variable.\n\n\nmutation\n \nvariableUpsert\n \n{\n\n\n  \nvariableUpsert\n(\n\n\n    \ninput\n:\n \n{\n\n\n      \nprojectId\n:\n \n\"\n8df3b1d6-2317-4400-b267-56c4a42eed06\n\"\n\n\n      \nenvironmentId\n:\n \n\"\n9fb4baf0-809a-40ec-af32-751f50890802\n\"\n\n\n      \nserviceId\n:\n \n\"\n4bd252dc-c4ac-4c2e-a52f-051804292035\n\"\n\n\n      \nname\n:\n \n\"\nNEW_VARIABLE\n\"\n\n\n      \nvalue\n:\n \n\"SECRET_VALUE\"\n\n\n    \n}\n\n\n  \n)\n\n\n}\nPrev\n \nManage Deployments\nNext\n \nConfig as Code\nEdit this file on GitHub\nOn This Page\nFetch Variables For a Service\nUpsert Variable For a Service"
  },
  {
    "url": "https://docs.railway.app/guides/metrics",
    "title": "Viewing Metrics | Railway Docs",
    "content": "Viewing Metrics\nRailway provides resource usage information on deployments within a service which can be used to diagnose issues with a project's performance.\n\n\nAccessing Service Metrics\n\n\nAccess a service's metrics by clicking on a service in the project canvas, and going to the \"Metrics\" tab.\n\n\n\n\nThe following metrics are provided -\n\n\n\n\nCPU\n\n\nMemory\n\n\nDisk Usage\n\n\nNetwork\n\n\n\n\nUnderstanding the Metrics Graphs\n\n\nGraphs include dotted lines to indicate when new deployments began. Only the past 7 days of data is available for each project.\n\n\n\n\nProjects maintain a continuous time-series for all deployments within a service, not just the latest one. Deployments appear on the graph so users can see which commit may have caused a spike in resources.\n\n\nFor services with multiple replicas, the metrics from all replicas are summed up and displayed in the metrics tab, for example, if you have 2 replicas, each using 100 MB of memory, the memory usage displayed in the metrics tab will be 200 MB.\nPrev\n \nObservability\nNext\n \nWebhooks\nEdit this file on GitHub\nOn This Page\nAccessing Service Metrics\nUnderstanding the Metrics Graphs"
  },
  {
    "url": "https://docs.railway.app/guides/mongodb",
    "title": "MongoDB | Railway Docs",
    "content": "MongoDB\nThe Railway MongoDB database template allows you to provision and connect to a MongoDB database with zero configuration.\n\n\nDeploy\n\n\nAdd a MongoDB database to your project via the \nctrl / cmd + k\n menu or by clicking the \n+ New\n button on the Project Canvas.\n\n\n\n\nYou can also deploy it via the \ntemplate\n from the template marketplace.\n\n\nDeployed Service\n\n\nUpon deployment, you will have a MongoDB service running in your project, deployed from the official \nmongo\n Docker image.\n\n\nCustom Start Command\n\n\nThe MongoDB database service starts with the following \nStart Command\n to enable communication over \nPrivate Network\n: \nmongod --ipv6 --bind_ip ::,0.0.0.0  --setParameter diagnosticDataCollectionEnabled=false\n\n\nConnect\n\n\nConnect to MongoDB from another service in your project by \nreferencing the environment variables\n made available in the Mongo service:\n\n\n\n\nMONGOHOST\n\n\nMONGOPORT\n\n\nMONGOUSER\n\n\nMONGOPASSWORD\n\n\nMONGO_URL\n\n\n\n\nConnecting Externally\n\n\nIt is possible to connect to MongoDB externally (from outside of the \nproject\n in which it is deployed), by using the \nTCP Proxy\n which is enabled by default.\n\n\nKeep in mind that you will be billed for \nNetwork Egress\n when using the TCP Proxy.\n\n\nModify the Deployment\n\n\nSince the deployed container is pulled from the official \nMongoDB\n image in Docker Hub, you can modify the deployment based on the \ninstructions in Docker Hub\n.\n\n\nBackup and Monitoring\n\n\nEspecially for production environments, performing regular backups and monitoring the health of your database is essential. Consider adding:\n\n\n\n\n\n\nBackups\n: Automate regular backups to ensure data recovery in case of failure. We suggest checking out our native \nBackups\n feature.\n\n\n\n\n\n\nObservability\n: Implement monitoring for insights into performance and health of your database.  Check out the tutorial which covers \nsetting up observability on a Mongo replica set\n.\n\n\n\n\n\n\nAdditional Resources\n\n\nWhile these templates are available for your convenience, they are considered unmanaged, meaning you have total control over their configuration and maintenance.\n\n\nWe \nstrongly encourage you\n to refer to the source documentation to gain deeper understanding of their functionality and how to use them effectively.  Here are some links to help you get started:\n\n\n\n\nMongo Documentation\n\n\nReplication in Mongo\n\n\nPrev\n \nRedis\nNext\n \nDatabase View\nEdit this file on GitHub\nOn This Page\nDeploy\nDeployed Service\nCustom Start Command\nConnect\nModify the Deployment\nBackup and Monitoring\nAdditional Resources"
  },
  {
    "url": "https://docs.railway.app/guides/monitoring",
    "title": "Monitoring | Railway Docs",
    "content": "Monitoring\nLet's learn about monitoring your services!\n\n\nAt this point, you should be feeling confident in your understanding of the foundational concepts and operations in Railway.\n\n\nNow is a great time to learn how to dig into your service's logs and metrics, so you can debug issues or track performance between code deploys.  You'll also learn how to enable notifications when your \ndeployments change state\n.\n\n\nMain Concepts\n\n\nLogs and Metrics\nLogs are the lines sent to \nstdout\n or \nstderr\n from your application code.  Metrics represent measured system level performance, like CPU and RAM.  Railway surfaces both logs and metrics for your services.\nNotifications\nAn essential part of monitoring is through proactive notifications.  Configure a webhook to be notified when any of your deployed services change state.\n\n\nThe next few pages cover the topics above and how to interact with them inside the platform.\nPrev\n \nDatabase View\nNext\n \nLogs\nEdit this file on GitHub\nOn This Page\nMain Concepts"
  },
  {
    "url": "https://docs.railway.app/guides/monorepo",
    "title": "Deploying a Monorepo | Railway Docs",
    "content": "Deploying a Monorepo\nRailway provides a few features to help improve support for deploying monorepos\nof various types:\n\n\n\n\nIsolated Monorepo\n â†’ A repository that contains components that are completely isolated to the\ndirectory they are contained in (eg. JS frontend and Python backend)\n\n\nShared Monorepo\n â†’ A repository that contains components that share code or configuration from the\nroot directory (eg. Yarn workspace or Lerna project)\n\n\n\n\nFor a full step by step walk through on deploying an isolated Monorepo see our \ntutorial\n on the subject.\n\n\nDeploying an Isolated Monorepo\n\n\nThe simplest form of a monorepo is a repository that contains two completely\nisolated projects that do not share any code or configuration.\n\n\nâ”œâ”€â”€ frontend/\n\nâ”‚   â”œâ”€â”€ index.js\n\nâ”‚   â””â”€â”€ \n..\n.\n\nâ””â”€â”€ backend/\n\n    â”œâ”€â”€ server.py\n\n    â””â”€â”€ \n..\n.\n\n\nTo deploy this type of monorepo on Railway, define a root directory for the service.\n\n\n\n\nSelect the service within the project canvas to open up the service view.\n\n\nClick on the Settings tab.\n\n\nSet the root directory option. Setting this means that Railway will only pull down files from that directory when creating new deployments.\n\n\n\n\n\n\nNote:\n The \nRailway Config File\n does not follow the \nRoot Directory\n path. You have to specify the absolute path for the \nrailway.json\n or \nrailway.toml\n file.\n\n\nDeploying a Shared Monorepo\n\n\nPopular in the JavaScript ecosystem, shared monorepos contain multiple components that all share a common root directory.\n\n\nBy default, all components are built with a single command from the root directory (e.g. \nnpm run build\n). However, if you are using Nixpacks, then you can override the build command in the service settings.\n\n\nâ”œâ”€â”€ package.json\n\nâ””â”€â”€ packages\n\n    â”œâ”€â”€ backend\n\n    â”‚   â””â”€â”€ index.js\n\n    â”œâ”€â”€ common\n\n    â”‚   â””â”€â”€ index.js\n\n    â””â”€â”€ frontend\n\n        â””â”€â”€ index.jsx\n\n\nTo deploy this type of monorepo in Railway, define a separate custom start\ncommand in Service Settings for each project that references the monorepo\ncodebase.\n\n\n\n\nSelect the service within the project canvas to open the service view.\n\n\nClick on the Settings tab.\n\n\nSet the start command, e.g. \nnpm run start:backend\n and \nnpm run start:frontend\n\n\n\n\n\n\nWatch paths\n\n\nTo prevent code changes in one service from triggering a rebuild of other services in your monorepo, you should configure watch paths.\n\n\nWatch paths are \ngitignore-style\n patterns that can be used to trigger a new deployment based on what file paths have changed.\n\n\n\n\nA monorepo might want to only trigger builds if files are changed in the \n/packages/backend\n directory, for example.\n\n\nUsing the CLI\n\n\nWhen interacting with your services deployed from a monorepo using the CLI, always ensure you are \"linked\" to the appropriate service when executing commands.\n\n\nTo link to a specific service from the CLI, use \nrailway link\n and follow the prompts.\nPrev\n \nRestart Policy\nNext\n \nCron Jobs\nEdit this file on GitHub\nOn This Page\nDeploying an Isolated Monorepo\nDeploying a Shared Monorepo\nWatch paths\nUsing the CLI"
  },
  {
    "url": "https://docs.railway.app/guides/mysql",
    "title": "MySQL | Railway Docs",
    "content": "MySQL\nThe Railway MySQL database template allows you to provision and connect to a MySQL database with zero configuration.\n\n\nDeploy\n\n\nAdd a MySQL database to your project via the \nctrl / cmd + k\n menu or by clicking the \n+ New\n button on the Project Canvas.\n\n\n\n\nYou can also deploy it via the \ntemplate\n from the template marketplace.\n\n\nDeployed Service\n\n\nUpon deployment, you will have a MySQL service running in your project, deployed directly from the \nmysql Docker image\n.\n\n\nConnect\n\n\nConnect to MySQL from another service in your project by \nreferencing the environment variables\n made available in the MySQL service:\n\n\n\n\nMYSQLHOST\n\n\nMYSQLPORT\n\n\nMYSQLUSER\n\n\nMYSQLPASSWORD\n\n\nMYSQLDATABASE\n\n\nMYSQL_URL\n\n\n\n\nConnecting Externally\n\n\nIt is possible to connect to MySQL externally (from outside of the \nproject\n in which it is deployed), by using the \nTCP Proxy\n which is enabled by default.\n\n\nKeep in mind that you will be billed for \nNetwork Egress\n when using the TCP Proxy.\n\n\nModify the Deployment\n\n\nSince the deployed container is pulled from the official MySQL image in Docker hub, you can modify the deployment based on the \ninstructions in Docker hub\n.\n\n\nBackups and Observability\n\n\nEspecially for production environments, performing regular backups and monitoring the health of your database is essential.  Consider adding:\n\n\n\n\n\n\nBackups\n: Automate regular backups to ensure data recovery in case of failure. We suggest checking out our native \nBackups\n feature.\n\n\n\n\n\n\nObservability\n: Implement monitoring for insights into performance and health of your databases.  If you're not already running an observability stack, check out these templates to help you get started building one:\n\n\n\n\nPrometheus\n\n\nGrafana\n\n\n\n\n\n\n\n\nAdditional Resources\n\n\nWhile these templates are available for your convenience, they are considered unmanaged, meaning you have total control over their configuration and maintenance.\n\n\nWe \nstrongly encourage you\n to refer to the source documentation to gain deeper understanding of their functionality and how to use them effectively. Here are some links to help you get started:\n\n\n\n\nMySQL Documentation\n\n\nMySQL InnoDB Cluster Documentation\n\n\nMySQL Router Documentation\n\n\nPrev\n \nPostgreSQL\nNext\n \nRedis\nEdit this file on GitHub\nOn This Page\nDeploy\nDeployed Service\nConnect\nConnecting Externally\nModify the Deployment"
  },
  {
    "url": "https://docs.railway.app/guides/nest",
    "title": "Deploy a NestJS App | Railway Docs",
    "content": "Deploy a NestJS App\nNest\n is a modern Node.js framework designed to create efficient, reliable, and scalable server-side applications. Built on top of powerful HTTP server frameworks, it uses Express as the default but also offers seamless support for Fastify for enhanced performance and flexibility.\n\n\nThis guide covers how to deploy a Nest app to Railway in four ways:\n\n\n\n\nOne-click deploy from a template\n.\n\n\nFrom a GitHub repository\n.\n\n\nUsing the CLI\n.\n\n\nUsing a Dockerfile\n.\n\n\n\n\nNow, let's go ahead and create a Nest app!\n\n\nCreate a Nest App\n\n\nNote:\n If you already have a Nest app locally or on GitHub, you can skip this step and go straight to the \nDeploy Nest App to Railway\n.\n\n\nTo create a new Nest app, ensure that you have \nNode\n and \nNestJS\n installed on your machine.\n\n\nRun the following command in your terminal to create a new Nest app:\n\n\nnest new helloworld\n\n\nA new Nest app will be provisioned for you in the \nhelloworld\n directory.\n\n\nRun the Nest App locally\n\n\nNext, start the app locally by running the following command:\n\n\nnpm\n run start\n\n\nLaunch your browser and navigate to \nhttp://localhost:3000\n to view the app.\n\n\nIf you'd prefer to run the app on a different port, simply use the command \nPORT=8080 npm run start\n in the terminal.\n\n\nAfterward, you can access the app at \nhttp://localhost:8080\n.\n\n\nAdd and Configure Database\n\n\nNote:\n We will be using Postgres for this app. If you donâ€™t have it installed locally, you can either \ninstall it\n or use a different Node.js database package of your choice.\n\n\n\n\n\n\nCreate a database named \nnestjshelloworld_dev\n.\n\n\n\n\n\n\nInstall the following packages:\n\n\n\n\n\n\nnpm\n i @nestjs/typeorm typeorm pg\n\n\n\n\ntypeorm is an ORM library for Typescript and JavaScript.\n\n\npg is for communicating with Postgres database.\n\n\n\n\n\n\nOpen the \nsrc/app.module.ts\n file and modify the content to the code below:\n\n\n\n\nimport\n \n{\n Module \n}\n \nfrom\n \n'@nestjs/common'\n;\n\n\nimport\n \n{\n AppController \n}\n \nfrom\n \n'./app.controller'\n;\n\n\nimport\n \n{\n AppService \n}\n \nfrom\n \n'./app.service'\n;\n\n\nimport\n \n{\n TypeOrmModule \n}\n \nfrom\n \n'@nestjs/typeorm'\n;\n\n\n\n\n@\nModule\n(\n{\n\n\n  \nimports\n:\n \n[\n\n\n    TypeOrmModule\n.\nforRoot\n(\n{\n\n\n      \ntype\n:\n \n'postgres'\n,\n\n\n      \nhost\n:\n \n'localhost'\n,\n\n\n      \nport\n:\n \n5432\n,\n\n\n      \nusername\n:\n \n'username'\n,\n\n\n      \npassword\n:\n \n'password'\n,\n\n\n      \ndatabase\n:\n \n'nestjshelloworld_dev'\n,\n\n\n      \nentities\n:\n \n[\n]\n,\n\n\n      \nsynchronize\n:\n \ntrue\n,\n\n\n    \n}\n)\n,\n\n\n  \n]\n,\n\n\n  \ncontrollers\n:\n \n[\nAppController\n]\n,\n\n\n  \nproviders\n:\n \n[\nAppService\n]\n,\n\n\n}\n)\n\n\nexport\n \nclass\n \nAppModule\n \n{\n}\n\n\nStart the app using the command, \nnpm run start:dev\n. The code above tries to connect to the database once the app is started. If any of the credentials are wrong, you will see a warning stating that the app can't connect to the database.\n\n\n\n\nOpen \nsrc/app.service.ts\n file and modify the content to return \nHello World, Welcome to Railway!\n.\n\n\n\n\nimport\n \n{\n Injectable \n}\n \nfrom\n \n'@nestjs/common'\n;\n\n\n\n\n@\nInjectable\n(\n)\n\n\nexport\n \nclass\n \nAppService\n \n{\n\n\n  \ngetHello\n(\n)\n:\n string \n{\n\n\n    \nreturn\n \n'Hello World, Welcome to Railway!'\n;\n\n\n  \n}\n\n\n}\n\n\n\n\nRun the app again to see your changes in action!\n\n\n\n\nPrepare NestJS App for deployment\n\n\nIn the \nsrc/app.module.ts\n file, replace the hardcoded Postgres database credentials with environment variables:\n\n\nimport\n \n{\n Module \n}\n \nfrom\n \n'@nestjs/common'\n;\n\n\nimport\n \n{\n AppController \n}\n \nfrom\n \n'./app.controller'\n;\n\n\nimport\n \n{\n AppService \n}\n \nfrom\n \n'./app.service'\n;\n\n\nimport\n \n{\n TypeOrmModule \n}\n \nfrom\n \n'@nestjs/typeorm'\n;\n\n\n\n\n@\nModule\n(\n{\n\n\n  \nimports\n:\n \n[\n\n\n    TypeOrmModule\n.\nforRoot\n(\n{\n\n\n      \ntype\n:\n \n'postgres'\n,\n\n\n      \nhost\n:\n process\n.\nenv\n.\nDB_HOST\n,\n\n\n      \nport\n:\n \n5432\n,\n\n\n      \nusername\n:\n process\n.\nenv\n.\nDB_USERNAME\n,\n\n\n      \npassword\n:\n process\n.\nenv\n.\nDB_PASSWORD\n,\n\n\n      \ndatabase\n:\n process\n.\nenv\n.\nDB_DATABASE\n,\n\n\n      \nentities\n:\n \n[\n]\n,\n\n\n      \nsynchronize\n:\n \ntrue\n,\n\n\n    \n}\n)\n,\n\n\n  \n]\n,\n\n\n  \ncontrollers\n:\n \n[\nAppController\n]\n,\n\n\n  \nproviders\n:\n \n[\nAppService\n]\n,\n\n\n}\n)\n\n\nexport\n \nclass\n \nAppModule\n \n{\n}\n\n\nThis allows the app to dynamically pull the correct database configuration from Railway during deployment.\n\n\nDeploy the Nest App to Railway\n\n\nRailway offers multiple ways to deploy your Nest app, depending on your setup and preference.\n\n\nOne-Click Deploy from a Template\n\n\nIf youâ€™re looking for the fastest way to get started with Nest connected to a Postgres database, the one-click deploy option is ideal.\n\n\nClick the button below to begin:\n\n\n\n\nWe highly recommend that \nyou eject from the template after deployment\n to create a copy of the repo on your GitHub account.\n\n\nNote:\n You can also choose from a \nvariety of Nest app templates\n created by the community.\n\n\nDeploy from the CLI\n\n\n\n\nInstall the Railway CLI\n:\n\n\n\nInstall the CLI\n and \nauthenticate it\n using your Railway account.\n\n\n\n\n\n\nInitialize a Railway Project\n:\n\n\n\nRun the command below in your Nest app directory.\n\nrailway init\n\n\n\n\nFollow the prompts to name your project.\n\n\nAfter the project is created, click the provided link to view it in your browser.\n\n\n\n\n\n\nAdd a Postgres Database Service\n:\n\n\n\nRun \nrailway add -d postgres\n.\n\n\nHit \nEnter\n to add it to your project.\n\n\nA database service will be added to your Railway project.\n\n\n\n\n\n\nAdd a Service and Environment Variable\n:\n\n\n\nRun \nrailway add\n.\n\n\nSelect \nEmpty Service\n from the list of options.\n\n\nIn the \nEnter a service name\n prompt, enter \napp-service\n.\n\n\nIn the \nEnter a variable\n prompt, enter\n\n\n\nDB_DATABASE=${{Postgres.PGDATABASE}}\n.\n\n\nDB_USERNAME=${{Postgres.PGUSER}}\n\n\nDB_PASSWORD=${{Postgres.PGPASSWORD}}\n\n\nDB_HOST=${{Postgres.PGHOST}}\n\n\nThe Postgres values references the credentials of your new Postgres database. Learn more about \nreferencing service variables\n.\n\n\n\n\n\n\n\n\nNote:\n Explore the \nRailway CLI reference\n for a variety of options.\n\n\nDeploy the Application\n:\n\n\n\nRun \nrailway up\n to deploy your app.\n\n\n\nThis command will scan, compress and upload your app's files to Railway. Youâ€™ll see real-time deployment logs in your terminal.\n\n\n\n\n\n\nOnce the deployment is complete, we can proceed to generate a domain for the app service.\n\n\n\n\n\n\nSet Up a Public URL\n:\n\n\n\nRun \nrailway domain\n to generate a public URL for your app.\n\n\nVisit the new URL to see your app live in action!\n\n\n\n\n\n\n\n\n\n\nDeploy from a GitHub Repo\n\n\nTo deploy a Nest app to Railway directly from GitHub, follow the steps below:\n\n\n\n\n\n\nCreate a New Project on Railway\n:\n\n\n\n\nGo to \nRailway\n to create a new project.\n\n\n\n\n\n\n\n\nDeploy from GitHub\n:\n\n\n\n\nSelect \nDeploy from GitHub repo\n and choose your repository.\n\n\n\nIf your Railway account isnâ€™t linked to GitHub yet, youâ€™ll be prompted to do so.\n\n\n\n\n\n\n\n\n\n\n\n\nAdd Environment Variables and Provision a Database Service\n:\n\n\n\n\nClick \nAdd Variables\n, but hold off on adding anything just yet. First, proceed with the next step.\n\n\nRight-click on the Railway project canvas or click the \nCreate\n button, then select \nDatabase\n and choose \nAdd PostgreSQL\n.\n\n\n\nThis will create and deploy a new PostgreSQL database for your project.\n\n\n\n\n\n\nOnce the database is deployed, you can return to adding the necessary environment variables:\n\n\n\nDB_DATABASE=${{Postgres.PGDATABASE}}\n.\n\n\nDB_USERNAME=${{Postgres.PGUSER}}\n\n\nDB_PASSWORD=${{Postgres.PGPASSWORD}}\n\n\nDB_HOST=${{Postgres.PGHOST}}\n\n\nThe Postgres values references the credentials of your new Postgres database. Learn more about \nreferencing service variables\n.\n\n\n\n\n\n\n\n\n\n\n\n\nDeploy the App Service\n:\n\n\n\n\nClick \nDeploy\n on the Railway project canvas to apply your changes.\n\n\n\n\n\n\n\n\nVerify the Deployment\n:\n\n\n\n\nOnce the deployment completes, go to \nView logs\n to check if the server is running successfully.\n\n\n\n\nNote:\n During the deployment process, Railway will automatically \ndetect that itâ€™s a Node.js app via Nixpacks\n.\n\n\n\n\n\n\nSet Up a Public URL\n:\n\n\n\n\nNavigate to the \nNetworking\n section under the \nSettings\n tab of your new service.\n\n\nClick \nGenerate Domain\n to create a public URL for your app.\n\n\n\n\n\n\n\n\nUse a Dockerfile\n\n\n\n\nCreate a \nDockerfile\n in the Nest app's root directory.\n\n\nAdd the content below to the \nDockerfile\n:\n\n# Use the Node official image\n\n\n# https://hub.docker.com/_/node\n\n\nFROM node:lts\n\n\n# Create and change to the app directory.\n\n\nWORKDIR /app\n\n\n# Copy local code to the container image\n\n\nCOPY \n.\n ./\n\n\n\n# Install packages\n\n\nRUN \nnpm\n ci\n\n\n\n# Serve the app\n\n\nCMD \n[\n\"npm\"\n, \n\"run\"\n, \n\"start:prod\"\n]\n\n\n\n\nEither deploy via the CLI or from GitHub.\n\n\n\n\nRailway automatically detects the \nDockerfile\n, \nand uses it to build and deploy the app.\n\n\nNote:\n Railway supports also \ndeployment from public and private Docker images\n.\n\n\nThis guide covers the main deployment options on Railway. Choose the approach that suits your setup, and start deploying your Nest apps seamlessly!\n\n\nNext Steps\n\n\nExplore these resources to learn how you can maximize your experience with Railway:\n\n\n\n\nAdd a Database Service\n\n\nMonitor your app\n\n\nPrev\n \nExpress\nNext\n \nFastify\nEdit this file on GitHub\nOn This Page\nCreate a Nest App\nRun the Nest App locally\nAdd and Configure Database\nPrepare NestJS App for deployment\nDeploy the Nest App to Railway\nOne-Click Deploy from a Template\nDeploy from the CLI\nDeploy from a GitHub Repo\nUse a Dockerfile\nNext Steps"
  },
  {
    "url": "https://docs.railway.app/guides/networking",
    "title": "Networking | Railway Docs",
    "content": "Networking\nLet's get your services connected!\n\n\nOnce you are familiar with the foundational components of the platform, you'll likely want to get things connected.  The guides in this section cover the features that enable the best experience possible when establishing connectivity to and within your application.\n\n\nNetworking Features\n\n\nPublic Networking\nPublic networking refers to exposing your application to the public network.  Railway makes it easy to make your applications publicly accessible.\nPrivate Networking\nPrivate networking refers to restricting communication of your services to a private network, inaccessible to the public internet. All Projects in Railway are provisioned with their own private network.\nTCP Proxy\nTCP Proxy is a feature that enables proxying public traffic to a TCP service, like a Database.  This feature allows you to connect to your database services in Railway from anywhere on the internet.\n\n\nDive into the next pages to understand how to use these great features and get your services talking.\nPrev\n \nPhoenix Distillery\nNext\n \nPublic Networking\nEdit this file on GitHub\nOn This Page\nNetworking Features"
  },
  {
    "url": "https://docs.railway.app/guides/nuxt",
    "title": "Deploy a Nuxt App | Railway Docs",
    "content": "Deploy a Nuxt App\nNuxt\n is a Vue.js framework that makes web development intuitive and powerful. You can create performant and production-grade full-stack web apps and websites with confidence.\n\n\nNuxt is known as \nThe Intuitive Vue Framework\n because it simplifies building Vue.js applications with features like server-side rendering and easy routing.\n\n\nThis guide covers how to deploy a Nuxt app to Railway in four ways:\n\n\n\n\nOne-click deploy from a template\n.\n\n\nFrom a GitHub repository\n.\n\n\nUsing the CLI\n.\n\n\nUsing a Dockerfile\n.\n\n\n\n\nNow, let's create a Nuxt app!\n\n\nCreate a Nuxt App\n\n\nNote:\n If you already have a Nuxt app locally or on GitHub, you can skip this step and go straight to the \nDeploy Nuxt App on Railway\n.\n\n\nTo create a new Nuxt app, ensure that you have \nNode\n installed on your machine.\n\n\nRun the following command in your terminal to create a new Nuxt app:\n\n\nnpx nuxi@latest init helloworld\n\n\nA new Nuxt app will be provisioned for you in the \nhelloworld\n directory.\n\n\nRun the Nuxt App locally\n\n\nNext, \ncd\n into the directory and start the development server by running the following command:\n\n\nnpm\n run dev\n\n\nOpen your browser and go to \nhttp://localhost:3000\n to see your app.\n\n\nDeploy the Nuxt App to Railway\n\n\nRailway offers multiple ways to deploy your Nuxt app, depending on your setup and preference.\n\n\nOne-Click Deploy from a Template\n\n\nIf youâ€™re looking for the fastest way to get started, the one-click deploy option is ideal.\n\n\nClick the button below to begin:\n\n\n\n\nWe highly recommend that \nyou eject from the template after deployment\n to create a copy of the repo on your GitHub account.\n\n\nNote:\n You can also choose from a \nvariety of Nuxt app templates\n created by the community.\n\n\nDeploy from the CLI\n\n\n\n\n\n\nInstall the Railway CLI\n:\n\n\n\n\nInstall the CLI\n and \nauthenticate it\n using your Railway account.\n\n\n\n\n\n\n\n\nInitialize a Railway Project\n:\n\n\n\n\nRun the command below in your Vue app directory.\n\n\nrailway init\n\n\n\n\nFollow the prompts to name your project.\n\n\nAfter the project is created, click the provided link to view it in your browser.\n\n\n\n\n\n\n\n\nModify Package.json Config\n:\n\n\n\n\n\n\nBy default, Nuxt doesn't add a start script in the \npackage.json\n file. We'll need to add that to instruct Railway on how to run our app.\n\n\n\n\n\n\nAdd \n\"start\":\"node .output/server/index.mjs\"\n to the \npackage.json\n file.\n\n\n\n\n\n\npackage.json\n\n\n{\n\n\n    \n\"name\"\n:\n \n\"nuxt-app\"\n,\n\n    \n\"private\"\n:\n true,\n\n    \n\"type\"\n:\n \n\"module\"\n,\n\n    \n\"scripts\"\n:\n \n{\n\n\n        \n\"build\"\n:\n \n\"nuxt build\"\n,\n\n        \n\"dev\"\n:\n \n\"nuxt dev\"\n,\n\n        \n\"start\"\n:\n \n\"node .output/server/index.mjs\"\n,\n\n        \n\"generate\"\n:\n \n\"nuxt generate\"\n,\n\n        \n\"preview\"\n:\n \n\"nuxt preview\"\n,\n\n        \n\"postinstall\"\n:\n \n\"nuxt prepare\"\n\n\n    \n}\n,\n\n    \n\"dependencies\"\n:\n \n{\n\n\n        \n\"nuxt\"\n:\n \n\"^3.13.0\"\n,\n\n        \n\"vue\"\n:\n \n\"latest\"\n,\n\n        \n\"vue-router\"\n:\n \n\"latest\"\n\n\n    \n}\n\n\n}\n\n\nNote:\n Railway uses \nNixpacks\n to build and deploy your code with zero configuration. The Nixpack Node provider will pick up the start script in the \npackage.json\n file and use it to serve the app.\n\n\n\n\n\n\nDeploy the Application\n:\n\n\n\n\nUse the command below to deploy your app:\n\n\nrailway up\n\n\n\n\nThis command will scan, compress and upload your app's files to Railway. Youâ€™ll see real-time deployment logs in your terminal.\n\n\nOnce the deployment completes, go to \nView logs\n to check if the service is running successfully.\n\n\n\n\n\n\n\n\nSet Up a Public URL\n:\n\n\n\n\nNavigate to the \nNetworking\n section under the \nSettings\n tab of your new service.\n\n\nClick \nGenerate Domain\n to create a public URL for your app.\n\n\n\n\n\n\n\n\n\n\nDeploy from a GitHub Repo\n\n\nTo deploy a Nuxt app to Railway directly from GitHub, follow the steps below:\n\n\n\n\nCreate a New Project on Railway\n:\n\n\n\n\nGo to \nRailway\n to create a new project.\n\n\n\n\n\n\nModify Package.json Config\n:\n\n\n\n\nFollow \nstep 3 mentioned in the CLI guide\n\n\n\n\n\n\nDeploy from GitHub\n:\n\n\n\n\nSelect \nDeploy from GitHub repo\n and choose your repository.\n\n\n\n\nIf your Railway account isnâ€™t linked to GitHub yet, youâ€™ll be prompted to do so.\n\n\n\n\n\n\n\n\n\n\nDeploy the App\n:\n\n\n\n\nClick \nDeploy\n to start the deployment process.\n\n\nOnce the deployed, a Railway \nservice\n will be created for your app, but it wonâ€™t be publicly accessible by default.\n\n\n\n\n\n\nVerify the Deployment\n:\n\n\n\n\nOnce the deployment completes, go to \nView logs\n to check if the server is running successfully.\n\n\n\n\n\n\nSet Up a Public URL\n:\n\n\n\n\nNavigate to the \nNetworking\n section under the \nSettings\n tab of your new service.\n\n\nClick \nGenerate Domain\n to create a public URL for your app.\n\n\n\n\n\n\n\n\nUse a Dockerfile\n\n\n\n\nCreate a \nDockerfile\n in the \nhelloworld\n or Nuxt app's root directory.\n\n\nAdd the content below to the \nDockerfile\n:\n\n\n# Use the Node alpine official image\n\n\n# https://hub.docker.com/_/node\n\n\nFROM node:lts-alpine AS build\n\n\n\n# Create and change to the app directory.\n\n\nWORKDIR /app\n\n\n\n# Copy the files to the container image\n\n\nCOPY package*.json ./\n\n\n\n# Install packages\n\n\nRUN \nnpm\n ci\n\n\n\n# Copy local code to the container image.\n\n\nCOPY \n.\n ./\n\n\n\n# Build the app.\n\n\nRUN \nnpm\n run build\n\n\n\n# Copy files to the container image.\n\n\nCOPY --from\n=\nbuild /app ./\n\n\n\n# Serve the app\n\n\nCMD \n[\n\"npm\"\n, \n\"run\"\n, \n\"start\"\n]\n\n\n\n\nEither deploy via the CLI or from GitHub.\n\n\n\n\nRailway automatically detects the \nDockerfile\n, \nand uses it to build and deploy the app.\n\n\nNote:\n Railway supports also \ndeployment from public and private Docker images\n.\n\n\nThis guide covers the main deployment options on Railway. Choose the approach that suits your setup, and start deploying your Nuxt apps seamlessly!\n\n\nNext Steps\n\n\nExplore these resources to learn how you can maximize your experience with Railway:\n\n\n\n\nAdd a Database Service\n\n\nMonitor your app\n\n\nPrev\n \nVue\nNext\n \nSpring Boot\nEdit this file on GitHub\nOn This Page\nCreate a Nuxt App\nRun the Nuxt App locally\nDeploy the Nuxt App to Railway\nOne-Click Deploy from a Template\nDeploy from the CLI\nDeploy from a GitHub Repo\nUse a Dockerfile\nNext Steps"
  },
  {
    "url": "https://docs.railway.app/guides/observability",
    "title": "Observability Dashboard | Railway Docs",
    "content": "Observability Dashboard\nRailway provides a built-in observability dashboard that provides a customizable view into chosen metrics, logs, and data all in one place.\n\n\n\n\nShape the future of this dashboard! We are actively collecting feedback on usecases and bugs you may encounter.\n\n\nNavigating to the Observability Dashboard\n\n\n\n\nUsers may notice that the project navigation is updated with the feature.\n\n\n\n\nNavigate to the Observability tab from the main project top bar.\n\n\nEnsure you are in the correct environment (e.g., production).\n\n\n\n\nThe Observability Dashboard is uniquely scoped to each project environment as services may differ between each environment.\n\n\nGetting Started\n\n\nBy default the Observability Dashboard starts with no configured widgets.\n\n\n\n\nWhen you first access a new environment, you will be prompted to \"Start with a simple dashboard\" or \"Add new item\".\n\n\nClick on \"Start with a simple dashboard\" to create your initial layout, Railway will autogenerate graphs and widgets with spend, service metrics and logs.\n\n\n\n\nCreating Widgets\n\n\nClicking \"New\" in the top right corner of the dashboard will open the Widget creation modal. Widget types depend on the data source provided, where they can be a graph, displayed data, or logs.\n\n\n\n\nWidgets have a name and a description attached to them. By default Railway will provide a suggested name for the widget upon creation and display a preview of the content that is to be displayed on the dashboard.\n\n\nAvailable Data Sources\n\n\nOn the top right, you can select a data source to display within a widget.\n\n\n\n\nCPU Usage: Track the CPU usage for various services over time.\n\n\nMemory Usage: Monitor the memory consumption for your services.\n\n\nNetwork In/Out: Keep track of network traffic.\n\n\nDisk Usage: Observe disk usage trends.\n\n\nLogs: Select logs from a single service or multiple services with filtering\n\n\nProject Usage: report the spend of your project and track the overall resource usage of your project.\n\n\n\n\nFiltering Widget Information\n\n\nWhen creating a widget, you can use Railway's filtering syntax to select services, select data, and perform logical negations to define rules.\n\n\n\n\n<keyword>\n or \n\"key phrase\"\n â†’ Filter by exact text\n\n\n@key:value\n â†’ Filter by key/value pair\n\n\n\n\nValid keys are replica, deployment, service, plugin\n\n\n\n\n\n\n@attribute:value\n â†’ Filter by custom attribute (see structured logs below)\n\n\n\n\nAny of the above expressions can be combined with boolean operators \nAND\n,\n\nOR\n, and \n-\n (negation).\n\n\nArranging the Dashboard\n\n\nThe Dashboard is customizable in content and layout. Widgets can be stacked, repositioned and resized.\n\n\nClicking the \"Edit\" button on the top right corner of the dashboard will transition the dashboard into edit mode, the dashboard then allows the ability to resize and reposition your widgets using the provided handle on each widget. To persist your changes, select \"Save\".\n\n\n\n\nResizing and Moving Widgets:\n\n\n\n\nDrag and drop items to rearrange them on the grid by dragging the arrow handle.\n\n\nResize widgets by dragging the bottom right corner handle\n\n\n\n\nNote for Small Screens: On smaller screens, items stack vertically and respect their configured height to ensure readability and usability. Editing is disabled at smaller visual breakpoints.\n\n\nEditing/Deleting Widgets\n\n\nUnder Edit mode, each widget will have a three dot menu at the upper right corner at the bounding box of the widget. Clicking into this menu will allow you to edit the data source or delete the widget.\n\n\nTo persist your changes, make sure you press Save at the top right corner.\nPrev\n \nLogs\nNext\n \nMetrics\nEdit this file on GitHub\nOn This Page\nNavigating to the Observability Dashboard\nGetting Started\nCreating Widgets\nAvailable Data Sources\nFiltering Widget Information\nArranging the Dashboard\nEditing/Deleting Widgets"
  },
  {
    "url": "https://docs.railway.app/guides/optimize-performance",
    "title": "Optimize Performance | Railway Docs",
    "content": "Optimize Performance\nRailway offers some quick and easy ways to configure deployments for achieving optimal performance.\n\n\nSpecifically, we offer the following features:\n\n\n\n\nHorizontal Scaling with Replicas where each individual replica can use the full resources your plan allows for. (\nVertical scaling\n is done automatically)\n\n\nRegional Deployments\n\n\n\n\nContinue reading for information on how to configure these.\n\n\nConfigure Horizontal Scaling\n\n\nScale horizontally by manually increasing the number of replicas for a service.\n\n\nEach replica has access to the full resources allocated by your plan. For instance, with the \nPro\n plan, each of your replicas can utilize up to 32 vCPU and 32GB of memory, for example, if you had 2 replicas, your service would be able to utilize up to 64 vCPU and 64GB of memory split between the 2 replicas.\n\n\nRailway's infrastructure spans multiple regions across the globe, and by default Railway deploys to your \npreferred region\n.\n\n\n\n\nTo change the number of replicas per deploy within your service, go to the service settings view and look for the \"Regions\" field in the \"Deploy\" section. This will create multiple instances of your service and distribute traffic between them.\n\n\nAdditional regions may be added in the future as Railway continues expanding its infrastructure footprint.\n\n\nReplica ID Environment Variable\n\n\nEach replica will be deployed with a Railway-provided environment variable named \nRAILWAY_REPLICA_ID\n which can be used for logging and monitoring, for example.\n\n\nReplica Region Environment Variable\n\n\nEach replica will be deployed with a Railway-provided environment variable named \nRAILWAY_REPLICA_REGION\n which can be used for logging and monitoring, for example.\n\n\nLoad Balancing Between Replicas\n\n\nIf you are using multi-region replicas, Railway will automatically route public traffic to the nearest region and then randomly distribute requests to the replicas within that region.\n\n\nIf you are using a single region with multiple replicas, Railway will randomly distribute public traffic to the replicas of that region.\n\n\nNote:\n For now Railway does not support sticky sessions nor report the usage of the individual replicas within the metrics view, all metrics are aggregated across all replicas in all regions.\n\n\nSet a Preferred Region\n\n\nTo set a default or preferred region, do so from your \nWorkspace Settings\n.\n\n\nImpact of Region Changes\n\n\nFor information on the impact of changing a service's region, see the \nRegions reference guide\n.\n\n\nSingleton Deploys\n\n\nBy default, Railway maintains only one deploy per service.\nPrev\n \nGitHub Autodeploys\nNext\n \nHealthchecks\nEdit this file on GitHub\nOn This Page\nConfigure Horizontal Scaling\nReplica ID Environment Variable\nReplica Region Environment Variable\nLoad Balancing Between Replicas\nSet a Preferred Region\nImpact of Region Changes\nSingleton Deploys"
  },
  {
    "url": "https://docs.railway.app/guides/optimize-usage",
    "title": "Optimize Usage | Railway Docs",
    "content": "Optimize Usage\nRailway provides controls over resource usage in the form of usage limits and auto-sleeping of inactive services.\n\n\nConfiguring Usage Limits\n\n\nUsage Limits allow you to set a maximum limit on your usage for a billing cycle.\n\n\nVisit the \nWorkspace Usage page\n to set the usage limits. Once you click the \nSet Usage Limits\n button, you will see a modal above where you can set a \nCustom email alert\n and a \nHard limit\n.\n\n\n\n\nSetting Limits for Teams\n\n\nIf you want to set a usage limit for your team, use the account switcher in the top left corner of your dashboard to access the team's usage page.\n\n\nSetting Limits for Prepaid Plans\n\n\nIf you are on a prepaid plan, you can not directly set a hard limit. Instead the amount of credits you load determines the hard limit.\n\n\nCustom Email Alert\n\n\nConfigure a soft limit by setting a threshold in Custom email alert. When your resource usage reaches the specified amount, we will email you that this threshold has been met and resources continue running.\n\n\nHard Limit\n\n\nConfigure a hard limit to take resources offline once usage meets the specified threshold.\n\n\nMultiple emails will be sent as your usage approaches your hard limit:\n\n\n\n\nWhen your usage reaches 75% of your hard limit\n\n\nWhen your usage reaches 90% of your hard limit\n\n\nWhen your usage reaches 100% of your hard limit and workloads have been taken down.\n\n\n\n\nSetting a hard limit is a possibly destructive action as you're risking having all your resources shut down once your usage crosses the specified amount.\n\n\nFind more information about Usage Limits in the \nreference page\n.\n\n\nUse Private Networking\n\n\nUsing \nPrivate Networking\n when communicating with other services (such as databases) within your Railway project will help you avoid unnecessary Network Egress costs.\n\n\nWith Databases\n\n\nCommunicate with your Railway database over private networking by using the \nDATABASE_URL\n environment variable, instead of \nDATABASE_PUBLIC_URL\n:\n\n\nWith Other Services\n\n\nIf your Railway services need to communicate with each other, you can find the service's private URL in the service settings:\n\n\n\n\nLearn more about Railway's Private Networking \nhere\n.\n\n\nEnabling Serverless\n\n\nEnabling Serverless on a service tells Railway to stop a service when it is inactive, effectively reducing the overall cost to run it.\n\n\nTo enable Serverless, toggle the feature on within the service configuration pane in your project:\n\n\n\n\n\n\nNavigate to your service's settings > Deploy > Serverless\n\n\nToggle \"Enable Serverless\"\n\n\nTo \ndisable\n Serverless, toggle the setting again\n\n\n\n\nRead more about how Serverless works in the \nServerless Reference page\n.\n\n\nResource Limits\n\n\nResource limits are a way to limit the maximum amount of resources available to a service.\n\n\nTo toggle resource limits, navigate to your service's settings > Deploy > Resource Limits.\n\n\n\n\nUse Resource Limits\n\n\nSetting resource limits too low will cause your service to crash.\n\n\nUsing resource limits makes sense in scenarios where:\n\n\n\n\nYou don't want to risk a high bill due to unexpected spikes in usage\n\n\nYou are okay with the service crashing if it exceeds the limit\n\n\nPrev\n \nCron Jobs\nNext\n \nDatabases\nEdit this file on GitHub\nOn This Page\nConfiguring Usage Limits\nCustom Email Alert\nHard Limit\nUse Private Networking\nWith Databases\nWith Other Services\nEnabling Serverless\nResource Limits\nUse Resource Limits"
  },
  {
    "url": "https://docs.railway.app/guides/phoenix",
    "title": "Deploy a Phoenix App | Railway Docs",
    "content": "Deploy a Phoenix App\nPhoenix\n is popular Elixir framework designed for building scalable, maintainable, and high-performance web applications. It is known for its ability to handle real-time features efficiently, like WebSockets, while leveraging Elixir's concurrency model, which is built on the Erlang Virtual Machine (BEAM).\n\n\nCreate a Phoenix App\n\n\nNote:\n If you already have a Phoenix app locally or on GitHub, you can skip this step and go straight to the \nDeploy Phoenix App on Railway\n.\n\n\nTo create a new Phoenix app, ensure that you have \nElixir\n and \nHex package manager\n installed on your machine. Once everything is set up, run the following command in your terminal to install the Phoenix application generator:\n\n\nmix archive.install hex phx_new\n\n\nNext, run the following command:\n\n\nmix phx.new helloworld\n\n\nSelect \nY\n to install all dependencies.\n\n\nThis command will create a new Phoenix app named \nhelloworld\n with some optional dependencies such as:\n\n\n\n\nEcto\n for communicating with a database such as PostgreSQL, MySQL etc\n\n\nPhoenix live view\n for building realtime & interactive web apps.\n\n\nPhoenix HTML and Tailwind CSS\n for HTML apps.\n\n\n\n\nConfigure Database\n\n\nNext, navigate into the \nhelloworld\n directory using the \ncd\n command.\n\n\nOpen up the \nconfig/dev.exs\n file. You'll notice that a new Phoenix app is already set up with PostgreSQL settings. It assumes the database has a \npostgres\n user with the right permissions and a default password of \npostgres\n. Update the username and password to match your local PostgreSQL account credentials.\n\n\nNote\n: If you prefer using a different database, like MySQL, you can easily switch the database adapter in the \nmix.exs\n file. Simply remove the \nPostgrex\n dependency and add \nMyXQL\n instead. For detailed instructions, check out this \nguide on using other databases\n in Phoenix.\n\n\nThe default database name is set to \nhelloworld_dev\n, but feel free to change it to whatever you'd prefer.\n\n\nNext, create the database for our app by running the following command:\n\n\nmix ecto.create\n\n\nA database will be created for our app.\n\n\nRun the Phoenix App locally\n\n\nStart the app by running the following command:\n\n\nmix phx.server\n\n\nBy default, Phoenix accepts requests on port \n4000\n.\n\n\nOpen your browser and go to \nhttp://localhost:4000\n to see your app.\n\n\nNow that your app is running locally, letâ€™s move on to deploying it to Railway!\n\n\nPrepare our Phoenix App for deployment\n\n\nGo ahead and create a \nnixpacks.toml\n file in the root directory of our Phoenix app.\n\n\nThe \nnixpacks.toml file\n is a configuration file used by Nixpacks, a build system developed and used by Railway, to set up and deploy applications.\n\n\nIn this file, you can specify the instructions for various build and deployment phases, along with environment variables and package dependencies.\n\n\nAdd the following content to the file:\n\n\n# nixpacks.toml\n\n\n[\nvariables\n]\n\n\nMIX_ENV\n \n=\n \n'prod'\n\n\n\n\n[\nphases.setup\n]\n\n\nnixPkgs\n \n=\n \n[\n'...'\n,\n \n'erlang'\n]\n\n\n\n\n[\nphases.install\n]\n\n\ncmds\n \n=\n \n[\n\n\n  \n'mix local.hex --force'\n,\n\n\n  \n'mix local.rebar --force'\n,\n\n\n  \n'mix deps.get --only prod'\n\n\n]\n\n\n\n\n[\nphases.build\n]\n\n\ncmds\n \n=\n \n[\n\n\n  \n'mix compile'\n,\n\n\n  \n'mix assets.deploy'\n\n\n]\n\n\n\n\n[\nstart\n]\n\n\ncmd\n \n=\n \n\"mix ecto.setup && mix phx.server\"\n\n\n\n\n[variables]\n This section contains the list of env variables you want to set for the app.\n\n\n\n\nMIX_ENV = 'prod'\n: It sets the Elixir environment to prod.\n\n\n\n\n\n\n[phases.setup]\n: This defines a list of Nix packages to be installed during the setup phase. The placeholder \n'...'\n should be replaced with any additional packages needed for your application. The inclusion of erlang indicates that the Erlang runtime is required for the Elixir application.\n\n\n[phases.install]\n: This section contains a list of commands to run during the installation phase.\n\n\n\n\nmix local.hex --force\n: Installs the Hex package manager for Elixir, which is necessary for managing dependencies.\n\n\nmix local.rebar --force\n: Installs Rebar, a build tool for Erlang.\n\n\nmix deps.get --only prod\n: Fetches only the production dependencies defined in the \nmix.exs\n file.\n\n\n\n\n\n\n[phases.build]\n: This section contains commands to run during the build phase.\n\n\n\n\nmix compile\n: Compiles the Elixir application.\n\n\nmix assets.deploy\n: This is a command to handle the deployment of static assets (e.g., JavaScript, CSS) for our app.\n\n\n\n\n\n\n[start]\n: This section contains commands to run when starting the application.\n\n\n\n\nmix ecto.setup\n: This command is used to set up the database by running migrations and seeding it. It prepares the database for the application to connect.\n\n\nmix phx.server\n: This starts the Phoenix server, allowing the application to begin accepting requests.\n\n\n\n\n\n\n\n\nNow, we are ready to deploy!\n\n\nDeploy Phoenix App to Railway\n\n\nRailway offers multiple ways to deploy your Phoenix app, depending on your setup and preference. Choose any of the following methods:\n\n\n\n\nOne-click deploy from a template\n.\n\n\nUsing the CLI\n.\n\n\nFrom a GitHub repository\n.\n\n\n\n\nOne-Click Deploy from a Template\n\n\nIf youâ€™re looking for the fastest way to get started, the one-click deploy option is ideal. It sets up a Phoenix app along with a Postgres database.\n\n\nClick the button below to begin:\n\n\n\n\nAfter deploying, we recommend that you \neject from the template\n to create a copy of the repository under your own GitHub account. This will give you full control over the source code and project.\n\n\nDeploy from the CLI\n\n\nTo deploy the Phoenix app using the Railway CLI, please follow the steps:\n\n\n\n\n\n\nInstall the Railway CLI\n:\n\n\n\n\nInstall the CLI\n and \nauthenticate it\n using your Railway account.\n\n\n\n\n\n\n\n\nInitialize a Railway Project\n:\n\n\n\n\nRun the command below in your Phoenix app directory.\n\n\nrailway init\n\n\n\n\nFollow the prompts to name your project.\n\n\nAfter the project is created, click the provided link to view it in your browser.\n\n\n\n\n\n\n\n\nDeploy the Application\n:\n\n\n\n\nUse the command below to deploy your app:\n\n\nrailway up\n\n\n\n\nThis command will scan, compress and upload your app's files to Railway. Youâ€™ll see real-time deployment logs in your terminal.\n\n\n\n\nNote:\n You might encounter an errorâ€“â€“\nwarning: the VM is running with native name encoding of latin1 which\n \nmay cause Elixir to malfunction as it expects utf8....\n. Donâ€™t worry, weâ€™ll address this in the next step.\n\n\n\n\n\n\nAdd a Database Service\n:\n\n\n\n\nRun \nrailway add\n.\n\n\nSelect \nPostgreSQL\n by pressing space and hit \nEnter\n to add it to your project.\n\n\nA database service will be added to your Railway project.\n\n\n\n\n\n\n\n\nConfigure Environment Variables\n:\n\n\n\n\nGo to your app service \nVariables\n section and add the following:\n\n\n\n\nSECRET_KEY_BASE\n : Set the value to the your app's secret key. You can run \nmix phx.gen.secret\n locally to generate one.\n\n\nLANG\nand \nLC_CTYPE\n: Set both values to \nen_US.UTF-8\n. This sets your app's locale and gets rid of the \nnative name encoding of latin1\n warning.\n\n\nDATABASE_URL\n: Set the value to \n${{Postgres.DATABASE_URL}}\n (this references the URL of your new Postgres database). Learn more about \nreferencing service variables\n.\n\n\nECTO_IPV6\n: Set the value to \ntrue\n to enable your Phoenix app to connect to the database through the \nIPv6 private network\n.\n\n\n\n\n\n\nUse the \nRaw Editor\n to add any other required environment variables in one go.\n\n\n\n\n\n\n\n\nRedeploy the Service\n:\n\n\n\n\nClick \nDeploy\n on the Railway Project Canvas to apply your changes.\n\n\n\n\n\n\n\n\nVerify the Deployment\n:\n\n\n\n\nOnce the deployment completes, go to \nView logs\n to check if the server is running successfully.\n\n\n\n\n\n\n\n\nSet Up a Public URL\n:\n\n\n\n\nNavigate to the \nNetworking\n section under the \nSettings\n tab of your new service.\n\n\nClick \nGenerate Domain\n to create a public URL for your app.\n\n\n\n\n\n\n\n\n\n\nDeploy from a GitHub Repo\n\n\nTo deploy the Phoenix app to Railway, start by pushing the app to a GitHub repo. Once thatâ€™s set up, follow the steps below to complete the deployment process.\n\n\n\n\n\n\nCreate a New Project on Railway\n:\n\n\n\n\nGo to \nRailway\n to create a new project.\n\n\n\n\n\n\n\n\nDeploy from GitHub\n:\n\n\n\n\nSelect \nDeploy from GitHub repo\n and choose your repository.\n\n\n\n\nIf your Railway account isnâ€™t linked to GitHub yet, youâ€™ll be prompted to do so.\n\n\n\n\n\n\n\n\n\n\n\n\nAdd Environment Variables and Provision a Database Service\n:\n\n\n\n\nClick \nAdd Variables\n, but hold off on adding anything just yet. First, proceed with the next step.\n\n\nRight-click on the Railway project canvas or click the \nCreate\n button, then select \nDatabase\n and choose \nAdd PostgreSQL\n. This will create and deploy a new PostgreSQL database for your project.\n\n\nOnce the database is deployed, you can return to adding the necessary environment variables:\n\n\n\n\nSECRET_KEY_BASE\n : Set the value to the your app's secret key. You can run \nmix phx.gen.secret\n locally to generate one.\n\n\nLANG\nand \nLC_CTYPE\n: Set both values to \nen_US.UTF-8\n to ensure proper locale settings and avoid the \nnative name encoding of latin1 warning\n.\n\n\nDATABASE_URL\n: Set the value to \n${{Postgres.DATABASE_URL}}\n (this references the URL of your new Postgres database). Learn more about \nreferencing service variables\n.\n\n\nECTO_IPV6\n: Set the value to \ntrue\n to enable your Phoenix app to connect to the database through the \nIPv6 private network\n.\n\n\n\n\n\n\n\n\n\n\n\n\nDeploy the App Service\n:\n\n\n\n\nClick \nDeploy\n on the Railway project canvas to apply your changes.\n\n\n\n\n\n\n\n\nVerify the Deployment\n:\n\n\n\n\nOnce the deployment completes, go to \nView logs\n to check if the server is running successfully.\n\n\n\n\nNote:\n During the deployment process, Railway will automatically \ndetect that itâ€™s an Elixir app\n.\n\n\n\n\n\n\nSet Up a Public URL\n:\n\n\n\n\nNavigate to the \nNetworking\n section under the \nSettings\n tab of your new service.\n\n\nClick \nGenerate Domain\n to create a public URL for your app.\n\n\n\n\n\n\n\n\nThis guide covers the main deployment options on Railway. Choose the approach that suits your setup, and start deploying your Phoenix apps effortlessly!\n\n\nWant to Deploy Livebook?\n\n\nLivebook\n, an interactive notebook tool built specifically for Elixir, provides a powerful and intuitive environment for exploring data, running code, and documenting insights, all in one place. Itâ€™s perfect for experimenting with Elixir code, prototyping, and sharing live documentation.\n\n\nClick the button below to deploy an instance of Livebook quickly.\n\n\n\n\nNext Steps\n\n\nExplore these resources to learn how you can maximize your experience with Railway:\n\n\n\n\nDeploy Phoenix with Distillery\n\n\nMonitoring\n\n\nDeployments\n\n\nPrev\n \nSolid\nNext\n \nPhoenix Distillery\nEdit this file on GitHub\nOn This Page\nCreate a Phoenix App\nConfigure Database\nRun the Phoenix App locally\nPrepare our Phoenix App for deployment\nDeploy Phoenix App to Railway\nOne-Click Deploy from a Template\nDeploy from the CLI\nDeploy from a GitHub Repo\nWant to Deploy Livebook?\nNext Steps"
  },
  {
    "url": "https://docs.railway.app/guides/phoenix-distillery",
    "title": "Deploy a Phoenix App with Distillery | Railway Docs",
    "content": "Deploy a Phoenix App with Distillery\nPhoenix\n is popular Elixir framework designed for building scalable, maintainable, and high-performance web applications. It is known for its ability to handle real-time features efficiently, like WebSockets, while leveraging Elixir's concurrency model, which is built on the Erlang Virtual Machine (BEAM).\n\n\nIn this guide, you'll learn how to deploy Phoenix apps with \nDistillery\n to Railway.\n\n\nCreate a Phoenix App with Distillery\n\n\nNote:\n If you already have a Phoenix app locally or on GitHub, you can skip this step and go straight to the \nDeploy Phoenix App with Distillery to Railway\n.\n\n\nTo create a new Phoenix app, ensure that you have \nElixir\n and \nHex package manager\n installed on your machine. Once everything is set up, run the following command in your terminal to install the Phoenix application generator:\n\n\nmix archive.install hex phx_new\n\n\nNext, run the following command:\n\n\nmix phx.new helloworld_distillery\n\n\nSelect \nY\n to install all dependencies.\n\n\nThis command will create a new Phoenix app named \nhelloworld_distillery\n with some optional dependencies such as:\n\n\n\n\nEcto\n for communicating with a database such as PostgreSQL, MySQL etc\n\n\nPhoenix live view\n for building realtime & interactive web apps.\n\n\nPhoenix HTML and Tailwind CSS\n for HTML apps.\n\n\n\n\nConfigure Database\n\n\nNext, navigate into the \nhelloworld\n directory using the \ncd\n command.\n\n\nOpen up the \nconfig/dev.exs\n file. You'll notice that a new Phoenix app is already set up with PostgreSQL settings. It assumes the database has a \npostgres\n user with the right permissions and a default password of \npostgres\n. Update the username and password to match your local PostgreSQL account credentials.\n\n\nNote\n: If you prefer using a different database, like MySQL, you can easily switch the database adapter in the \nmix.exs\n file. Simply remove the \nPostgrex\n dependency and add \nMyXQL\n instead. For detailed instructions, check out this \nguide on using other databases\n in Phoenix.\n\n\nThe default database name is set to \nhelloworld_dev\n, but feel free to change it to whatever you'd prefer.\n\n\nNext, create the database for our app by running the following command:\n\n\nmix ecto.create\n\n\nA database will be created for our app.\n\n\nAdd and Configure Distillery\n\n\n\n\nOpen up the \nmix.exs\n file and add Distillery to the deps function:\n\n\n\n\ndefp\n deps \ndo\n\n\n    \n[\n \n...\n,\n\n\n     \n{\n:distillery\n,\n \n\"~> 2.1\"\n}\n,\n\n\n      \n...\n,\n\n\n    \n]\n\n\n  \nend\n\n\nNow, run \nmix deps.get\n to update your dependencies.\n\n\n\n\nOpen up \nconfig/prod.exs\n file and update the endpoint section to the following:\n\n\n\n\nconfig \n:helloworld_distillery\n,\n \nHelloworldDistilleryWeb\n.\nEndpoint\n,\n\n\n  \ncache_static_manifest:\n \n\"priv/static/cache_manifest.json\"\n,\n\n\n  \nserver:\n \ntrue\n,\n\n\n  \nroot:\n \n\".\"\n,\n\n\n  \nversion:\n \nApplication\n.\nspec\n(\n:phoenix_distillery\n,\n \n:vsn\n)\n\n\nserver\n configures the endpoint to boot the Cowboy application http endpoint on start.\n\nroot\n configures the application root for serving static files\n\nversion\n ensures that the asset cache will be busted on versioned application upgrades.\n\n\n\n\nInitialize your Distillery release by running the following command:\n\n\n\n\nmix distillery.init\n\n\nThis will create the \nrel/config.exs\n and \nrel/vm.args\n files. A \nrel/plugins\n directory will be created too.\n\n\n\n\nCreate a Mix config file at \nrel/config/config.exs\n. Here, we are creating a mix config provider. Add the following to it:\n\n\n\n\nimport\n \nConfig\n\n\n\n\nport \n=\n \nString\n.\nto_integer\n(\nSystem\n.\nget_env\n(\n\"PORT\"\n)\n \n||\n \n\"4000\"\n)\n\n\ndefault_secret_key_base \n=\n \n:crypto\n.\nstrong_rand_bytes\n(\n43\n)\n \n|>\n \nBase\n.\nencode64\n\n\n\nconfig \n:helloworld_distillery\n,\n \nHelloworldDistilleryWeb\n.\nEndpoint\n,\n\n\n  \nhttp:\n \n[\nport:\n port\n]\n,\n\n\n  \nurl:\n \n[\nhost:\n \n\"localhost\"\n,\n \nport:\n port\n]\n,\n\n\n  \nsecret_key_base:\n \nSystem\n.\nget_env\n(\n\"SECRET_KEY_BASE\"\n)\n \n||\n default_secret_key_base\n\n\nNow, update the \nrel/config.exs\n file to use our new provider. In the \nenvironment :prod\n part of the file, replace with the following:\n\n\nenvironment \n:prod\n \ndo\n\n\n  set \ninclude_erts:\n \ntrue\n\n\n  set \ninclude_src:\n \nfalse\n\n\n  set \ncookie:\n :\n\"Jo2*~U0C1x!*E}!o}W*(mx=pzd[XWG[bW)T~_Kjy3eJuEJ;M&!eqj7AUR1*9Vw]!\"\n\n\n  set \nconfig_providers:\n \n[\n\n\n    \n{\nDistillery\n.\nReleases\n.\nConfig\n.\nProviders\n.\nElixir\n,\n \n[\n\"${RELEASE_ROOT_DIR}/etc/config.exs\"\n]\n}\n\n\n  \n]\n\n\n  set \noverlays:\n \n[\n\n\n    \n{\n:copy\n,\n \n\"rel/config/config.exs\"\n,\n \n\"etc/config.exs\"\n}\n\n\n  \n]\n\n\nend\n\n\n\n\nFinally, let's configure Ecto to fetch the database credentials from the runtime environment variables.\n\n\n\n\nOpen the \nlib/helloworld_distillery/repo.ex\n file and modify it to this:\n\n\ndefmodule\n \nHelloworldDistillery\n.\nRepo\n \ndo\n\n\n  \nuse\n \nEcto\n.\nRepo\n,\n\n\n    \notp_app:\n \n:helloworld_distillery\n,\n\n\n    \nadapter:\n \nEcto\n.\nAdapters\n.\nPostgres\n,\n\n\n    \npool_size:\n \n10\n\n\n  \ndef\n \ninit\n(\n_type\n,\n config\n)\n \ndo\n\n\n    \n{\n:ok\n,\n \nKeyword\n.\nput\n(\nconfig\n,\n \n:url\n,\n \nSystem\n.\nget_env\n(\n\"DATABASE_URL\"\n)\n)\n}\n\n\n  \nend\n\n\nend\n\n\nBuild the Release with Distillery\n\n\nTo build the release, run the following command:\n\n\nnpm\n run deploy --prefix assets \n&&\n \nMIX_ENV\n=\nprod mix \ndo\n phx.digest, distillery.release --env\n=\nprod\n\n\nHandling Errors\n\n\nIf you encounter the following error after running the command:\n\n\n==\n>\n Invalid application \n`\n:sasl\n`\n!\n The \nfile\n sasl.app does not exist or cannot be loaded.\n\n\nYou need to modify your \nmix.exs\n file to include \n:sasl\n. Open the file and add \n:sasl\n to the \nextra_applications\n list in the \napplication\n function:\n\n\ndef\n application \ndo\n\n\n    \n[\n\n\n      \nmod:\n \n{\nHelloworldDistillery\n.\nApplication\n,\n \n[\n]\n}\n,\n\n\n      \nextra_applications:\n \n[\n:logger\n,\n \n:runtime_tools\n,\n \n:sasl\n]\n\n\n    \n]\n\n\n  \nend\n\n\nAfter saving your changes, try running the command again as a super user to prevent access errors:\n\n\nsudo\n \nnpm\n run deploy --prefix assets \n&&\n \nMIX_ENV\n=\nprod mix \ndo\n phx.digest, distillery.release --env\n=\nprod\n\n\nAdditional Errors\n\n\nIf you encounter this error:\n\n\nFailed to archive release: _build/prod/rel/helloworld_distillery/releases/RELEASES: no such \nfile\n or directory\n\n\nYouâ€™ll need to create the \nRELEASES\n directory manually. Once created, run the command again.\n\n\nSuccessful Build\n\n\nUpon a successful build, you should see output similar to the following:\n\n\n..\n.\n\n==\n>\n Packaging release\n..\n\n\nRelease successfully built\n!\n\n\nTo start the release you have built, you can use one of the following tasks:\n\n\n    \n# start a shell, like 'iex -S mix'\n\n\n    \n>\n _build/prod/rel/helloworld_distillery/bin/helloworld_distillery console\n\n\n\n    \n# start in the foreground, like 'mix run --no-halt'\n\n\n    \n>\n _build/prod/rel/helloworld_distillery/bin/helloworld_distillery foreground\n\n\n\n    \n# start in the background, must be stopped with the 'stop' command\n\n\n    \n>\n _build/prod/rel/helloworld_distillery/bin/helloworld_distillery start\n\n\nIf you started a release elsewhere, and wish to connect to it:\n\n\n    \n# connects a local shell to the running node\n\n\n    \n>\n _build/prod/rel/helloworld_distillery/bin/helloworld_distillery remote_console\n\n\n\n    \n# connects directly to the running node's console\n\n\n    \n>\n _build/prod/rel/helloworld_distillery/bin/helloworld_distillery attach\n\n\nFor a complete listing of commands and their use:\n\n\n    \n>\n _build/prod/rel/helloworld_distillery/bin/helloworld_distillery \nhelp\n\n\nTest the Release with Distillery locally\n\n\nNow, let's test our release locally. First, create your database by running the following command:\n\n\nmix ecto.create\n\n\nNext, export the necessary environment variables by running:\n\n\nexport\n \nDATABASE_URL\n=\npostgresql://username:password@127.0.0.1:5432/helloworld_distillery\n\nexport\n \nSECRET_KEY_BASE\n=\n<\nyour-secret-key-base\n>\n\n\nWith the environment set up, you can start the release with:\n\n\n_build/prod/rel/helloworld_distillery/bin/helloworld_distillery foreground\n\n\nOnce your app is running, open your browser and visit \nhttp://localhost:4000\n to see it in action.\n\n\nWith your app up and running locally, let's move on to deploying the release to Railway!\n\n\nPrepare App for Deployment\n\n\nCreate a \nnixpacks.toml\n file in the root of your app directory and add the following content:\n\n\n# nixpacks.toml\n\n\n[\nvariables\n]\n\n\nMIX_ENV\n \n=\n \n'prod'\n\n\n\n\n[\nphases.setup\n]\n\n\nnixPkgs\n \n=\n \n[\n'...'\n,\n \n'erlang'\n]\n\n\n\n\n[\nphases.install\n]\n\n\ncmds\n \n=\n \n[\n\n\n  \n'mix local.hex --force'\n,\n\n\n  \n'mix local.rebar --force'\n,\n\n\n  \n'mix deps.get --only prod'\n\n\n]\n\n\n\n\n[\nphases.build\n]\n\n\ncmds\n \n=\n \n[\n\n\n  \n'mix compile'\n,\n\n\n  \n'mkdir -p _build/prod/rel/helloworld_distillery/releases/RELEASES'\n,\n\n\n  \n'mix do phx.digest, distillery.release --env=prod'\n,\n\n\n]\n\n\n\n\n[\nstart\n]\n\n\ncmd\n \n=\n \n\"mix ecto.setup && _build/prod/rel/helloworld_distillery/bin/helloworld_distillery foreground\"\n\n\nThis \nnixpacks.toml\n file\n instructs Railway to execute specific commands during the setup, install, build, and start phases of the deployment. It ensures your app is compiled, assets are digested, and the release is created correctly using Distillery.\n\n\nDeploy Phoenix App to Railway\n\n\nRailway offers multiple ways to deploy your Phoenix app, depending on your setup and preference. Choose any of the following methods:\n\n\n\n\nOne-click deploy from a template\n.\n\n\nUsing the CLI\n.\n\n\nFrom a GitHub repository\n.\n\n\n\n\nOne-Click Deploy from a Template\n\n\nIf youâ€™re looking for the fastest way to get started, the one-click deploy option is ideal. It sets up a Phoenix app with Distillery along with a Postgres database.\n\n\nClick the button below to begin:\n\n\n\n\nAfter deploying, we recommend that you \neject from the template\n to create a copy of the repository under your own GitHub account. This will give you full control over the source code and project.\n\n\nDeploy from the CLI\n\n\nTo deploy the Phoenix app using the Railway CLI, please follow the steps:\n\n\n\n\n\n\nInstall the Railway CLI\n:\n\n\n\n\nInstall the CLI\n and \nauthenticate it\n using your Railway account.\n\n\n\n\n\n\n\n\nInitialize a Railway Project\n:\n\n\n\n\nRun the command below in your Phoenix app directory.\n\nrailway init\n\n\n\n\nFollow the prompts to name your project.\n\n\nAfter the project is created, click the provided link to view it in your browser.\n\n\n\n\n\n\n\n\nDeploy the Application\n:\n\n\n\n\nUse the command below to deploy your app:\n\nrailway up\n\n\n\n\nThis command will scan, compress and upload your app's files to Railway. Youâ€™ll see real-time deployment logs in your terminal.\n\n\n\n\nNote:\n You might encounter an errorâ€“â€“\nwarning: the VM is running with native name encoding of latin1 which\n \nmay cause Elixir to malfunction as it expects utf8....\n. Donâ€™t worry, weâ€™ll address this in the next step.\n\n\n\n\n\n\nAdd a Database Service\n:\n\n\n\n\nRun \nrailway add\n.\n\n\nSelect \nPostgreSQL\n by pressing space and hit \nEnter\n to add it to your project.\n\n\nA database service will be added to your Railway project.\n\n\n\n\n\n\n\n\nConfigure Environment Variables\n:\n\n\n\n\nGo to your app service \nVariables\n section and add the following:\n\n\n\nSECRET_KEY_BASE\n : Set the value to the your app's secret key. You can run \nmix phx.gen.secret\n locally to generate one.\n\n\nLANG\nand \nLC_CTYPE\n: Set both values to \nen_US.UTF-8\n. This sets your app's locale and gets rid of the \nnative name encoding of latin1\n warning.\n\n\nDATABASE_URL\n: Set the value to \n${{Postgres.DATABASE_URL}}\n (this references the URL of your new Postgres database). Learn more about \nreferencing service variables\n.\n\n\nECTO_IPV6\n: Set the value to \ntrue\n to enable your Phoenix app to connect to the database through the \nIPv6 private network\n.\n\n\n\n\n\n\nUse the \nRaw Editor\n to add any other required environment variables in one go.\n\n\n\n\n\n\n\n\nRedeploy the Service\n:\n\n\n\n\nClick \nDeploy\n on the Railway Project Canvas to apply your changes.\n\n\n\n\n\n\n\n\nVerify the Deployment\n:\n\n\n\n\nOnce the deployment completes, go to \nView logs\n to check if the server is running successfully.\n\n\n\n\n\n\n\n\nSet Up a Public URL\n:\n\n\n\n\nNavigate to the \nNetworking\n section under the \nSettings\n tab of your new service.\n\n\nClick \nGenerate Domain\n to create a public URL for your app.\n\n\n\n\n\n\n\n\n\n\nDeploy from a GitHub Repo\n\n\nTo deploy the Phoenix app to Railway, start by pushing the app to a GitHub repo. Once thatâ€™s set up, follow the steps below to complete the deployment process.\n\n\n\n\n\n\nCreate a New Project on Railway\n:\n\n\n\n\nGo to \nRailway\n to create a new project.\n\n\n\n\n\n\n\n\nDeploy from GitHub\n:\n\n\n\n\nSelect \nDeploy from GitHub repo\n and choose your repository.\n\n\n\nIf your Railway account isnâ€™t linked to GitHub yet, youâ€™ll be prompted to do so.\n\n\n\n\n\n\n\n\n\n\n\n\nAdd Environment Variables and Provision a Database Service\n:\n\n\n\n\nClick \nAdd Variables\n, but hold off on adding anything just yet. First, proceed with the next step.\n\n\nRight-click on the Railway project canvas or click the \nCreate\n button, then select \nDatabase\n and choose \nAdd PostgreSQL\n. This will create and deploy a new PostgreSQL database for your project.\n\n\nOnce the database is deployed, you can return to adding the necessary environment variables:\n\n\n\nSECRET_KEY_BASE\n : Set the value to the your app's secret key. You can run \nmix phx.gen.secret\n locally to generate one.\n\n\nLANG\nand \nLC_CTYPE\n: Set both values to \nen_US.UTF-8\n to ensure proper locale settings and avoid the \nnative name encoding of latin1 warning\n.\n\n\nDATABASE_URL\n: Set the value to \n${{Postgres.DATABASE_URL}}\n (this references the URL of your new Postgres database). Learn more about \nreferencing service variables\n.\n\n\nECTO_IPV6\n: Set the value to \ntrue\n to enable your Phoenix app to connect to the database through the \nIPv6 private network\n.\n\n\n\n\n\n\n\n\n\n\n\n\nDeploy the App Service\n:\n\n\n\n\nClick \nDeploy\n on the Railway project canvas to apply your changes.\n\n\n\n\n\n\n\n\nVerify the Deployment\n:\n\n\n\n\nOnce the deployment completes, go to \nView logs\n to check if the server is running successfully.\n\n\n\n\nNote:\n During the deployment process, Railway will automatically \ndetect that itâ€™s an Elixir app\n.\n\n\n\n\n\n\nSet Up a Public URL\n:\n\n\n\n\nNavigate to the \nNetworking\n section under the \nSettings\n tab of your new service.\n\n\nClick \nGenerate Domain\n to create a public URL for your app.\n\n\n\n\n\n\n\n\nThis guide covers the main deployment options on Railway. Choose the approach that suits your setup, and start deploying your Phoenix apps with Distillery effortlessly!\n\n\nNext Steps\n\n\nExplore these resources to learn how you can maximize your experience with Railway:\n\n\n\n\nMonitoring\n\n\nDeployments\n\n\nPrev\n \nPhoenix\nNext\n \nNetworking\nEdit this file on GitHub\nOn This Page\nCreate a Phoenix App with Distillery\nConfigure Database\nAdd and Configure Distillery\nBuild the Release with Distillery\nHandling Errors\nSuccessful Build\nTest the Release with Distillery locally\nPrepare App for Deployment\nDeploy Phoenix App to Railway\nOne-Click Deploy from a Template\nDeploy from the CLI\nDeploy from a GitHub Repo\nNext Steps"
  },
  {
    "url": "https://docs.railway.app/guides/play",
    "title": "Deploy a Scala Play App | Railway Docs",
    "content": "Deploy a Scala Play App\nPlay\n is a high velocity and productive web framework for Java and Scala. It is based on a lightweight, stateless, web-friendly architecture and features predictable and minimal resource consumption (CPU, memory, threads) for highly-scalable applications thanks to its reactive model, based on Pekko Streams.\n\n\nThis guide covers how to deploy a Scala Play app to Railway in four ways:\n\n\n\n\nOne-click deploy from a template\n.\n\n\nFrom a GitHub repository\n.\n\n\nUsing the CLI\n.\n\n\nUsing a Dockerfile\n.\n\n\n\n\nNow, let's create a Play app!\n\n\nCreate a Play App\n\n\nNote:\n If you already have a Play app locally or on GitHub, you can skip this step and go straight to the \nDeploy Play App to Railway\n.\n\n\nTo create a new Scala Play app, ensure that you have \nJDK\n and \nsbt\n installed on your machine.\n\n\nRun the following command in your terminal to create a new Play app:\n\n\nsbt new\n\n\nA list of templates will be shown to select from. Select the \nplayframework/play-scala-seed.g8\n template.\n\n\n\n\nGive it a name, \nhelloworld\n.\n\n\nGive it an organization name, \ncom.railwayguide\n\n\nHit Enter for the rest to use the latest versions of play, scala and sbt scaffold.\n\n\n\n\nA new Scala Play app will be provisioned in the \nhelloworld\n directory.\n\n\nModify Scala Play Views and Set Up Database Config\n\n\nStep 1\n : Modify the Index File\n\n\nOpen the project in your editor. Head over to the \napp/views/index.scala.html\n file.\n\n\nModify it to the following:\n\n\n@\n(\n)\n\n\n\n\n@main\n(\n\"Welcome to Play\"\n)\n \n{\n\n\n  \n<\nh1\n>\nWelcome to Play\n!\n<\n/\nh1\n>\n\n\n  \n<\nh1\n>\nHello World\n,\n Railway\n!\n<\n/\nh1\n>\n\n\n}\n\n\nThis change adds a new heading, which you'll see when you run the app locally.\n\n\nStep 2\n : Run the App Locally\n\n\n\n\nNow, letâ€™s run the app locally to verify our changes. You should see the new headers appear in the browser.\n\n\n\n\nStep 3\n : Add PostgreSQL Driver as a Dependency\n\n\nPlay doesnâ€™t provide built-in database drivers, so we need to add the PostgreSQL JDBC driver manually to our project.\n\n\nIn your \nbuild.sbt\n, add the following dependency:\n\n\nlibraryDependencies \n+=\n \n\"org.postgresql\"\n \n%\n \n\"postgresql\"\n \n%\n \n\"42.7.4\"\n \n// Always use the latest stable version\n\n\nStep 4\n : Configure PostgreSQL in application.conf\n\n\nNext, configure the PostgreSQL database connection in \nconf/application.conf\n:\n\n\n# Default database configuration using PostgreSQL\n\ndb\n.\ndefault\n.\ndriver \n=\n org\n.\npostgresql\n.\nDriver\n\ndb\n.\ndefault\n.\nurl \n=\n \n\"jdbc:postgresql://username:password@127.0.0.1:5432/scala_play\"\n  # Replace \nwith\n \ncorrect\n credentials\n\n\nMake sure to replace \nusername\n and \npassword\n with your PostgreSQL credentials.\n\n\nStep 5\n : Update Project Dependencies\n\n\nTo download the PostgreSQL driver and any updated dependencies, run the following:\n\n\nsbt update\n\n\nStep 6\n : Add Database Migration Tool (Flyway)\n\n\nPlay doesnâ€™t include built-in support for database migrations, so weâ€™ll use Flyway.\n\n\n\n\nInstall Flyway Plugin: Open your \nproject/plugin.sbt\n and add the Flyway plugin:\n\n\n\n\naddSbtPlugin\n(\n\"io.github.davidmweber\"\n \n%\n \n\"flyway-sbt\"\n \n%\n \n\"7.4.0\"\n)\n\n\n\n\nConfigure Flyway in \nbuild.sbt\n: Enable Flyway and configure the database connection in your \nbuild.sbt\n:\n\n\n\n\nname \n:\n=\n \n\"\"\"helloworld\"\"\"\n\n\norganization \n:\n=\n \n\"com.railwayguide\"\n\n\nversion \n:\n=\n \n\"1.0-SNAPSHOT\"\n\n\nexecutableScriptName \n:\n=\n \n\"main\"\n\n\n\n\nlazy\n \nval\n root \n=\n \n(\nproject in file\n(\n\".\"\n)\n)\n.\nenablePlugins\n(\nPlayScala\n)\n.\nenablePlugins\n(\nFlywayPlugin\n)\n\n\n\n\nscalaVersion \n:\n=\n \n\"2.13.15\"\n\n\n\n\nlibraryDependencies \n+=\n guice\n\nlibraryDependencies \n+=\n \n\"org.scalatestplus.play\"\n \n%\n%\n \n\"scalatestplus-play\"\n \n%\n \n\"7.0.1\"\n \n%\n Test\n\nlibraryDependencies \n+=\n \n\"org.postgresql\"\n \n%\n \n\"postgresql\"\n \n%\n \n\"42.7.4\"\n \n// Latest version\n\n\n\n\nflywayUrl \n:\n=\n \n\"jdbc:postgresql://127.0.0.1:5432/scala_play?user=<username>\"\n  # Replace \nwith\n \ncorrect\n credentials\n\nflywayLocations \n:\n=\n Seq\n(\n\"filesystem:src/main/resources/db/migration\"\n)\n\n\nReplace \nusername\n with your database username.\n\n\nStep 7\n : Create the Migration Files\n\n\n\n\nCreate Migration Folder\n: Create the folder structure for your migration files:\n\n\n\n\nsrc/main/resources/db/migration\n\n\n\n\nCreate Migration SQL File\n: In \nsrc/main/resources/db/migration\n, create a schema migration file called \nV1_0__create_employees_table.sql\n with the following content:\n\n\n\n\nCREATE TABLE employee (\n\n  id VARCHAR(20) PRIMARY KEY,\n  first_name VARCHAR(30),\n  last_name VARCHAR(30),\n  email VARCHAR(30),\n  admin BOOLEAN\n);\n\n\nStep 8\n : Run Database Migrations\n\n\nOnce your migration file is in place, run the Flyway migration with the following command:\n\n\nsbt flywayMigrate\n\n\nThis will apply the migration and create the employee table in your PostgreSQL database.\n\n\nCheck your database to confirm that the employee table has been successfully created. You can use a database tool like psql or any PostgreSQL client to view the table.\n\n\nRun the Play App locally\n\n\nNext, run \nsbt run\n in the terminal to build the project, install all the dependencies and start the embedded \nPekko\n HTTP server.\n\n\nOpen your browser and go to \nhttp://localhost:9000\n to see the app.\n\n\nPrepare Scala Play App for deployment\n\n\n\n\nSet Application Secret\n:\n\n\n\nOpen up the \napplication.conf\n file and add the following to it to set the app's secret.\n\nplay\n.\nhttp\n.\nsecret\n.\nkey\n=\n$\n{\n?\nAPPLICATION_SECRET\n}\n\n\n\n\n\n\n\n\nSet Database URL\n:\n\n\n\nOpen up the \napplication.conf\n file and add the following to it to ensure the \nDATABASE_URL\n is read from the environment variable.\n\ndb\n.\ndefault\n.\nurl\n=\n\"jdbc:${?DATABASE_URL}\"\n\n\n\n\n\n\n\n\nSet Allowed Hosts\n:\n\n\n\nBy default, Play ships with a list of \ndefault Allowed Hosts filter\n. This is the list of allowed valid hosts = [\"localhost\", \".local\", \"127.0.0.1\"]. You need to add an option to allow Railway hosts, \n[\".up.railway.app\"]\n.\n\n\nAdd the following to the \napplication.conf\n file:\n\nplay\n.\nfilters\n.\nhosts\n.\nallowed\n=\n[\n\".up.railway.app\"\n]\n\n\n\n\n\n\nNote:\n Railway provided domains end in \n.up.railway.app\n. Once you add your custom domain, please update the allowed hosts to the new URL.\n\n\nAdd sbt-native-packager sbt plugin\n:\n\n\n\nAdd the \nsbt-native-packager\n sbt plugin to \nproject/plugins.sbt\n\n\naddSbtPlugin\n(\n\"com.github.sbt\"\n \n%\n \n\"sbt-native-packager\"\n \n%\n \n\"x.x.x\"\n)\n\n\n\n\nEnable the \nJavaAppPackaging\n plugin in \nbuild.sbt\n and set the \nexecutableScriptName\n to \nmain\n. Your \nbuild.sbt\n should be looking like this now:\n\nname \n:\n=\n \n\"\"\"helloworld\"\"\"\n\n\norganization \n:\n=\n \n\"com.railwayguide\"\n\n\n\n\nversion \n:\n=\n \n\"1.0-SNAPSHOT\"\n\n\n\n\nexecutableScriptName \n:\n=\n \n\"main\"\n\n\n\n\nlazy\n \nval\n root \n=\n \n(\nproject in file\n(\n\".\"\n)\n)\n.\nenablePlugins\n(\nPlayScala\n)\n.\nenablePlugins\n(\nJavaAppPackaging\n)\n.\nenablePlugins\n(\nFlywayPlugin\n)\n\n\n\n\nscalaVersion \n:\n=\n \n\"2.13.15\"\n\n\n\n\nlibraryDependencies \n+=\n guice\n\nlibraryDependencies \n+=\n \n\"org.scalatestplus.play\"\n \n%\n%\n \n\"scalatestplus-play\"\n \n%\n \n\"7.0.1\"\n \n%\n Test\n\nlibraryDependencies \n+=\n \n\"org.postgresql\"\n \n%\n \n\"postgresql\"\n \n%\n \n\"42.7.4\"\n \n// Always use the latest stable version\n\n\n\n\nflywayUrl \n:\n=\n sys\n.\nenv\n.\ngetOrElse\n(\n\"DATABASE_URL\"\n,\n \n\"jdbc:postgresql://127.0.0.1:5432/scala_play?user=username\"\n)\n\n\n\n\nflywayLocations \n:\n=\n Seq\n(\n\"filesystem:src/main/resources/db/migration\"\n)\n\n\n\n\nRun \nsbt update\n to install the \nsbt-native-packager\n and update the dependencies.\n\n\n\n\n\n\n\n\nNow, we are ready to deploy to Railway!\n\n\nDeploy the Play App to Railway\n\n\nRailway offers multiple ways to deploy your Scala app, depending on your setup and preference.\n\n\nOne-Click Deploy from a Template\n\n\nIf youâ€™re looking for the fastest way to get started, the one-click deploy option is ideal.\n\n\nClick the button below to begin:\n\n\n\n\nWe highly recommend that \nyou eject from the template after deployment\n to create a copy of the repo on your GitHub account.\n\n\nNote:\n You can also choose from a \nvariety of Scala app templates\n created by the community.\n\n\nDeploy from the CLI\n\n\n\n\nInstall the Railway CLI\n:\n\n\n\nInstall the CLI\n and \nauthenticate it\n using your Railway account.\n\n\n\n\n\n\nInitialize a Railway Project\n:\n\n\n\nRun the command below in your Luminus app directory.\n\nrailway init\n\n\n\n\nFollow the prompts to name your project.\n\n\nAfter the project is created, click the provided link to view it in your browser.\n\n\n\n\n\n\nAdd a Postgres Database Service\n:\n\n\n\nRun \nrailway add -d postgres\n.\n\n\nHit \nEnter\n to add it to your project.\n\n\nA database service will be added to your Railway project.\n\n\n\n\n\n\nAdd a Service and Environment Variable\n:\n\n\n\nRun \nrailway add\n.\n\n\nSelect \nEmpty Service\n from the list of options.\n\n\nIn the \nEnter a service name\n prompt, enter \napp-service\n.\n\n\nIn the \nEnter a variable\n prompt, enter \nAPPLICATION_SECRET=<generated-app-secret>\n where \n<generated-app-secret>\n is the secret generated from running \nplayGenerateSecret\n in your terminal.\n\n\nIn the \nEnter a variable\n prompt, enter \nDATABASE_URL=${{Postgres.DATABASE_URL}}\n.\n\n\n\nThe value, \n${{Postgres.DATABASE_URL}}\n, references the URL of your new Postgres database. Learn more about \nreferencing service variables\n.\n\n\n\n\n\n\n\n\nNote:\n Explore the \nRailway CLI reference\n for a variety of options.\n\n\nDeploy the Application\n:\n\n\n\nRun \nrailway up\n to deploy your app.\n\n\n\nThis command will scan, compress and upload your app's files to Railway. Youâ€™ll see real-time deployment logs in your terminal.\n\n\n\n\n\n\nOnce the deployment is complete, we can proceed to generate a domain for the app service.\n\n\n\n\n\n\nSet Up a Public URL\n:\n\n\n\nRun \nrailway domain\n to generate a public URL for your app.\n\n\nVisit the new URL to see your app live in action!\n\n\n\n\n\n\n\n\n\n\nDeploy from a GitHub Repo\n\n\nTo deploy a Scala Play app to Railway directly from GitHub, follow the steps below:\n\n\n\n\n\n\nCreate a New Project on Railway\n:\n\n\n\n\nGo to \nRailway\n to create a new project.\n\n\n\n\n\n\n\n\nDeploy from GitHub\n:\n\n\n\n\nSelect \nDeploy from GitHub repo\n and choose your repository.\n\n\n\nIf your Railway account isnâ€™t linked to GitHub yet, youâ€™ll be prompted to do so.\n\n\n\n\n\n\n\n\n\n\n\n\nAdd Environment Variables and Provision a Database Service\n:\n\n\n\n\nClick \nAdd Variables\n, but hold off on adding anything just yet. First, proceed with the next step.\n\n\nRight-click on the Railway project canvas or click the \nCreate\n button, then select \nDatabase\n and choose \nAdd PostgreSQL\n.\n\n\n\nThis will create and deploy a new PostgreSQL database for your project.\n\n\n\n\n\n\nOnce the database is deployed, you can return to adding the necessary environment variables:\n\n\n\nDATABASE_URL\n: Set the value to \n${{Postgres.DATABASE_URL}}\n (this references the URL of your new Postgres database). Learn more about \nreferencing service variables\n.\n\n\nAPPLICATION_SECRET\n: Set the value to the generated app secret.\n\n\n\n\n\n\n\n\n\n\n\n\nDeploy the App Service\n:\n\n\n\n\nClick \nDeploy\n on the Railway project canvas to apply your changes.\n\n\n\n\n\n\n\n\nVerify the Deployment\n:\n\n\n\n\nOnce the deployment completes, go to \nView logs\n to check if the server is running successfully.\n\n\n\n\nNote:\n During the deployment process, Railway will automatically \ndetect that itâ€™s a Scala app\n.\n\n\n\n\n\n\nSet Up a Public URL\n:\n\n\n\n\nNavigate to the \nNetworking\n section under the \nSettings\n tab of your new service.\n\n\nClick \nGenerate Domain\n to create a public URL for your app.\n\n\n\n\n\n\n\n\nUse a Dockerfile\n\n\n\n\nCreate a \nDockerfile\n in the Play app's root directory.\n\n\nAdd the content below to the \nDockerfile\n:\n\n# Use the Scala sbt official image\n\n\n# https://hub.docker.com/r/sbtscala/scala-sbt/tags\n\n\nFROM sbtscala/scala-sbt:eclipse-temurin-21.0.5_11_1.10.5_3.5.2\n\n\n# Create and change to the app directory.\n\n\nWORKDIR /app\n\n\n# Copy local code to the container image.\n\n\nCOPY \n.\n ./\n\n\n\n# Build the app.\n\n\nRUN sbt stage\n\n\n# Run the app\n\n\nCMD \n[\n\"./target/universal/stage/bin/main\"\n]\n\n\n\n\nEither deploy via the CLI or from GitHub.\n\n\n\n\nRailway automatically detects the \nDockerfile\n, \nand uses it to build and deploy the app.\n\n\nNote:\n Railway supports also \ndeployment from public and private Docker images\n.\n\n\nThis guide covers the main deployment options on Railway. Choose the approach that suits your setup, and start deploying your Scala apps seamlessly!\n\n\nNext Steps\n\n\nExplore these resources to learn how you can maximize your experience with Railway:\n\n\n\n\nAdd a Database Service\n\n\nMonitor your app\n\n\nPrev\n \nLuminus\nNext\n \nSails\nEdit this file on GitHub\nOn This Page\nCreate a Play App\nModify Scala Play Views and Set Up Database Config\nRun the Play App locally\nPrepare Scala Play App for deployment\nDeploy the Play App to Railway\nOne-Click Deploy from a Template\nDeploy from the CLI\nDeploy from a GitHub Repo\nUse a Dockerfile\nNext Steps"
  },
  {
    "url": "https://docs.railway.app/guides/postgresql",
    "title": "PostgreSQL | Railway Docs",
    "content": "PostgreSQL\nThe Railway PostgreSQL database template allows you to provision and connect to a PostgreSQL database with zero configuration.\n\n\nDeploy\n\n\nAdd a PostgreSQL database to your project via the \nctrl / cmd + k\n menu or by clicking the \n+ New\n button on the Project Canvas.\n\n\n\n\nYou can also deploy it via the \ntemplate\n from the template marketplace.\n\n\nDeployed Service\n\n\nUpon deployment, you will have a PostgreSQL service running in your project, deployed from Railway's \nSSL-enabled Postgres image\n, which uses the official \nPostgres\n image from Docker Hub as its base.\n\n\nConnect\n\n\nConnect to the PostgreSQL server from another service in your project by \nreferencing the environment variables\n made available in the PostgreSQL service:\n\n\n\n\nPGHOST\n\n\nPGPORT\n\n\nPGUSER\n\n\nPGPASSWORD\n\n\nPGDATABASE\n\n\nDATABASE_URL\n\n\n\n\nNote, Many libraries will automatically look for the \nDATABASE_URL\n variable and use\nit to connect to PostgreSQL but you can use these variables in whatever way works for you.\n\n\nConnecting Externally\n\n\nIt is possible to connect to PostgreSQL externally (from outside of the \nproject\n in which it is deployed), by using the \nTCP Proxy\n which is enabled by default.\n\n\nKeep in mind that you will be billed for \nNetwork Egress\n when using the TCP Proxy.\n\n\nModify the Deployment\n\n\nSince the deployed container is based on an image built from the official \nPostgreSQL\n image in Docker hub, you can modify the deployment based on the \ninstructions in Docker hub\n.\n\n\nWe also encourage you to fork the \nRailway postgres-ssl repository\n to customize it to your needs, or feel free to open a PR in the repo!\n\n\nBackups and Observability\n\n\nEspecially for production environments, performing regular backups and monitoring the health of your database is essential.  Consider adding:\n\n\n\n\n\n\nBackups\n: Automate regular backups to ensure data recovery in case of failure. We suggest checking out our native \nBackups\n feature.\n\n\n\n\n\n\nObservability\n: Implement monitoring for insights into performance and health of your databases.  If you're not already running an observability stack, check out these templates to help you get started building one:\n\n\n\n\nPrometheus\n\n\nGrafana\n\n\nPostgreSQL Exporter\n\n\n\n\n\n\n\n\nExtensions\n\n\nIn an effort to maintain simplicity in the default templates, we do not plan to add extensions to the PostgreSQL templates covered in this guide.\n\n\nFor some of the most popular extensions, like PostGIS and Timescale, there are several options in the template marketplace.\n\n\n\n\n\n\nTimescaleDB\n\n\n\n\n\n\nPostGIS\n\n\n\n\n\n\nTimescaleDB + PostGIS\n\n\n\n\n\n\npgvector\n\n\n\n\n\n\nModifying The Postgres Configuration\n\n\nYou can modify the Postgres configuration by using the \nALTER SYSTEM\n command.\n\n\nALTER SYSTEM SET shared_buffers = '2GB';\n\nALTER SYSTEM SET effective_cache_size = '6GB';\n\nALTER SYSTEM SET maintenance_work_mem = '512MB';\n\nALTER SYSTEM SET work_mem = '32MB';\n\nALTER SYSTEM SET max_worker_processes = '8';\n\nALTER SYSTEM SET max_parallel_workers_per_gather = '4';\n\nALTER SYSTEM SET max_parallel_workers = '8';\n\n\n\n-- Reload the configuration to save the changes\n\nSELECT pg_reload_conf();\n\n\nAfter running the SQL, you will need to restart the deployment for the changes to take effect.\n\n\nYou can restart the deployment by clicking the \nRestart\n button in the deployment's 3-dot menu.\n\n\nIncreasing the SHM Size\n\n\nThe SHM Size is the maximum amount of shared memory available to the container.\n\n\nBy default it is set to 64MB.\n\n\nYou would need to change the SHM Size if you are experiencing the following error -\n\n\nERROR: could not resize shared memory segment \"PostgresSQL.1590182853\" to 182853 bytes: no space left on device\n\n\nYou can modify the SHM Size by setting the \nRAILWAY_SHM_SIZE_BYTES\n variable in your service variables.\n\n\nThis variable is a number in bytes, so you would need to convert the size you want to use.\n\n\nFor example, to increase the SHM Size to 500MB, you would set the variable to \n524288000\n.\n\n\nAdditional Resources\n\n\nWhile these templates are available for your convenience, they are considered unmanaged, meaning you have total control over their configuration and maintenance.\n\n\nWe \nstrongly encourage you\n to refer to the source documentation to gain deeper understanding of their functionality and how to use them effectively.  Here are some links to help you get started:\n\n\n\n\nPostgreSQL Documentation\n\n\nPostgreSQL High Availability Documentation\n\n\nRepmgr Documentation\n\n\nPgpool-II Documentation\n\n\nPrev\n \nBuild a Database Service\nNext\n \nMySQL\nEdit this file on GitHub\nOn This Page\nDeploy\nConnect\nConnecting Externally\nModify the Deployment\nBackups and Observability\nExtensions\nModifying The Postgres Configuration\nIncreasing the SHM Size\nAdditional Resources"
  },
  {
    "url": "https://docs.railway.app/guides/pre-deploy-command",
    "title": "Add a Pre-Deploy Command | Railway Docs",
    "content": "Add a Pre-Deploy Command\nPre-deploy commands execute between building and deploying your application, handling tasks like database migrations or data seeding before your application runs.\nThey execute within your private network and have access to your application's environment variables.\n\n\nIf your command fails, it will not be retried and the deployment will not proceed.\n\n\n\n\nFor pre-deploy commands to work correctly, ensure that:\n\n\n\n\nIt exits with a status code of \n0\n to indicate success or non-zero to indicate failure.\n\n\nIt runs in a reasonable amount of time. It will occupy a slot in your build queue.\n\n\nIt does not rely on the application running.\n\n\nIt has the dependencies it needs to run installed in the application image.\n\n\nIt does not attempt to read or write data to the volume or filesystem, that should instead be done as part of the start command.\n\n\n\n\nPre-deploy commands execute in a separate container from your application. Changes to the filesystem are not persisted and \nvolumes\n are not mounted.\nPrev\n \nDeployments\nNext\n \nStart Command\nEdit this file on GitHub"
  },
  {
    "url": "https://docs.railway.app/guides/private-networking",
    "title": "Private Networking | Railway Docs",
    "content": "Private Networking\nPrivate Networking is a feature within Railway that allows you to have a private network between your services, helpful for situations where you want to have a public gateway for your API but leave internal communication private.\n\n\n\n\nBy default, all projects have private networking enabled and services will get a new DNS name under the \nrailway.internal\n domain. This DNS name will resolve to the internal IPv6 address of the services within a project.\n\n\nCommunicating Over the Private Network\n\n\nTo communicate over the private network, there are some specific things to know to be successful.\n\n\nListen on IPv6\n\n\nSince the private network is an IPv6 only network, applications that will receive requests over the private network must be configured to listen on IPv6. On most web frameworks, you can do this by binding to the host \n::\n.\n\n\nSome examples are below -\n\n\nNode / Express\n\n\nListen on \n::\n to bind to both IPv4 and IPv6.\n\n\nconst\n port \n=\n process\n.\nenv\n.\nPORT\n \n||\n \n3000\n;\n\n\n\n\napp\n.\nlisten\n(\nport\n,\n \n'::'\n,\n \n(\n)\n \n=>\n \n{\n\n\n    console\n.\nlog\n(\n`\nServer listening on [::]\n${\nport\n}\n`\n)\n;\n\n\n}\n)\n;\n\n\nNode / Nest\n\n\nListen on \n::\n to bind to both IPv4 and IPv6.\n\n\nconst\n port \n=\n process\n.\nenv\n.\nPORT\n \n||\n \n3000\n;\n\n\n\n\nasync\n \nfunction\n \nbootstrap\n(\n)\n \n{\n\n\n  \nawait\n app\n.\nlisten\n(\nport\n,\n \n'::'\n)\n;\n\n\n}\n\n\nNode / Next\n\n\nUpdate your start command to bind to both IPv4 and IPv6.\n\n\nnext start --hostname :: --port \n${PORT-3000}\n\n\nOr if you are using a custom server, set \nhostname\n to \n::\n in the configuration object passed to the \nnext()\n function.\n\n\nconst\n port \n=\n process\n.\nenv\n.\nPORT\n \n||\n \n3000\n;\n\n\n\n\nconst\n app \n=\n \nnext\n(\n{\n\n\n  \n// ...\n\n\n  \nhostname\n:\n \n'::'\n,\n\n\n  \nport\n:\n port\n\n}\n)\n;\n\n\nIf neither of these options are viable, you can set a \nHOSTNAME\n \nservice variable\n with the value \n::\n to listen on both IPv4 and IPv6.\n\n\nPython / Gunicorn\n\n\nUpdate your start command to bind to both IPv4 and IPv6.\n\n\ngunicorn app:app --bind \n[\n::\n]\n:\n${PORT-3000}\n\n\nPython / Hypercorn\n\n\nUpdate your start command to bind to both IPv4 and IPv6.\n\n\nhypercorn app:app --bind \n[\n::\n]\n:\n${PORT-3000}\n\n\nPython / Uvicorn\n\n\nUpdate your start command to bind to IPv6.\n\n\nuvicorn app:app --host :: --port \n${PORT-3000}\n\n\nNote:\n If your application needs to be accessible over both private and public networks, your application server must support dual stack binding. Most servers handle this automatically when listening on \n::\n, but some, like Uvicorn, do not.\n\n\nUse Internal Hostname and Port\n\n\nFor applications making requests to a service over the private network, you should use the internal DNS name of the service, plus the \nPORT\n on which the service is listening.\n\n\nFor example, if you have a service called \napi\n listening on port 3000, and you want to communicate with it from another service, you would use \napi.railway.internal\n as the hostname and specify the port -\n\n\napp\n.\nget\n(\n'/fetch-secret'\n,\n \nasync\n \n(\nreq\n,\n res\n)\n \n=>\n \n{\n\n\n    axios\n.\nget\n(\n'http://api.railway.internal:3000/secret'\n)\n\n\n    \n.\nthen\n(\nresponse\n \n=>\n \n{\n\n\n        res\n.\njson\n(\nresponse\n.\ndata\n)\n;\n\n\n    \n}\n)\n\n\n}\n)\n\n\nNote that you should use \nhttp\n in the address.\n\n\nUsing Reference Variables\n\n\nUsing \nreference variables\n, you can accomplish the same end as the above example.\n\n\nLet's say you are setting up your frontend service to talk to the \napi\n service.  In the frontend service, set the following variable -\n\n\nBACKEND_URL\n=\nhttp://\n${{api.RAILWAY_PRIVATE_DOMAIN}\n}\n:\n${{api.PORT}\n}\n\n\napi.PORT\n above refers to a service variable that must be set manually. It does not automatically resolve to the port the service is listening on, nor does it resolve to the \nPORT\n environment variable injected into the service at runtime.\n\n\nThen in the frontend code, you will simply reference the \nBACKEND_URL\n environment variable -\n\n\napp\n.\nget\n(\n'/fetch-secret'\n,\n \nasync\n \n(\nreq\n,\n res\n)\n \n=>\n \n{\n\n\n    axios\n.\nget\n(\n`\n${\nprocess\n.\nenv\n.\nBACKEND_URL\n}\n/secret\n`\n)\n\n\n    \n.\nthen\n(\nresponse\n \n=>\n \n{\n\n\n        res\n.\njson\n(\nresponse\n.\ndata\n)\n;\n\n\n    \n}\n)\n\n\n}\n)\n\n\nPrivate Network Context\n\n\nThe private network exists in the context of a project and environment and is not accessible over the public internet.  In other words -\n\n\n\n\nA web application that makes client-side requests \ncannot\n communicate to another service over the private network.\n\n\nServices in one project/environment \ncannot\n communicate with services in another project/environment over the private network.\n\n\n\n\nCheck out the \nFAQ\n section for more information.\n\n\nKnown Configuration Requirements for IPv6\n\n\nSome libraries and components require you to be explicit when either listening or establishing a connection over IPv6.\n\n\nioredis\nioredis\n is a Redis client for node.js, commonly used for connecting to Redis from a node application.\nWhen initializing a Redis client using \nioredis\n, you must specify \nfamily=0\n in the connection string to support connecting to both IPv6 and IPv4 endpoints:\nimport\n Redis \nfrom\n \n'ioredis'\n;\n\n\n\n\nconst\n redis \n=\n \nnew\n \nRedis\n(\nprocess\n.\nenv\n.\nREDIS_URL\n \n+\n \n'?family=0'\n)\n;\n\n\n\n\nconst\n ping \n=\n \nawait\n redis\n.\nping\n(\n)\n;\nioredis docs\n\n\nbullmq\nbullmq\n is a message queue and batch processing library for node.js, commonly used for processing jobs in a queue.\nWhen initializing a bullmq client, you must specify \nfamily: 0\n in the connection object to support connecting to both IPv6 and IPv4 Redis endpoints:\nimport\n \n{\n Queue \n}\n \nfrom\n \n\"bullmq\"\n;\n\n\n\n\nconst\n redisURL \n=\n \nnew\n \nURL\n(\nprocess\n.\nenv\n.\nREDIS_URL\n)\n;\n\n\n\n\nconst\n queue \n=\n \nnew\n \nQueue\n(\n\"Queue\"\n,\n \n{\n\n\n    \nconnection\n:\n \n{\n\n\n        \nfamily\n:\n \n0\n,\n\n\n        \nhost\n:\n redisURL\n.\nhostname\n,\n\n\n        \nport\n:\n redisURL\n.\nport\n,\n\n\n        \nusername\n:\n redisURL\n.\nusername\n,\n\n\n        \npassword\n:\n redisURL\n.\npassword\n\n    \n}\n\n\n}\n)\n;\n\n\n\n\nconst\n jobs \n=\n \nawait\n queue\n.\ngetJobs\n(\n)\n;\n\n\n\n\nconsole\n.\nlog\n(\njobs\n)\n;\nbullmq docs\n\n\nMongo Docker image\nIf you are creating a service using the official Mongo Docker image in Docker Hub and would like to connect to it over the private network, you must start the container with some options to instruct the Mongo instance to listen on IPv6. For example, this would be set in your \nStart Command\n:\ndocker-entrypoint.sh mongod --ipv6 --bind_ip ::,0.0.0.0\nNote that the official template provided by Railway is already deployed with this Start Command.\n\n\nhot-shots\nhot-shots\n is a StatsD client for node.js, which can be used to ship metrics to a DataDog agent for example.  When initializing a StatsD client using \nhot-shots\n, you must specify that it should connect over IPv6:\nconst\n StatsD \n=\n \nrequire\n(\n'hot-shots'\n)\n;\n\n\n\n\nconst\n statsdClient \n=\n \nnew\n \nStatsD\n(\n{\n\n\n  \nhost\n:\n process\n.\nenv\n.\nAGENT_HOST\n,\n\n\n  \nport\n:\n process\n.\nenv\n.\nAGENT_PORT\n,\n\n\n  \nprotocol\n:\n \n'udp'\n,\n\n\n  \ncacheDns\n:\n \ntrue\n,\n\n\n  \nudpSocketOptions\n:\n \n{\n\n\n    \ntype\n:\n \n'udp6'\n,\n\n\n    \nreuseAddr\n:\n \ntrue\n,\n\n\n    \nipv6Only\n:\n \ntrue\n,\n\n\n  \n}\n,\n\n\n}\n)\n;\nhot-shots docs\n\n\nGo Fiber\nfiber\n is a web framework for Go.  When configuring your Fiber app, you should set the Network field to \ntcp\n to have it listen on IPv6 as well as IPv4:\napp \n:=\n fiber\n.\nNew\n(\nfiber\n.\nConfig\n{\n\n\n    Network\n:\n       \n\"tcp\"\n,\n\n\n    ServerHeader\n:\n  \n\"Fiber\"\n,\n\n\n    AppName\n:\n \n\"Test App v1.0.1\"\n,\n\n\n}\n)\nFiber docs\n\n\nChanging the Service Name for DNS\n\n\nWithin the service settings you can change the service name to which you refer, e.g. \napi-1.railway.internal\n -> \napi-2.railway.internal\n\n\nThe root of the domain, \nrailway.internal\n, is static and \ncannot\n be changed.\n\n\nCaveats\n\n\nDuring the feature development process we found a few caveats that you should be aware of:\n\n\n\n\nPrivate networking is not available during the build phase.\n\n\nYou will need to bind to a IPv6 port to receive traffic on the private network.\n\n\nWe don't support IPv4 private networking\n\n\n\n\nFAQ\n\n\nWhat is a client side app, a server side app, and what kind of app am I running?\nIn the context of private networking, the key distinction between client- and server-side is from where requests are being made.\n\n\nIn client-side applications, requests to other resources (like other Railway services) are made from a browser, which exists on the public network and outside the private network.\n\n\nIn server-side applications, requests to other resources are made from the server hosting the application, which would exist within the private network (assuming the server hosting the app is in Railway).\n\n\nOne way to determine whether your application is making client- or server-side requests is by inspecting the request in the Network tab of DevTools.  If the RequestURL is the resource to which the request is being made, e.g. a backend server, this is a good indication that the browser itself is making the request (client-side).\n\n\nWhat if I am making a request server-side, but from Vercel?\nSince an application hosted on Vercel exists outside of the private network in Railway, requests coming from Vercel servers cannot be made over the private network.\nPrev\n \nPublic Networking\nNext\n \nBuilds\nEdit this file on GitHub\nOn This Page\nCommunicating Over the Private Network\nListen on IPv6\nNode / Express\nNode / Nest\nNode / Next\nPython / Gunicorn\nPython / Hypercorn\nPython / Uvicorn\nUse Internal Hostname and Port\nUsing Reference Variables\nPrivate Network Context\nKnown Configuration Requirements for IPv6\nChanging the Service Name for DNS\nCaveats\nFAQ"
  },
  {
    "url": "https://docs.railway.app/guides/projects",
    "title": "Managing Projects | Railway Docs",
    "content": "Managing Projects\nA Railway project contains any services, environments, and deployments that an app needs. Projects can be found on \nyour project dashboard\n.\n\n\nClick on a project card to go to the project canvas:\n\n\n\n\nProject settings can be managed through the \nSettings\n button at the top right of the project canvas.\n\n\nManaging Project Info\n\n\nA project's name and description can be changed from the General tab within a project's settings.\n\n\nThe project id can also be retrieved here.\n\n\nDeleting a Project\n\n\nA project can be deleted by selecting the \nDelete Project\n button in the Danger tab. Deleting a project will delete all services, environments, and deployments associated with the project.\n\n\nSpecific services within a project can also be deleted from this page.\n\n\nInviting Members\n\n\nInvite members to access a project through the Members tab in your Project Settings.\n\n\nYou can invite a member by sending an invitation to their email address, or by generating an invite link to send to them directly.\n\n\nClick \nhere\n to view the scope definitions for permissions.\n\n\nInvite by Email\n\n\nInvite a new member via email by specifying their email address and scope of permissions, then click \nInvite\n.\n\n\nThis will send an email to the address specified containing a link to join your project.\n\n\nInvite by Link\n\n\nEach project generates a project invite link. To invite someone via a link:\n\n\n\n\nSelect the desired invited member scope\n\n\nCopy link and send to the invitee\n\n\n\n\nTransferring Projects\n\n\nDepending on your plan, you can transfer Projects to other users or Teams.\n\n\nHobby User to Hobby User\n\n\nTo transfer a project from one Hobby User to another Hobby User, you must first \nadd the user as a member\n in the project.\n\n\nYou can then transfer the project to the new member by selecting the three dots next to the user and choosing \nTransfer Ownership\n.\n\n\n\n\nThe transferee receives an email requesting to transfer the project.\n\n\nHobby User to Team || Team to Team\n\n\nYou can transfer a Project in your Hobby workspace to a Team (or between Teams) in which you are an Admin.  Inside your project, visit the \nSettings\n page and click the \nTransfer Project\n button to view the project transfer modal.\n\n\n\n\nNote: If you do not see the Transfer Project section in your Project Settings, you may not be an Admin of the Team to which you wish to transfer the Project.  See the \nreference page for Teams\n for more information on team member permissions.\n\n\nViewing Recent Activity\n\n\nThe activity feed shows all the changes that have been made to a project. This includes changes to services and volumes. You can click on a change to see everything that was committed.\n\n\n\n\nUpdating Project Visibility\n\n\nProjects are private by default and only accessible to members of the project.  However, you can make your projects public to share in a read-only state by changing the visibility in project settings -\n\n\nPrev\n \nFoundations\nNext\n \nStaged Changes\nEdit this file on GitHub\nOn This Page\nManaging Project Info\nDeleting a Project\nInviting Members\nInvite by Email\nInvite by Link\nTransferring Projects\nHobby User to Hobby User\nHobby User to Team || Team to Team\nViewing Recent Activity\nUpdating Project Visibility"
  },
  {
    "url": "https://docs.railway.app/guides/public-api",
    "title": "Use the Public API | Railway Docs",
    "content": "Use the Public API\nThe Railway public API is built with GraphQL and is the same API that powers the Railway dashboard.\n\n\nUse the Public API to integrate Railway into your CI/CD pipelines and other workflows.\n\n\nUnderstanding GraphQL\n\n\nIf you haven't used GraphQL before, here are a few resources to get started:\n\n\n\n\nThe official \nIntroduction to GraphQL\n\n\nThe \nGraphQL Basics\n course by Hasura\n\n\nGraphQL is the better REST\n to understand how it is different from a REST API\n\n\n\n\nConnecting to the Public API\n\n\nTo connect to and query the Public API, you will need the endpoint URL and a token for authentication.\n\n\nEndpoint\n\n\nThe public API is accessible at the following endpoint:\n\n\nhttps://backboard.railway.com/graphql/v2\n\n\nCreating a Token\n\n\nTo use the API, you will need an API token. There are three types of tokens you can create.\n\n\nTeam Tokens and Account Tokens\n\n\nYou can create an API token from the \ntokens page\n in your account settings.\n\n\n\n\n\n\nTeam token\n - Select a team in the \nTeam\n dropdown to create a token tied to a team. A team token has access to all the team's resources, and cannot be used to access your personal resources on Railway. Feel free to share this token with your teammates.\n\n\nAccount token\n - If you do not select a team, the token will be tied to your Railway account and will have access to all your resources including the teams you are a part of. Do not share this token with anyone else.\n\n\n\n\nNote that Teams are a Pro feature.\n\n\nProject Token\n\n\nYou can create a project token from the tokens page in your project settings.\n\n\nProject tokens are scoped to a specific environment within a project and can only be used to authenticate requests to that environment.\n\n\nExecute a Test Query\n\n\nOnce you have your token, you can pass it within the Authorization header of your request.\n\n\nUsing an Account Token\n\n\nYou can try the query below in the terminal of your choice. It should return your name and email on Railway:\n\n\ncurl\n --request POST \n\\\n\n\n  --url https://backboard.railway.com/graphql/v2 \n\\\n\n\n  --header \n'Authorization: Bearer <API_TOKEN_GOES_HERE>'\n \n\\\n\n\n  --header \n'Content-Type: application/json'\n \n\\\n\n\n  --data \n'{\"query\":\"query { me { name email } }\"}'\n\n\nNote:\n This query \ncannot\n be used with a team or project token because the data returned is scoped to your personal account.\n\n\nUsing a Team Token\n\n\nIf you have a team token, you can use it to authenticate requests to a specific team. The query below should return the team name and ID:\n\n\ncurl\n --request POST \n\\\n\n\n  --url https://backboard.railway.com/graphql/v2 \n\\\n\n\n  --header \n'Team-Access-Token: <TEAM_TOKEN_GOES_HERE>'\n \n\\\n\n\n  --header \n'Content-Type: application/json'\n \n\\\n\n\n  --data \n'{\"query\":\"query { team(id: \\\"<TEAM_ID_GOES_HERE>\\\") { name id } }\"}'\n\n\nNote:\n This query \ncan\n also be used with an account token as long as you are a member of the team.\n\n\nUsing a Project Token\n\n\nIf you have a project token, you can use it to authenticate requests to a specific environment within a project.  The query below should return the project and environment IDs:\n\n\ncurl\n --request POST \n\\\n\n\n  --url https://backboard.railway.com/graphql/v2 \n\\\n\n\n  --header \n'Project-Access-Token: <PROJECT_TOKEN_GOES_HERE>'\n \n\\\n\n\n  --header \n'Content-Type: application/json'\n \n\\\n\n\n  --data \n'{\"query\":\"query { projectToken { projectId environmentId } }\"}'\n\n\nViewing the Schema\n\n\nUse popular tools like \nPostman\n or \nInsomnia\n to connect to the API and query the schema.  Simply set up your connection with the endpoint and Authorization token, and fetch the schema.\n\n\nAPI Collection File\n\n\nWe also provide a collection file which can be imported into your preferred API client.  Click \nhere\n to download it.\n\n\nOnce imported, you should only need to add your API token to get connected and start executing queries in the collection.\n\n\nGraphiQL Playground\n\n\nAlternatively, you can use our \nGraphiQL playground\n to view the schema and test your queries.\n\n\n\n\nMake sure to set an Authorization header with an \nauth token\n. Click the \"Headers\" tab at the bottom of the GraphiQL page and enter this json, using your own token:\n\n\n{\n\"Authorization\"\n:\n \n\"Bearer <API_TOKEN_GOES_HERE>\"\n}\n\n\nTips and Tricks\n\n\nResource IDs\n\n\nWhile building your queries, if you quickly need to copy resource IDs, you can hit \nCmd/Ctrl + K\n within your project and copy the project/service/environment ID.\n\n\n\n\nThe Network Tab\n\n\nIf you're unsure about what query/mutation to use for what you are trying to achieve, you can always do the action in the dashboard and look for the request in the network tab. As we use the same API internally, you can simply grab the name and then look for specific query in the introspected schema.\n\n\nExternal Resources\n\n\n\n\nThe \nawesome-graphql\n repository is a great resource for all things GraphQL with implementations available across a variety of languages.\n\n\nThe \nGraphQL Discord\n is the official Discord channel for graphql.org with a lot of active members and specific help channels.\n\n\n\n\nExamples\n\n\nTo help you get started, we have provided some example queries in the guides within this section -\n\n\n\n\nManage Projects\n\n\nManage Services\n\n\nManage Deployments\n\n\nManage Variables\n\n\n\n\nSupport\n\n\nIf you run into problems using the API or have any suggestions, feel free to join our \nDiscord server\n where you can interact with the engineers working on the API directly.\n\n\nRate Limits\n\n\nRate limits are enforced on the Public API.  For details on the limits visit the \nPublic API reference page\n.\nPrev\n \nDeploy\nNext\n \nManage Projects\nEdit this file on GitHub\nOn This Page\nUnderstanding GraphQL\nConnecting to the Public API\nEndpoint\nCreating a Token\nTeam Tokens and Account Tokens\nProject Token\nExecute a Test Query\nUsing an Account Token\nUsing a Team Token\nUsing a Project Token\nViewing the Schema\nAPI Collection File\nGraphiQL Playground\nTips and Tricks\nResource IDs\nThe Network Tab\nExternal Resources\nExamples\nSupport\nRate Limits"
  },
  {
    "url": "https://docs.railway.app/guides/public-networking",
    "title": "Public Networking | Railway Docs",
    "content": "Public Networking\nPublic Networking refers to exposing your application to the internet, to be accessible from the public network.\n\n\nPort Variable\n\n\nAn essential part of connecting to your service from the internet, is properly handling the \nPORT\n variable.\n\n\nThe easiest way to get up and running is by using the Railway-provided port.\n\n\nRailway-provided port\n\n\nAs long as you have not defined a \nPORT\n variable, Railway will provide and expose one for you.\n\n\nTo have your application use the Railway-provided port, you should ensure it is listening on \n0.0.0.0:$PORT\n, where \nPORT\n is the Railway-provided environment variable.\n\n\nExamples\n -\n\n\n# python web server\n\n\nif\n __name__ \n==\n \n'__main__'\n:\n\n\n    app\n.\nrun\n(\ndebug\n=\nTrue\n,\n port\n=\nos\n.\ngetenv\n(\n\"PORT\"\n,\n default\n=\n5000\n)\n)\n\n\n// node web server\n\n\nconst\n port \n=\n process\n.\nenv\n.\nPORT\n \n||\n \n3000\n;\n\n\n\n\napp\n.\nlisten\n(\nport\n,\n \n(\n)\n \n=>\n \n{\n\n\n  console\n.\nlog\n(\n`\nApp listening on port: \n${\nport\n}\n`\n)\n;\n\n\n}\n)\n;\n\n\nMore information and examples for this can be found in the \nFixing Common Errors guide\n.\n\n\nNote:\n If your application needs to be accessible over both public and private networks, your application server must support dual stack binding. Most servers handle this automatically when listening on \n::\n, but some, like Uvicorn, do not.\n\n\nUser-defined port\n\n\nIf you prefer to explicitly set a port, you can set the \nPORT\n variable in your service variables to the port on which your service is listening.\n\n\nIf your domain does not have a \ntarget port set\n, Railway will direct incoming traffic to the port specified in the \nPORT\n variable, this is sometimes needed when creating a template.\n\n\nFor information on how to configure variables, see the \nVariables guide\n.\n\n\nRailway-Provided Domain\n\n\nRailway services don't obtain a domain automatically, but it is easy to set one up.\n\n\nTo assign a domain to your service, go to your service's settings, find the Networking -> Public Networking section, and choose \nGenerate Domain\n.\n\n\nAutomated Prompt\n\n\nIf Railway detects that a deployed service is listening correctly (as described above), you will see a prompt on the service tile in the canvas, and within the service panel.\n\n\n\n\nSimply follow the prompts to generate a domain and your app will be exposed to the internet.\n\n\nDon't see the Generate Domain Button?\n\n\nIf you have previously assigned a TCP Proxy to your service, you will not see the \nGenerate Domain\n option.  You must remove the TCP Proxy (click the Trashcan icon), then you can add a domain.\n\n\nCustom Domains\n\n\nCustom domains can be added to a Railway service and once setup we will automatically issue an SSL certificate for you.\n\n\n\n\n\n\nNavigate to the \nSettings tab\n of your desired \nservice\n.\n\n\n\n\n\n\nClick \n+ Custom Domain\n in the Public Networking section of Settings\n\n\n\n\n\n\nType in the custom domain (wildcard domains are supported, \nsee below\n for more details)\n\n\nYou will be provided with a CNAME domain to use, e.g., \ng05ns7.up.railway.app\n.\n\n\n\n\n\n\nIn your DNS provider (Cloudflare, DNSimple, Namecheap, etc), create a CNAME record with the CNAME value provided by Railway.\n\n\n\n\n\n\nWait for Railway to verify your domain.  When verified, you will see a greencheck mark next to the domain(s) -\n\n\n\n\nYou will also see a \nCloudflare proxy detected\n message if we have detected that you are using Cloudflare.\n\n\nNote:\n Changes to DNS settings may take up to 72 hours to propagate worldwide.\n\n\n\n\n\n\nImportant Considerations\n\n\n\n\nFreenom domains are not allowed and not supported.\n\n\nThe Trial Plan is limited to 1 custom domain. It is therefore not possible to use both \nyourdomain.com\n and \nwww.yourdomain.com\n as these are considered two distinct custom domains.\n\n\nThe \nHobby Plan\n is limited to 2 custom domains per service.\n\n\nThe \nPro Plan\n is limited to 20 domains per service by default.  This limit can be increased for Pro users on request, simply reach out to us via a \nprivate thread\n.\n\n\n\n\nWildcard Domains\n\n\nWildcard domains allow for flexible subdomain management. There are a few important things to know when using them -\n\n\n\n\n\n\nEnsure that the CNAME record for \nauthorize.railwaydns.net\n is not proxied by your provider (eg: Cloudflare). This is required for the verification process to work.\n\n\n\n\n\n\nWildcards cannot be nested (e.g., *.*.yourdomain.com).\n\n\n\n\n\n\nWildcards can be used for any subdomain level (e.g., \n*.example.com\n or \n*.subdomain.example.com\n).\n\n\n\n\n\n\nSubdomains\n\n\nE.g. \n*.example.com\n\n\n\n\n\n\nMake sure \nUniversal SSL is enabled\n.\n\n\n\n\n\n\nEnable \nFull SSL/TLS encryption\n.\n\n\n\n\n\n\nAdd CNAME records for the wildcard subdomain.\n\n\n\n\n\n\nNested Subdomains\n\n\nE.g. \n*.nested.example.com\n\n\n\n\n\n\nDisable Universal SSL\n.\n\n\n\n\n\n\nPurchase Cloudflare's \nAdvanced Certificate Manager\n.\n\n\n\n\n\n\nEnable \nEdge Certificates\n.\n\n\n\n\n\n\nEnable \nFull SSL/TLS encryption\n.\n\n\n\n\n\n\nAdd CNAME records for the wildcard nested subdomain.\n\n\n\n\n\n\nWhen you add a wildcard domain, you will be provided with two domains for which you should add two CNAME records -\n\n\n\n\nOne record is for the wildcard domain, and one for the _acme-challenge. The _acme-challenge CNAME is required for Railway to issue the SSL Certificate for your domain.\n\n\nWildcard Domains on Cloudflare\n\n\nIf you have a wildcard domain on Cloudflare, you must:\n\n\n\n\n\n\nTurn off Cloudflare proxying is on the \n_acme-challenge\n record (disable the orange cloud)\n\n\n\n\n\n\nEnable Cloudflare's \nUniversal SSL\n\n\n\n\n\n\nTarget Ports\n\n\nTarget Ports, or Magic Ports, correlate a single domain to a specific internal port that the application listens on, enabling you to expose multiple HTTP ports through the use of multiple domains.\n\n\nExample -\n\n\nhttps://example.com/\n â†’ \n:8080\n\n\nhttps://management.example.com/\n â†’ \n:9000\n\n\nWhen you first generate a Railway-provided domain, if your application listens on a single port, Railway's magic automatically detects and sets it as the domain's target port. If your app listens on multiple ports, you're provided with a list to choose from.\n\n\nWhen you add a custom domain, you're given a list of ports to choose from, and the selected port will handle all traffic routed to the domain. You can also specify a custom port if needed.\n\n\nThese target ports inform Railway which public domain corresponds to each internal port, ensuring that traffic from a specific domain is correctly routed to your application.\n\n\n\n\nYou can change the automatically detected or manually set port at any time by clicking the edit icon next to the domain.\n\n\nAdding a Custom Domain\n\n\nWhen adding a root or apex domain to your Railway service, you must ensure that you add the appropriate DNS record to the domain within your DNS provider.  At this time, Railway supports \nCNAME Flattening\n and dynamic ALIAS records.\n\n\nAdditional context\n\n\nGenerally, direct CNAME records at the root or apex level are incompatible with DNS standards (which assert that you should use an \"A\" or \"AAAA\" record).  However, given the dynamic nature of the modern web and PaaS providers like Railway, some DNS providers have incorporated workarounds enabling CNAME-like records to be associated with root domains.\n\nCheck out \nRFC 1912\n if you're interested in digging into this topic.\n\n\nChoosing the correct record type\n\n\nThe type of record to create is entirely dependent on your DNS provider.  Here are some examples -\n\n\n\n\nCloudflare CNAME\n - Simply set up a CNAME record for your root domain in Cloudflare, and they take care of the rest under the hood.  Refer to \nthis guide\n for more detailed instructions.\n\n\nDNSimple ALIAS\n - Set up an dynamic ALIAS in DNSimple for your root domain.\n\n\nNamecheap CNAME\n - Set up an CNAME in Namecheap for your root domain.\n\n\nbunny.net\n - Set up a ANAME in bunny.net for your root domain.\n\n\n\n\nIn contrast there are many nameservers that don't support CNAME flattening or dynamic ALIAS records -\n\n\n\n\n\n\nAWS Route 53\n\n\n\n\n\n\nHostinger\n\n\n\n\n\n\nGoDaddy\n\n\n\n\n\n\nNameSilo\n\n\n\n\n\n\nHurricane Electric\n\n\n\n\n\n\nSquareSpace\n\n\n\n\n\n\nWorkaround - Changing your Domain's Nameservers\n\n\nIf your DNS provider doesn't support CNAME Flattening or dynamic ALIAS records at the root, you can also change your domain's nameservers to point to Cloudflare's nameservers. This will allow you to use a CNAME record for the root domain. Follow the instructions listed on Cloudflare's documentation to \nchange your nameservers\n.\n\n\nAdding a Root Domain With www Subdomain to Cloudflare\n\n\nIf you want to add your root domain (e.g., \nmydomain.com\n) and the \nwww.\n subdomain to Cloudflare and redirect all \nwww.\n traffic to the root domain:\n\n\n\n\nCreate a Custom Domain in Railway for your root domain (e.g., \nmydomain.com\n). Copy the \nvalue\n field. This will be in the form: \nabc123.up.railway.app\n.\n\n\nAdd a \nCNAME\n DNS record to Cloudflare:\n\n\n\nName\n â†’ \n@\n.\n\n\nTarget\n â†’ the \nvalue\n field from Railway.\n\n\nProxy status\n â†’ \non\n, should display an orange cloud.\n\n\nNote: Due to domain flattening, \nName\n will automatically update to your root domain (e.g., \nmydomain.com\n).\n\n\n\n\n\n\nAdd another \nCNAME\n DNS record to Cloudflare:\n\n\n\nName\n â†’ \nwww\n.\n\n\nTarget\n â†’ \n@\n\n\nProxy status:\n â†’ on, should display an orange cloud.\n\n\nNote: Cloudflare will automatically change the \nTarget\n value to your root domain.\n\n\n\n\n\n\nEnable Full SSL/TLS encryption in Cloudflare:\n\n\n\nGo to your domain on Cloudflare.\n\n\nNavigate to \nSSL/TLS -> Overview\n.\n\n\nSelect \nFull\n. \nNot\n \nFull (Strict)\n \nStrict mode will not work as intended\n.\n\n\n\n\n\n\nEnable Universal SSL in Cloudflare:\n\n\n\nGo to your domain on Cloudflare.\n\n\nNavigate to \nSSL/TLS -> Edge Certificates\n.\n\n\nEnable \nUniversal SSL\n.\n\n\n\n\n\n\nAfter doing this, you should see \nCloudflare proxy detected\n on your Custom Domain in Railway with a green cloud.\n\n\nCreate a Bulk Redirect in Cloudflare:\n\n\n\nGo to your \nCloudflare dashboard\n.\n\n\nNavigate to \nBulk Redirects\n.\n\n\nClick \nCreate Bulk Redirect List\n.\n\n\nGive it a name, e.g., \nwww-redirect\n.\n\n\nClick \nOr, manually add URL redirects\n.\n\n\nAdd a \nSource URL\n: \nhttps://www.mydomain.com\n.\n\n\nAdd \nTarget URL\n: \nhttps://mydomain.com\n with status \n301\n.\n\n\nTick all the parameter options: (\nPreserve query string\n, \nInclude subdomains\n, \nSubpath matching\n, \nPreserve path suffix\n)\n\n\nClick \nNext\n, then \nSave and Deploy\n.\n\n\n\n\n\n\n\n\nNote:\n DNS changes may take some time to propagate. You may want to refresh your DNS cache by using commands like \nipconfig /flushdns\n on Windows or \ndscacheutil -flushcache\n on macOS. Testing the URLs in an incognito window can also help verify changes.\n\n\nTCP Proxying\n\n\nYou can proxy TCP traffic to your service by creating a TCP proxy in the service settings. Enter the port that you want traffic proxied to, Railway will generate a domain and port for you to use. All traffic sent to \ndomain:port\n will be proxied to your service. This is useful for services that don't support HTTP, such as databases.\n\n\n\n\nIncoming traffic will be distributed across all replicas in the closest region using a random algorithm.\n\n\nUsing HTTP and TCP Together\n\n\nRailway does support exposing both HTTP and TCP over public networking, in a single service. Therefore, if you have a domain assigned, you will still see the option to enable TCP Proxy, and vice-versa.\n\n\nIf you have a usecase that requires exposing both HTTP and TCP over public networking, in one service, \nlet us know\n!\n\n\nLet's Encrypt SSL Certificates\n\n\nOnce a custom domain has been correctly configured, Railway will automatically\ngenerate and apply a Let's Encrypt certificate. This means that any custom\ndomain on Railway will automatically be accessible\nvia \nhttps://\n.\n\n\nExternal SSL Certificates\n\n\nWe currently do not support external SSL certificates since we provision one for you.\n\n\nProvider Specific Instructions\n\n\nIf you have proxying enabled on Cloudflare (the orange cloud), you MUST set your\nSSL/TLS settings to \nFull\n -- Full (Strict) \nwill not work as intended\n.\n\n\n\n\nIf proxying is not enabled, Cloudflare will not associate the domain with your Railway project.  In this case, you will encounter the following error message:\n\n\nERR_TOO_MANY_REDIRECTS\n\n\nAlso note that if proxying is enabled, you can NOT use a domain deeper than a first level subdomain without Cloudflare's Advanced Certificate Manager. For example, anything falling under *.yourdomain.com can be proxied through Cloudflare without issue, however if you have a custom domain under *.subdomain.yourdomain.com, you MUST disable Cloudflare Proxying and set the CNAME record to DNS Only (the grey cloud), unless you have Cloudflare's Advanced Certificate Manager.\n\n\nSupport\n\n\nLooking for the technical specs like timeouts, TLS information, rate limits etc? Check out the \nPublic Networking reference page\n.\n\n\nHaving trouble connecting to your app from the internet? Check out the \nFixing Common Errors guide\n or reach out on our \nDiscord\n.\nPrev\n \nNetworking\nNext\n \nPrivate Networking\nEdit this file on GitHub\nOn This Page\nPort Variable\nRailway-provided port\nUser-defined port\nRailway-Provided Domain\nAutomated Prompt\nCustom Domains\nWildcard Domains\nSubdomains\nNested Subdomains\nWildcard Domains on Cloudflare\nTarget Ports\nAdding a Custom Domain\nAdding a Root Domain With www Subdomain to Cloudflare\nTCP Proxying\nUsing HTTP and TCP Together\nLet's Encrypt SSL Certificates\nExternal SSL Certificates\nProvider Specific Instructions\nSupport"
  },
  {
    "url": "https://docs.railway.app/guides/publish-and-share",
    "title": "Publish and Share Templates | Railway Docs",
    "content": "Publish and Share Templates\nOnce you create a template, you have the option to publish it. Publishing a template will add it to our \ntemplate marketplace\n for other users to deploy.\n\n\nPublishing a Template\n\n\nAfter you create your template, simply click the publish button and fill out the form to publish your template.\n\n\n\n\nYou can always publish your template by going to the \nTemplates page in your Workspace settings\n and choose \nPublish\n next to the template you'd like to publish.\n\n\nSharing your Templates\n\n\nAfter you create your template, you may want to share your work with the public and let others clone your project. You are provided with the Template URL where your template can be found and deployed.\n\n\nDeploy on Railway Button\n\n\nTo complement your template, we also provide a \nDeploy on Railway\n button which you can include in your README or embed it into a website.\n\n\n\n\n\nThe button is located at \nhttps://railway.com/button.svg\n.\n\n\nMarkdown\n\n\nTo render the button in Markdown, copy the following code and replace the link with your desired template:\n\n\n[![Deploy on Railway](https://railway.com/button.svg)](https://railway.com/new/template/ZweBXA)\n\n\nHTML\n\n\nTo render the button in HTML, copy the following code and replace the link with your desired template:\n\n\n<\na\n \nhref\n=\n\"\nhttps://railway.com/new/template/ZweBXA\n\"\n>\n<\nimg\n \nsrc\n=\n\"\nhttps://railway.com/button.svg\n\"\n \nalt\n=\n\"\nDeploy on Railway\n\"\n \n/>\n</\na\n>\n\n\nExamples\n\n\nHere are some example templates from the \ntemplate marketplace\n in button form:\n\n\nIcon\nTemplate\nButton\nNode\nDeno\nBun\nGin\nFlask\n\n\nKickback program\n\n\nIf your published template is deployed into other users' projects, you are immediately eligible for a 50% kickback, in the form of Railway credits. Refer to the \ntemplate reference page\n for more information.\nPrev\n \nBest Practices\nNext\n \nDeploy\nEdit this file on GitHub\nOn This Page\nPublishing a Template\nSharing your Templates\nDeploy on Railway Button\nMarkdown\nHTML\nExamples\nKickback program"
  },
  {
    "url": "https://docs.railway.app/guides/rails",
    "title": "Deploy a Ruby on Rails App | Railway Docs",
    "content": "Deploy a Ruby on Rails App\nRails is a Ruby full-stack framework designed to compress the complexity of modern web apps. It ships with all the tools needed to build amazing web apps on both the front and back end.\n\n\nCreate a Rails App\n\n\nNote:\n If you already have a Rails app locally or on GitHub, you can skip this step and go straight to the \nDeploy Ruby on Rails App on Railway\n.\n\n\nTo create a new Rails app, ensure that you have \nRuby\n and \nRails\n installed on your machine. Once everything is set up, run the following command in your terminal:\n\n\nrails new blog --database\n=\npostgresql\n\n\nThis command will create a new Rails app named \nblog\n with PostgreSQL as the database config. Now, letâ€™s create a simple \"Hello World\" page to ensure everything is working correctly.\n\n\n\n\n\n\nGenerate a Controller\n: Run the following command to create a new controller named \nHelloWorld\n with an \nindex\n action:\n\n\nrails g controller HelloWorld index\n\n\nThis will generate the necessary files for the controller, along with a view, route, and test files.\n\n\n\n\n\n\nUpdate the Routes File\n: Open the \nconfig/routes.rb\n file and modify it to set the root route to the \nhello_world#index\n action:\n\n\nRails\n.\napplication\n.\nroutes\n.\ndraw \ndo\n\n\n    get \n\"hello_world/index\"\n\n\n    \n# Define your application routes per the DSL in https://guides.rubyonrails.org/routing.html\n\n\n\n\n    \n# Reveal health status on /up that returns 200 if the app boots with no exceptions, otherwise 500.\n\n\n    \n# Can be used by load balancers and uptime monitors to verify that the app is live.\n\n\n    get \n\"up\"\n \n=>\n \n\"rails/health#show\"\n,\n \nas\n:\n \n:rails_health_check\n\n\n\n\n    \n# Render dynamic PWA files from app/views/pwa/*\n\n\n    get \n\"service-worker\"\n \n=>\n \n\"rails/pwa#service_worker\"\n,\n \nas\n:\n \n:pwa_service_worker\n\n\n    get \n\"manifest\"\n \n=>\n \n\"rails/pwa#manifest\"\n,\n \nas\n:\n \n:pwa_manifest\n\n\n\n\n    \n# Defines the root path route (\"/\")\n\n\n    root \n\"hello_world#index\"\n\n\nend\n\n\n\n\n\n\nModify the View\n: Open the \napp/views/hello_world/index.html.erb\n file and replace its content with the following:\n\n\n<\nh1\n>\nHello World\n<\n/\nh1\n>\n\n\n\n\n<\np\n>\n This is a Rails app running on Railway\n<\n/\np\n>\n\n\n\n\n\n\nRun the Application Locally\n: Start the Rails server by running:\n\n\nbin/rails server\n\n\nOpen your browser and go to \nhttp://localhost:3000\n to see your \"Hello World\" page in action.\n\n\n\n\n\n\nNow that your app is running locally, letâ€™s move on to deploying it to Railway!\n\n\nDeploy Ruby on Rails App on Railway\n\n\nRailway offers multiple ways to deploy your Rails app, depending on your setup and preference. Choose any of the following methods:\n\n\n\n\nOne-click deploy from a template\n.\n\n\nUsing the CLI\n.\n\n\nFrom a GitHub repository\n.\n\n\n\n\nOne-Click Deploy from a Template\n\n\nIf youâ€™re looking for the fastest way to get started, the one-click deploy option is ideal. It sets up a Rails app along with a Postgres database and Redis.\n\n\nClick the button below to begin:\n\n\n\n\nAfter deploying, we recommend that you \neject from the template\n to create a copy of the repository under your own GitHub account. This will give you full control over the source code and project.\n\n\nDeploy from the CLI\n\n\nTo deploy the Rails app using the Railway CLI, please follow the steps:\n\n\n\n\nInstall the Railway CLI\n:\n\n\n\n\nInstall the CLI\n and \nauthenticate it\n using your Railway account.\n\n\n\n\n\n\nInitialize a Railway Project\n:\n\n\n\n\nRun the command below in your Rails app directory.\n\n\nrailway init\n\n\n\n\nFollow the prompts to name your project.\n\n\nAfter the project is created, click the provided link to view it in your browser.\n\n\n\n\n\n\nDeploy the Application\n:\n\n\n\n\nUse the command below to deploy your app:\n\n\nrailway up\n\n\n\n\nThis command will scan, compress and upload your app's files to Railway. Youâ€™ll see real-time deployment logs in your terminal.\n\n\n\n\n\n\n\n\n\n\nNote:\n If you see an error about a missing \nsecret_key_base\n for the production environment, donâ€™t worry. Weâ€™ll fix this in the next step.\n\n\n\n\n\n\nAdd a Database Service\n:\n\n\n\n\nRun \nrailway add\n.\n\n\nSelect \nPostgreSQL\n by pressing space and hit \nEnter\n to add it to your project.\n\n\nA database service will be added to your Railway project.\n\n\n\n\n\n\nConfigure Environment Variables\n:\n\n\n\n\nGo to your app service \nVariables\n section and add the following:\n\n\n\n\nSECRET_KEY_BASE\n or \nRAILS_MASTER_KEY\n: Set the value to the key from your local app's \nconfig/master.key\n.\n\n\nDATABASE_URL\n: Set the value to \n${{Postgres.DATABASE_PUBLIC_URL}}\n (this references the URL of your new Postgres database). Learn more about \nreferencing service variables\n.\n\n\n\n\n\n\nUse the \nRaw Editor\n to add any other required environment variables in one go.\n\n\n\n\n\n\nRedeploy the Service\n:\n\n\n\n\nClick \nDeploy\n on the Railway dashboard to apply your changes.\n\n\n\n\n\n\nVerify the Deployment\n:\n\n\n\n\nOnce the deployment completes, go to \nView logs\n to check if the server is running successfully.\n\n\n\n\n\n\n\n\nNote:\n If your app has a \nDockerfile\n (which newer Rails apps typically include by default), Railway will \nautomatically detect and use it to build\n your app. If not, Railway will still handle the deployment process for you.\n\n\n\n\nSet Up a Public URL\n:\n\n\n\n\nNavigate to the \nNetworking\n section under the \nSettings\n tab of your new service.\n\n\nClick \nGenerate Domain\n to create a public URL for your app.\n\n\n\n\n\n\n\n\n\n\nDeploy from a GitHub Repo\n\n\nTo deploy the Rails app to Railway, start by pushing the app to a GitHub repo. Once thatâ€™s set up, follow the steps below to complete the deployment process.\n\n\n\n\nCreate a New Project on Railway\n:\n\n\n\n\nGo to \nRailway\n to create a new project.\n\n\n\n\n\n\nDeploy from GitHub\n:\n\n\n\n\nSelect \nDeploy from GitHub repo\n and choose your repository.\n\n\n\n\nIf your Railway account isnâ€™t linked to GitHub yet, youâ€™ll be prompted to do so.\n\n\n\n\n\n\n\n\n\n\nAdd Environment Variables\n:\n\n\n\n\nClick \nAdd Variables\n and configure all the necessary environment variables for your app.\n\n\n\n\nE.g \nRAILS_ENV\n: Set the value to \nproduction\n.\n\n\nE.g \nSECRET_KEY_BASE\n or \nRAILS_MASTER_KEY\n: Set the value to the key from your app's \nconfig/master.key\n.\n\n\n\n\n\n\n\n\n\n\nDeploy the App\n:\n\n\n\n\nClick \nDeploy\n to start the deployment process.\n\n\nOnce the deployed, a Railway \nservice\n will be created for your app, but it wonâ€™t be publicly accessible by default.\n\n\n\n\n\n\nAdd a Database Service\n:\n\n\n\n\nRight-click on the Railway project canvas or click the \nCreate\n button.\n\n\nSelect \nDatabase\n.\n\n\nSelect \nAdd PostgreSQL\n from the available databases.\n\n\n\n\nThis will create and deploy a new Postgres database service for your project.\n\n\n\n\n\n\n\n\n\n\nConfigure Environment Variables\n:\n\n\n\n\nGo to your app service \nVariables\n section and add the following:\n\n\n\n\nDATABASE_URL\n: Set the value to \n${{Postgres.DATABASE_URL}}\n (this references the URL of your new Postgres database). Learn more about \nreferencing service variables\n.\n\n\n\n\n\n\nUse the \nRaw Editor\n to add any other required environment variables in one go.\n\n\n\n\n\n\nPrepare Database and Start Server\n:\n\n\n\n\nGo to your app service \nSettings\n section.\n\n\n\n\nIn the \nDeploy\n section, set \nbin/rails db:prepare && bin/rails server -b ::\n as the \nCustom Start Command\n. This command will run your database migrations and start the server.\n\n\n\n\n\n\n\n\n\n\nRedeploy the Service\n:\n\n\n\n\nClick \nDeploy\n on the Railway dashboard to apply your changes.\n\n\n\n\n\n\nVerify the Deployment\n:\n\n\n\n\nOnce the deployment completes, go to \nView logs\n to check if the server is running successfully.\n\n\n\n\n\n\n\n\nNote:\n During the deployment process, Railway will automatically \ndetect that itâ€™s a Rails app\n.\n\n\n\n\nSet Up a Public URL\n:\n\n\n\n\nNavigate to the \nNetworking\n section under the \nSettings\n tab of your new service.\n\n\nClick \nGenerate Domain\n to create a public URL for your app.\n\n\n\n\n\n\n\n\nThis guide covers the main deployment options on Railway. Choose the approach that suits your setup, and start deploying your Rails apps effortlessly!\n\n\nNext, we'll cover how to set up workers and cron jobs for your Rails app on Railway.\n\n\nSet Up Workers & Cron Jobs with Sidekiq\n\n\nSidekiq is a powerful and efficient background job processor for Ruby apps, and it integrates seamlessly with Rails. Follow the instructions below to configure and run Sidekiq in your Rails app on Railway:\n\n\n\n\n\n\nInstall Sidekiq\n\n\n\n\nStart by adding \nsidekiq\n and \nsidekiq-cron\n to your Rails app. In your terminal, run the following command:\n\n\nbundle \nadd\n sidekiq\n\nbundle \nadd\n sidekiq-cron\n\n\n\n\n\n\n\n\n\n\nAdd a Redis Database Service\n\n\n\n\nSidekiq uses Redis as a job queue. To set this up:\n\n\n\n\nRight-click on the Railway project canvas or click the \nCreate\n button.\n\n\nSelect \nDatabase\n.\n\n\nSelect \nAdd Redis\n from the available databases.\n\n\n\n\nThis will create and deploy a new Redis service for your app.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCreate and Configure a Worker Service\n\n\n\n\nNow, set up a \nseparate service\n to run your Sidekiq workers.\n\n\n\n\nCreate a new \nEmpty Service\n and name it \nWorker Service\n.\n\n\nGo to the \nSettings\n tab of this service to configure it.\n\n\nIn the \nSource\n section, connect your GitHub repository to the \nSource Repo\n.\n\n\nUnder the \nBuild\n section, set \nbundle install\n as the \nCustom Build Command\n. This installs the necessary dependencies.\n\n\nIn the \nDeploy\n section, set \nbundle exec sidekiq\n as the \nCustom Start Command\n. This command will start Sidekiq and begin processing jobs.\n\n\nClick on \nVariables\n at the top of the service settings.\n\n\nAdd the following environment variables:\n\n\n\n\nRAILS_ENV\n: Set the value to \nproduction\n.\n\n\nSECRET_KEY_BASE\n or \nRAILS_MASTER_KEY\n: Set this to the value of your Rails appâ€™s secret key.\n\n\nREDIS_URL\n: Set this to \n${{Redis.REDIS_URL}}\n to reference the Redis database URL. This tells Sidekiq where to find the job queue. Learn more about \nreferencing service variables\n.\n\n\nInclude any other environment variables your app might need.\n\n\n\n\n\n\nClick \nDeploy\n to apply the changes and start the deployment.\n\n\n\n\n\n\n\n\n\n\n\n\nVerify the Deployment\n:\n\n\n\n\nOnce the deployment is complete, click on \nView Logs\n. If everything is set up correctly, you should see Sidekiq starting up and processing any queued jobs.\n\n\n\n\n\n\n\n\n\n\nConfirm All Services Are Connected\n:\n\n\n\n\nAt this stage, your application should have the following services set up and connected:\n\n\n\n\nApp Service\n: Running the main Rails application.\n\n\nWorker Service\n: Running Sidekiq to process background jobs.\n\n\nPostgres Service\n: The database for your Rails app.\n\n\nRedis Service\n: Used by Sidekiq to manage background jobs\n\n\n\n\n\n\n\n\n\n\n\n\nHereâ€™s how your setup should look:\n\n\n\n\nBy following these steps, youâ€™ll have a fully functional Rails app with background job processing using Sidekiq on Railway. If you run into any issues or need to make adjustments, check the logs and revisit your environment variable configurations.\n\n\nNext Steps\n\n\nExplore these resources to learn how you can maximize your experience with Railway:\n\n\n\n\nMonitoring\n\n\nDeployments\n\n\nPrev\n \nGin\nNext\n \nAxum\nEdit this file on GitHub\nOn This Page\nCreate a Rails App\nDeploy Ruby on Rails App on Railway\nOne-Click Deploy from a Template\nDeploy from the CLI\nDeploy from a GitHub Repo\nSet Up Workers & Cron Jobs with Sidekiq\nNext Steps"
  },
  {
    "url": "https://docs.railway.app/guides/react",
    "title": "Deploy a React App | Railway Docs",
    "content": "Deploy a React App\nReact\n, also known as React.js or ReactJS, is a popular JavaScript library developed by Meta for building user interfaces, especially for web and native applications.\n\n\nReact simplifies the process of creating interactive and dynamic UIs by breaking them down into reusable components.\n\n\nThis guide covers how to deploy a React app to Railway in four ways:\n\n\n\n\nOne-click deploy from a template\n.\n\n\nFrom a GitHub repository\n.\n\n\nUsing the CLI\n.\n\n\nUsing a Dockerfile\n.\n\n\n\n\nNow, let's create a React app!\n\n\nCreate a React App\n\n\nNote:\n If you already have a React app locally or on GitHub, you can skip this step and go straight to the \nDeploy React App on Railway\n.\n\n\nTo create a new React app, ensure that you have \nNode\n installed on your machine.\n\n\nRun the following command in your terminal to create a new React app using \nVite\n:\n\n\nnpm\n create vite@latest helloworld -- --template react\n\n\nA new React app will be provisioned for you in the \nhelloworld\n directory.\n\n\nRun the React App locally\n\n\nNext, \ncd\n into the directory and install the dependencies.\n\n\nnpm\n \ninstall\n\n\nStart the Vite development server by running the following command:\n\n\nnpm\n run dev\n\n\nOpen your browser and go to \nhttp://localhost:5173\n to see your app.\n\n\nDeploy the React App to Railway\n\n\nRailway offers multiple ways to deploy your React app, depending on your setup and preference.\n\n\nOne-Click Deploy from a Template\n\n\nIf youâ€™re looking for the fastest way to get started, the one-click deploy option is ideal. It sets up a React app with \nCaddy\n to serve the dist folder.\n\n\nClick the button below to begin:\n\n\n\n\nWe highly recommend that \nyou eject from the template after deployment\n to create a copy of the repo on your GitHub account.\n\n\nNote:\n You can also choose from a \nvariety of React app templates\n created by the community.\n\n\nDeploy from the CLI\n\n\n\n\nInstall the Railway CLI\n:\n\n\n\n\nInstall the CLI\n and \nauthenticate it\n using your Railway account.\n\n\n\n\n\n\nInitialize a Railway Project\n:\n\n\n\n\nRun the command below in your React app directory.\n\n\nrailway init\n\n\n\n\nFollow the prompts to name your project.\n\n\nAfter the project is created, click the provided link to view it in your browser.\n\n\n\n\n\n\nDeploy the Application\n:\n\n\n\n\nUse the command below to deploy your app:\n\n\nrailway up\n\n\n\n\nThis command will scan, compress and upload your app's files to Railway. Youâ€™ll see real-time deployment logs in your terminal.\n\n\nOnce the deployment completes, go to \nView logs\n to check if the service is running successfully.\n\n\n\n\n\n\nSet Up a Public URL\n:\n\n\n\n\nNavigate to the \nNetworking\n section under the \nSettings\n tab of your new service.\n\n\nClick \nGenerate Domain\n to create a public URL for your app.\n\n\n\n\n\n\n\n\n\n\nDeploy from a GitHub Repo\n\n\nTo deploy a React app to Railway directly from GitHub, follow the steps below:\n\n\n\n\nCreate a New Project on Railway\n:\n\n\n\n\nGo to \nRailway\n to create a new project.\n\n\n\n\n\n\nDeploy from GitHub\n:\n\n\n\n\nSelect \nDeploy from GitHub repo\n and choose your repository.\n\n\n\n\nIf your Railway account isnâ€™t linked to GitHub yet, youâ€™ll be prompted to do so.\n\n\n\n\n\n\n\n\n\n\nDeploy the App\n:\n\n\n\n\nClick \nDeploy\n to start the deployment process.\n\n\nOnce the deployed, a Railway \nservice\n will be created for your app, but it wonâ€™t be publicly accessible by default.\n\n\n\n\n\n\nVerify the Deployment\n:\n\n\n\n\nOnce the deployment completes, go to \nView logs\n to check if the server is running successfully.\n\n\n\n\n\n\nSet Up a Public URL\n:\n\n\n\n\nNavigate to the \nNetworking\n section under the \nSettings\n tab of your new service.\n\n\nClick \nGenerate Domain\n to create a public URL for your app.\n\n\n\n\n\n\n\n\nUse a Dockerfile\n\n\n\n\nCreate a \nDockerfile\n in the \nhelloworld\n or React app's root directory.\n\n\nAdd the content below to the \nDockerfile\n:\n\n\n# Use the Node alpine official image\n\n\n# https://hub.docker.com/_/node\n\n\nFROM node:lts-alpine AS build\n\n\n\n# Set config\n\n\nENV \nNPM_CONFIG_UPDATE_NOTIFIER\n=\nfalse\n\nENV \nNPM_CONFIG_FUND\n=\nfalse\n\n\n\n# Create and change to the app directory.\n\n\nWORKDIR /app\n\n\n\n# Copy the files to the container image\n\n\nCOPY package*.json ./\n\n\n\n# Install packages\n\n\nRUN \nnpm\n ci\n\n\n\n# Copy local code to the container image.\n\n\nCOPY \n.\n ./\n\n\n\n# Build the app.\n\n\nRUN \nnpm\n run build\n\n\n\n# Use the Caddy image\n\n\nFROM caddy\n\n\n\n# Create and change to the app directory.\n\n\nWORKDIR /app\n\n\n\n# Copy Caddyfile to the container image.\n\n\nCOPY Caddyfile ./\n\n\n\n# Copy local code to the container image.\n\n\nRUN caddy \nfmt\n Caddyfile --overwrite\n\n\n\n# Copy files to the container image.\n\n\nCOPY --from\n=\nbuild /app/dist ./dist\n\n\n\n# Use Caddy to run/serve the app\n\n\nCMD \n[\n\"caddy\"\n, \n\"run\"\n, \n\"--config\"\n, \n\"Caddyfile\"\n, \n\"--adapter\"\n, \n\"caddyfile\"\n]\n\n\nThe \nDockerfile\n will use Caddy to serve the React app.\n\n\nAdd a \nCaddyfile\n to the app's root directory:\n\n\n# global options\n\n\n{\n\n\n    admin off \n# theres no need for the admin api in railway's environment\n\n\n    persist_config off \n# storage isn't persistent anyway\n\n\n    auto_https off \n# railway handles https for us, this would cause issues if left enabled\n\n\n    \n# runtime logs\n\n\n    log \n{\n\n\n        \nformat\n json \n# set runtime log format to json mode \n\n\n    \n}\n\n\n    \n# server options\n\n\n    servers \n{\n\n\n        trusted_proxies static private_ranges \n100.0\n.0.0/8 \n# trust railway's proxy\n\n\n    \n}\n\n\n}\n\n\n\n\n# site block, listens on the $PORT environment variable, automatically assigned by railway\n\n\n:\n{\n$PORT\n:3000\n}\n \n{\n\n\n    \n# access logs\n\n\n    log \n{\n\n\n        \nformat\n json \n# set access log format to json mode\n\n\n    \n}\n\n\n\n\n    \n# health check for railway\n\n\n    rewrite /health /*\n\n\n\n    \n# serve from the 'dist' folder (Vite builds into the 'dist' folder)\n\n\n    root * dist\n\n\n\n    \n# enable gzipping responses\n\n\n    encode \ngzip\n\n\n\n\n    \n# serve files from 'dist'\n\n\n    file_server\n\n\n\n    \n# if path doesn't exist, redirect it to 'index.html' for client side routing\n\n\n    try_files \n{\npath\n}\n /index.html\n\n}\n\n\n\n\nEither deploy via the CLI or from GitHub.\n\n\n\n\nRailway automatically detects the \nDockerfile\n, \nand uses it to build and deploy the app.\n\n\nNote:\n Railway supports also \ndeployment from public and private Docker images\n.\n\n\nThis guide covers the main deployment options on Railway. Choose the approach that suits your setup, and start deploying your React apps seamlessly!\n\n\nNext Steps\n\n\nExplore these resources to learn how you can maximize your experience with Railway:\n\n\n\n\nAdd a Database Service\n\n\nMonitor your app\n\n\nPrev\n \nAngular\nNext\n \nRemix\nEdit this file on GitHub\nOn This Page\nCreate a React App\nRun the React App locally\nDeploy the React App to Railway\nOne-Click Deploy from a Template\nDeploy from the CLI\nDeploy from a GitHub Repo\nUse a Dockerfile\nNext Steps"
  },
  {
    "url": "https://docs.railway.app/guides/redis",
    "title": "Redis | Railway Docs",
    "content": "Redis\nThe Railway Redis database template allows you to provision and connect to a Redis database with zero configuration.\n\n\nDeploy\n\n\nAdd a Redis database to your project via the \nctrl / cmd + k\n menu or by clicking the \n+ New\n button on the Project Canvas.\n\n\n\n\nYou can also deploy it via the \ntemplate\n from the template marketplace.\n\n\nDeployed Service\n\n\nUpon deployment, you will have a Redis service running in your project, deployed from the \nbitnami/redis\n Docker image.\n\n\nConnect\n\n\nConnect to the Redis server from another service in your project by \nreferencing the environment variables\n made available in the Redis service:\n\n\n\n\nREDISHOST\n\n\nREDISUSER\n\n\nREDISPORT\n\n\nREDISPASSWORD\n\n\nREDIS_URL\n\n\n\n\nConnecting Externally\n\n\nIt is possible to connect to Redis externally (from outside of the \nproject\n in which it is deployed), by using the \nTCP Proxy\n which is enabled by default.\n\n\nKeep in mind that you will be billed for \nNetwork Egress\n when using the TCP Proxy.\n\n\nModify the Deployment\n\n\nSince the deployed container is pulled from the \nbitnami Redis\n image in Docker Hub, you can modify the deployment based on the \ninstructions in Docker Hub\n.\n\n\nBackup and Monitoring\n\n\nEspecially for production environments, performing backups and monitoring the health of your data is essential. Consider adding:\n\n\n\n\n\n\nBackups\n: Automate regular backups to ensure data recovery in case of failure. We suggest checking out our native \nBackups\n feature.\n\n\n\n\n\n\nObservability\n: Implement monitoring for insights into performance and health of your Redis cluster. You can integrate a Redis exporter for Prometheus, although we do not provide a specific template at this time.\n\n\n\n\n\n\nAdditional Resources\n\n\nWhile these templates are available for your convenience, they are considered unmanaged, meaning you have total control over their configuration and maintenance.\n\n\nWe \nstrongly encourage you\n to refer to the source documentation to gain deeper understanding of their functionality and how to use them effectively.  Here are some links to help you get started:\n\n\n\n\nRedis Documentation\n\n\nRedis Replication\n\n\nHigh Availability with Redis Sentinel\n\n\nUnderstanding Sentinels\n\n\nPrev\n \nMySQL\nNext\n \nMongoDB\nEdit this file on GitHub\nOn This Page\nDeploy\nConnect\nConnecting Externally\nModify the Deployment\nBackup and Monitoring\nAdditional Resources"
  },
  {
    "url": "https://docs.railway.app/guides/remix",
    "title": "Deploy a Remix App | Railway Docs",
    "content": "Deploy a Remix App\nRemix\n is a full-stack web framework that empowers you to build fast, elegant, and resilient user experiences by focusing on the interface and working seamlessly with web standards. Your users will enjoy every moment spent with your product.\n\n\nThis guide covers how to deploy a Remix app to Railway in four ways:\n\n\n\n\nOne-click deploy from a template\n.\n\n\nFrom a GitHub repository\n.\n\n\nUsing the CLI\n.\n\n\nUsing a Dockerfile\n.\n\n\n\n\nNow, let's create a Remix app!\n\n\nCreate a Remix App\n\n\nNote:\n If you already have a Remix app locally or on GitHub, you can skip this step and go straight to the \nDeploy Remix App on Railway\n.\n\n\nTo create a new Remix app, ensure that you have \nNode\n installed on your machine.\n\n\nRun the following command in your terminal to create a new Remix app:\n\n\nnpx create-remix@latest\n\n\nFollow the prompts by giving a directory name, like \nhelloworld\n, where you want your app to be set up. When asked, select \nYes\n to automatically install all the necessary dependencies.\n\n\nA new Remix app will be provisioned for you in the \nhelloworld\n directory.\n\n\nRun the Remix App locally\n\n\nStart the Vite development server by running the following command:\n\n\nnpm\n run dev\n\n\nOpen your browser and go to \nhttp://localhost:5173\n to see your app.\n\n\nDeploy the Remix App to Railway\n\n\nRailway offers multiple ways to deploy your Remix app, depending on your setup and preference.\n\n\nOne-Click Deploy from a Template\n\n\nIf youâ€™re looking for the fastest way to get started, the one-click deploy option is ideal.\n\n\nClick the button below to begin:\n\n\n\n\nWe highly recommend that \nyou eject from the template after deployment\n to create a copy of the repo on your GitHub account.\n\n\nNote:\n You can also choose from a \nvariety of Remix app templates\n created by the community.\n\n\nDeploy from the CLI\n\n\n\n\nInstall the Railway CLI\n:\n\n\n\n\nInstall the CLI\n and \nauthenticate it\n using your Railway account.\n\n\n\n\n\n\nInitialize a Railway Project\n:\n\n\n\n\nRun the command below in your Vue app directory.\n\n\nrailway init\n\n\n\n\nFollow the prompts to name your project.\n\n\nAfter the project is created, click the provided link to view it in your browser.\n\n\n\n\n\n\nDeploy the Application\n:\n\n\n\n\nUse the command below to deploy your app:\n\n\nrailway up\n\n\n\n\nThis command will scan, compress and upload your app's files to Railway. Youâ€™ll see real-time deployment logs in your terminal.\n\n\nOnce the deployment completes, go to \nView logs\n to check if the service is running successfully.\n\n\n\n\n\n\nSet Up a Public URL\n:\n\n\n\n\nNavigate to the \nNetworking\n section under the \nSettings\n tab of your new service.\n\n\nClick \nGenerate Domain\n to create a public URL for your app.\n\n\n\n\n\n\n\n\n\n\nDeploy from a GitHub Repo\n\n\nTo deploy a Remix app to Railway directly from GitHub, follow the steps below:\n\n\n\n\nCreate a New Project on Railway\n:\n\n\n\n\nGo to \nRailway\n to create a new project.\n\n\n\n\n\n\nDeploy from GitHub\n:\n\n\n\n\nSelect \nDeploy from GitHub repo\n and choose your repository.\n\n\n\n\nIf your Railway account isnâ€™t linked to GitHub yet, youâ€™ll be prompted to do so.\n\n\n\n\n\n\n\n\n\n\nDeploy the App\n:\n\n\n\n\nClick \nDeploy\n to start the deployment process.\n\n\nOnce the deployed, a Railway \nservice\n will be created for your app, but it wonâ€™t be publicly accessible by default.\n\n\n\n\n\n\nVerify the Deployment\n:\n\n\n\n\nOnce the deployment completes, go to \nView logs\n to check if the server is running successfully.\n\n\n\n\n\n\nSet Up a Public URL\n:\n\n\n\n\nNavigate to the \nNetworking\n section under the \nSettings\n tab of your new service.\n\n\nClick \nGenerate Domain\n to create a public URL for your app.\n\n\n\n\n\n\n\n\nUse a Dockerfile\n\n\n\n\nCreate a \nDockerfile\n in the \nhelloworld\n or Remix app's root directory.\n\n\nAdd the content below to the \nDockerfile\n:\n\n\n# Use the Node alpine official image\n\n\n# https://hub.docker.com/_/node\n\n\nFROM node:lts-alpine\n\n\n\n# Create and change to the app directory.\n\n\nWORKDIR /app\n\n\n\n# Copy the files to the container image\n\n\nCOPY package*.json ./\n\n\n\n# Install packages\n\n\nRUN \nnpm\n ci\n\n\n\n# Copy local code to the container image.\n\n\nCOPY \n.\n ./\n\n\n\n# Build the app.\n\n\nRUN \nnpm\n run build\n\n\n\n# Serve the app\n\n\nCMD \n[\n\"npm\"\n, \n\"run\"\n, \n\"start\"\n]\n\n\n\n\nEither deploy via the CLI or from GitHub.\n\n\n\n\nRailway automatically detects the \nDockerfile\n, \nand uses it to build and deploy the app.\n\n\nNote:\n Railway supports also \ndeployment from public and private Docker images\n.\n\n\nThis guide covers the main deployment options on Railway. Choose the approach that suits your setup, and start deploying your Remix apps seamlessly!\n\n\nNext Steps\n\n\nExplore these resources to learn how you can maximize your experience with Railway:\n\n\n\n\nAdd a Database Service\n\n\nMonitor your app\n\n\nPrev\n \nReact\nNext\n \nVue\nEdit this file on GitHub\nOn This Page\nCreate a Remix App\nRun the Remix App locally\nDeploy the Remix App to Railway\nOne-Click Deploy from a Template\nDeploy from the CLI\nDeploy from a GitHub Repo\nUse a Dockerfile\nNext Steps"
  },
  {
    "url": "https://docs.railway.app/guides/restart-policy",
    "title": "Restart Policy | Railway Docs",
    "content": "Restart Policy\nThe restart policy dictates what action Railway should take if a deployed service stops, e.g., exits with a non-zero exit code.\n\n\nNote:\n For services with multiple replicas, a restart will only affect the replica that crashed, while the other replica(s) continue handling the workload until the restarted replica is back online.\n\n\nThe default is \nOn Failure\n with a maximum of 10 restarts.\n\n\nTo configure a different restart policy, go to the Service settings and select a different policy from the dropdown.\n\n\nWhat does each policy mean?\n\n\n\n\n\n\nAlways\n: Railway will automatically restart your service every time it stops, regardless of the reason.\n\n\n\n\n\n\nOn Failure\n: Railway will only restart your service if it stops due to an error (e.g., crashes, exits with a non-zero code).\n\n\n\n\n\n\nNever\n: Railway will never automatically restart your service, even if it crashes.\n\n\n\n\n\n\nPlan limitations\n\n\nUsers on the Free plan and those trialing the platform have some limitations on the restart policy:\n\n\n\n\n\n\nAlways\n Is not available.\n\n\n\n\n\n\nOn Failure\n is limited to 10 restarts.\n\n\n\n\n\n\nUsers on paid plans can set any restart policy with any number of restarts.\nPrev\n \nHealthchecks\nNext\n \nMonorepo\nEdit this file on GitHub\nOn This Page\nWhat does each policy mean?\nPlan limitations"
  },
  {
    "url": "https://docs.railway.app/guides/rocket",
    "title": "Deploy a Rust Rocket App | Railway Docs",
    "content": "Deploy a Rust Rocket App\nRocket\n is a web framework for Rust that makes it simple to write fast, type-safe, secure web applications with incredible usability, productivity and performance.\n\n\nThis guide covers how to deploy a Rocket app to Railway in four ways:\n\n\n\n\nOne-click deploy from a template\n.\n\n\nFrom a GitHub repository\n.\n\n\nUsing the CLI\n.\n\n\nUsing a Dockerfile\n.\n\n\n\n\nNow, let's create a Rocket app! ðŸš€\n\n\nCreate a Rocket App\n\n\nNote:\n If you already have a Rocket app locally or on GitHub, you can skip this step and go straight to the \nDeploy Rocket App to Railway\n.\n\n\nTo create a new Rocket app, ensure that you have \nRust\n installed on your machine.\n\n\nRun the following command in your terminal to create a new Rust app:\n\n\ncargo new helloworld --bin\n\n\nThe command creates a new binary-based Cargo project in a \nhelloworld\n directory.\n\n\nNext, \ncd\n into the directory and add Rocket as a dependency by running the following command:\n\n\ncargo \nadd\n rocket\n\n\nThis will add Rocket as a dependency, and youâ€™ll see it listed in your \nCargo.toml\n file.\n\n\nModify the Application File\n\n\nNext, open the app in your IDE and navigate to the \nsrc/main.rs\n file.\n\n\nReplace the content with the code below:\n\n\n#[macro_use]\n \n\nextern\n \ncrate\n \nrocket\n;\n\n\n\n\n#[get(\n\"/\"\n)]\n\n\nfn\n \nindex\n(\n)\n \n->\n \n&\n'static\n \nstr\n \n{\n\n\n    \n\"Hello world, Rocket!\"\n\n\n}\n\n\n\n\n#[launch]\n\n\nfn\n \nrocket\n(\n)\n \n->\n _ \n{\n\n\n    \nrocket\n::\nbuild\n(\n)\n.\nmount\n(\n\"/\"\n,\n \nroutes!\n[\nindex\n]\n)\n\n\n}\n\n\nThe code above uses the Rocket framework to create a basic web server that responds to HTTP requests. It defines a simple route using the \n#[get(\"/\")]\n macro, which tells Rocket to handle GET requests to the root URL \n(/)\n.\n\n\nThe \nindex()\n function is the handler for this route and returns a static string, \n\"Hello world, Rocket!\"\n, which will be sent as the response when the root URL is accessed.\n\n\nThe \n#[launch]\n attribute on the \nrocket()\n function marks it as the entry point to launch the application. Inside \nrocket()\n, the server is built with \nrocket::build()\n and the index route is mounted to the root path \n/\n using \nmount()\n.\n\n\nWhen the application runs, it listens for incoming requests and serves the \"Hello world, Rocket!\" response for requests made to the root URL, demonstrating a simple routing and response mechanism in Rocket.\n\n\nRun the Rocket App locally\n\n\nRun the following command in the \nhelloworld\n directory via the terminal:\n\n\ncargo run\n\n\nAll the dependencies will be installed and your app will be launched.\n\n\nOpen your browser and go to \nhttp://localhost:8000\n to see your app.\n\n\nDeploy the Rocket App to Railway\n\n\nRailway offers multiple ways to deploy your Rocket app, depending on your setup and preference.\n\n\nOne-Click Deploy from a Template\n\n\nIf youâ€™re looking for the fastest way to get started, the one-click deploy option is ideal.\n\n\nClick the button below to begin:\n\n\n\n\nWe highly recommend that \nyou eject from the template after deployment\n to create a copy of the repo on your GitHub account.\n\n\nNote:\n You can also choose from a \nvariety of Rocket templates\n created by the community.\n\n\nDeploy from the CLI\n\n\n\n\n\n\nInstall the Railway CLI\n:\n\n\n\n\nInstall the CLI\n and \nauthenticate it\n using your Railway account.\n\n\n\n\n\n\n\n\nInitialize a Railway Project\n:\n\n\n\n\nRun the command below in your Rocket app directory.\n\n\nrailway init\n\n\n\n\nFollow the prompts to name your project.\n\n\nAfter the project is created, click the provided link to view it in your browser.\n\n\n\n\n\n\n\n\nDeploy the Application\n:\n\n\n\n\nUse the command below to deploy your app:\n\n\nrailway up\n\n\n\n\nThis command will scan, compress and upload your app's files to Railway. Youâ€™ll see real-time deployment logs in your terminal.\n\n\n\n\n\n\n\n\nSet Up a Public URL\n:\n\n\n\n\nNavigate to the \nNetworking\n section under the \nSettings\n tab of your new service.\n\n\nClick \nGenerate Domain\n to create a public URL for your app.\n\n\n\n\nNote:\n You'll come across a 502 error where your application doesn't respond. We'll fix that in the next step.\n\n\n\n\n\n\nConfigure Rocket app to accept non-local connections\n:\n\n\n\n\nRocket apps need to be configured to accept external connections by listening on the correct address, which is typically \n0.0.0.0\n. You can easily do this by setting the address through the environment variable.\nRun the following command to set the Rocket address to \n0.0.0.0\n:\n\n\nrailway variables --set \n\"ROCKET_ADDRESS=0.0.0.0\"\n\n\n\n\n\n\n\n\n\n\nRedeploy the Service\n:\n\n\n\n\nRun \nrailway up\n again to trigger a redeployment of the service.\n\n\n\n\n\n\n\n\nVerify the Deployment\n:\n\n\n\n\nOnce the deployment completes, go to \nView logs\n to check if the server is running successfully. Access your public URL again and you should see your app working well.\n\n\n\n\n\n\n\n\n\n\nDeploy from a GitHub Repo\n\n\nTo deploy a Rocket app to Railway directly from GitHub, follow the steps below:\n\n\n\n\n\n\nCreate a New Project on Railway\n:\n\n\n\n\nGo to \nRailway\n to create a new project.\n\n\n\n\n\n\n\n\nDeploy from GitHub\n:\n\n\n\n\nSelect \nDeploy from GitHub repo\n and choose your repository.\n\n\n\n\nIf your Railway account isnâ€™t linked to GitHub yet, youâ€™ll be prompted to do so.\n\n\n\n\n\n\n\n\n\n\n\n\nAdd Environment Variables\n:\n\n\n\n\nClick \nAdd Variables\n, then add \nROCKET_ADDRESS\n with the value \n0.0.0.0\n. This allows your Rocket app to accept external connections by listening on \n0.0.0.0\n.\n\n\n\n\n\n\n\n\nDeploy the App\n:\n\n\n\n\nClick \nDeploy\n to start the deployment process.\n\n\nOnce the deployed, a Railway \nservice\n will be created for your app, but it wonâ€™t be publicly accessible by default.\n\n\n\n\n\n\n\n\nVerify the Deployment\n:\n\n\n\n\nOnce the deployment completes, go to \nView logs\n to check if the server is running successfully.\n\n\n\n\nNote:\n During the deployment process, Railway will automatically \ndetect that itâ€™s a Rust app\n.\n\n\n\n\n\n\nSet Up a Public URL\n:\n\n\n\n\nNavigate to the \nNetworking\n section under the \nSettings\n tab of your new service.\n\n\nClick \nGenerate Domain\n to create a public URL for your app.\n\n\n\n\n\n\n\n\nUse a Dockerfile\n\n\n\n\nCreate a \nDockerfile\n in the \nhelloworld\n or Rocket app's root directory.\n\n\nAdd the content below to the \nDockerfile\n:\n\n\nFROM\n lukemathwalker/cargo-chef:latest-rust-1 \nAS\n chef\n\n\n\n\n# Create and change to the app directory.\n\n\nWORKDIR\n /app\n\n\n\n\nFROM\n chef \nAS\n planner\n\n\nCOPY\n . ./\n\n\nRUN\n cargo chef prepare --recipe-path recipe.json\n\n\n\n\nFROM\n chef \nAS\n builder \n\n\nCOPY\n \n--from\n=\nplanner\n /app/recipe.json recipe.json\n\n\n\n\n# Build dependencies - this is the caching Docker layer!\n\n\nRUN\n cargo chef cook --release --recipe-path recipe.json\n\n\n\n\n# Build application\n\n\nCOPY\n . ./\n\n\nRUN\n cargo build --release\n\n\n\n\nCMD\n [\n\"./target/release/helloworld\"\n]\n\n\n\n\nEither deploy via the CLI or from GitHub.\n\n\n\n\nRailway automatically detects the \nDockerfile\n, \nand uses it to build and deploy the app.\n\n\nNote:\n Railway supports also \ndeployment from public and private Docker images\n.\n\n\nThis guide covers the main deployment options on Railway. Choose the approach that suits your setup, and start deploying your Rocket apps seamlessly!\n\n\nNext Steps\n\n\nExplore these resources to learn how you can maximize your experience with Railway:\n\n\n\n\nAdd a Database Service\n\n\nMonitor your app\n\n\nPrev\n \nAxum\nNext\n \nLaravel\nEdit this file on GitHub\nOn This Page\nCreate a Rocket App\nModify the Application File\nRun the Rocket App locally\nDeploy the Rocket App to Railway\nOne-Click Deploy from a Template\nDeploy from the CLI\nDeploy from a GitHub Repo\nUse a Dockerfile\nNext Steps"
  },
  {
    "url": "https://docs.railway.app/guides/sails",
    "title": "Deploy a Sails App | Railway Docs",
    "content": "Deploy a Sails App\nSails\n is a MVC framework for Node.js. It is designed to emulate the familiar MVC pattern of frameworks like Ruby on Rails, but with support for the requirements of modern apps: data-driven APIs with a scalable, service-oriented architecture.\n\n\nSails makes it easy to build custom, enterprise-grade Node.js apps.\n\n\nCreate a Sails App\n\n\nNote:\n If you already have a Sails app locally or on GitHub, you can skip this step and go straight to the \nDeploy Sails App on Railway\n.\n\n\nTo create a new Sails app, ensure that you have \nNode\n installed on your machine.\n\n\nRun the following command in your terminal to install Sails:\n\n\nnpm\n \ninstall\n sails -g\n\n\nNext, run the command below to create a new Sails app\n\n\nsails new workapp\n\n\nSelect \nWeb App\n as the template for your new Sails app. Once the dependencies have been installed, \ncd\n into the \nworkapp\n directory and run \nsails lift\n to start your app.\n\n\nOpen your browser and go to \nhttp://localhost:1337\n to see your app.\n\n\nNow, let's deploy to Railway!\n\n\nDeploy Sails App on Railway\n\n\nRailway offers multiple ways to deploy your Sails app, depending on your setup and preference. Choose any of the following methods:\n\n\n\n\nOne-click deploy from a template\n.\n\n\nUsing the CLI\n.\n\n\nFrom a GitHub repository\n.\n\n\n\n\nOne-Click Deploy from a Template\n\n\nIf youâ€™re looking for the fastest way to get started, the one-click deploy option is ideal. It sets up a Sails app along with a Postgres database and Redis.\n\n\nClick the button below to begin:\n\n\n\n\nAfter deploying, we recommend that you \neject from the template\n to create a copy of the repository under your own GitHub account. This will give you full control over the source code and project.\n\n\nDeploy from the CLI\n\n\nTo deploy the Sails app using the Railway CLI, please follow the steps:\n\n\n\n\nInstall the Railway CLI\n:\n\n\n\n\nInstall the CLI\n and \nauthenticate it\n using your Railway account.\n\n\n\n\n\n\nInitialize a Railway Project\n:\n\n\n\n\nRun the command below in your Sails app directory.\n\n\nrailway init\n\n\n\n\nFollow the prompts to name your project.\n\n\nAfter the project is created, click the provided link to view it in your browser.\n\n\n\n\n\n\nModify Sails Config\n:\n\n\n\n\nOpen up \nconfig/env/production.js\n file and make some changes:\n\n\n\n\nSet \nhttp.trustProxy\n to \ntrue\n because our app will be behind a proxy.\n\n\nSet \nsession.cookie.secure\n to \ntrue\n\n\nAdd this function to the \nsocket\n object just after the \nonlyAllowOrigins\n array:\n\n\nbeforeConnect\n:\n \nfunction\n(\nhandshake\n,\n proceed\n)\n \n{\n\n\n    \n// Send back `true` to allow the socket to connect.\n\n\n    \n// (Or send back `false` to reject the attempt.)\n\n\n    \nreturn\n \nproceed\n(\nundefined\n,\n \nfalse\n)\n;\n\n\n}\n,\n\n\n\n\n\n\nNote:\n We only added this because we don't need sockets now. If you do, skip this step and add your public app URL to the \nonlyAllowOrigins\n array. The function simply rejects socket connection attempts.\n\n\n\n\n\n\nDeploy the Application\n:\n\n\n\n\nUse the command below to deploy your app:\n\n\nrailway up\n\n\n\n\nThis command will scan, compress and upload your app's files to Railway. Youâ€™ll see real-time deployment logs in your terminal.\n\n\n\n\n\n\n\n\n\n\nNote:\n You'll come across an error about how the default \nsails-disk\n adapter and \nconnect.session()\n MemoryStore  is not designed for use as a production database, donâ€™t worry. Weâ€™ll fix this in the next step.\n\n\n\n\n\n\nAdd PostgreSQL & Redis Database Services\n:\n\n\n\n\nRun \nrailway add\n.\n\n\nSelect \nPostgreSQL\n by pressing space\n\n\nSelect \nRedis\n by also pressing space and hit \nEnter\n to add both database services to your project.\n\n\n\n\n\n\nModify Sails Database Config\n:\n\n\n\n\nOpen up \nconfig/env/production.js\n file and make some changes to let your app know what database to connect to and where to save sessions:\n\n\n\n\nIn the \ndatastores:\n section,\n\n\n\n\nAdd \nadapter: 'sails-postgresql'\n,\n\n\nAdd \nurl: process.env.DATABASE_URL\n\n\n\n\n\n\nIn the \nsession:\n section,\n\n\n\n\nAdd \nadapter: '@sailshq/connect-redis'\n,\n\n\nAdd \nurl: process.env.REDIS_URL\n,\n\n\n\n\n\n\n\n\n\n\nRun \nnpm install sails-postgresql --save\n to add the new adapter to your app locally.\n\n\n\n\n\n\nConfigure Environment Variables on Railway\n:\n\n\n\n\nGo to your app service \nVariables\n section and add the following:\n\n\n\n\nDATABASE_URL\n: Set the value to \n${{Postgres.DATABASE_URL}}\n (this references the URL of your new Postgres database). Learn more about \nreferencing service variables\n.\n\n\nREDIS_URL\n: Set the value to  \n${{Redis.REDIS_URL}}\n (this references the URL of your new Redis Database)\n\n\n\n\n\n\nUse the \nRaw Editor\n to add any other required environment variables in one go.\n\n\n\n\n\n\nRedeploy the Service\n:\n\n\n\n\nClick \nDeploy\n on the Railway dashboard to apply your changes.\n\n\n\n\n\n\nUpload Local Changes\n:\n\n\n\n\nRun \nrailway up\n to upload all the changes we made locally and redeploy our service.\n\n\n\n\n\n\nVerify the Deployment\n:\n\n\n\n\nOnce the deployment completes, go to \nView logs\n to check if the server is running successfully.\n\n\n\n\n\n\nSet Up a Public URL\n:\n\n\n\n\nNavigate to the \nNetworking\n section under the \nSettings\n tab of your new service.\n\n\nClick \nGenerate Domain\n to create a public URL for your app.\n\n\n\n\n\n\n\n\n\n\nDeploy from a GitHub Repo\n\n\nTo deploy the Sails app to Railway, start by pushing the app to a GitHub repo. Once thatâ€™s set up, follow the steps below to complete the deployment process.\n\n\n\n\nCreate a New Project on Railway\n:\n\n\n\n\nGo to \nRailway\n to create a new project.\n\n\n\n\n\n\nDeploy from GitHub\n:\n\n\n\n\nSelect \nDeploy from GitHub repo\n and choose your repository.\n\n\n\n\nIf your Railway account isnâ€™t linked to GitHub yet, youâ€™ll be prompted to do so.\n\n\n\n\n\n\n\n\n\n\nAdd Environment Variables\n:\n\n\n\n\nClick \nAdd Variables\n and configure all the necessary environment variables for your app.\n\n\n\n\n\n\nDeploy the App\n:\n\n\n\n\nClick \nDeploy\n to start the deployment process.\n\n\nOnce the deployed, a Railway \nservice\n will be created for your app, but it wonâ€™t be publicly accessible by default.\n\n\n\n\n\n\nAdd a Database Service\n:\n\n\n\n\nRight-click on the Railway project canvas or click the \nCreate\n button.\n\n\nSelect \nDatabase\n.\n\n\nSelect \nAdd PostgreSQL\n from the available databases.\n\n\n\n\nThis will create and deploy a new Postgres database service for your project.\n\n\n\n\n\n\n\n\n\n\nAdd a Redis Database Service\n:\n\n\n\n\nRight-click on the Railway project canvas or click the \nCreate\n button.\n\n\nSelect \nDatabase\n.\n\n\nSelect \nAdd Redis\n from the available databases.\n\n\n\n\nThis will create and deploy a new Redis database service for your project.\n\n\n\n\n\n\n\n\n\n\nConfigure Environment Variables\n:\n\n\n\n\nGo to your app service \nVariables\n section and add the following:\n\n\n\n\nDATABASE_URL\n: Set the value to \n${{Postgres.DATABASE_URL}}\n (this references the URL of your new Postgres database). Learn more about \nreferencing service variables\n.\n\n\nREDIS_URL\n: Set the value to  \n${{Redis.REDIS_URL}}\n (this references the URL of your new Redis Database)\n\n\n\n\n\n\nUse the \nRaw Editor\n to add any other required environment variables in one go.\n\n\n\n\n\n\nModify Sails Config\n:\n\n\n\n\nFollow \nsteps 3 & 5 mentioned in the CLI guide\n.\n\n\n\n\n\n\nRedeploy the Service\n:\n\n\n\n\nClick \nDeploy\n on the Railway dashboard to apply your changes.\n\n\n\n\n\n\nVerify the Deployment\n:\n\n\n\n\nOnce the deployment completes, go to \nView logs\n to check if the server is running successfully.\n\n\n\n\n\n\nSet Up a Public URL\n:\n\n\n\n\nNavigate to the \nNetworking\n section under the \nSettings\n tab of your new service.\n\n\nClick \nGenerate Domain\n to create a public URL for your app.\n\n\n\n\n\n\n\n\nThis guide covers the main deployment options on Railway. Choose the approach that suits your setup, and start deploying your Sails apps effortlessly!\n\n\nHereâ€™s how your setup should look:\n\n\n\n\nBy following these steps, youâ€™ll have a fully functional Sails app. If you run into any issues or need to make adjustments, check the logs and revisit your environment variable configurations.\n\n\nThe Boring JavaScript Stack Sails Starter\n\n\nIf you're a fan of \nThe Boring JavaScript Stack\n, weâ€™ve got a one-click deploy option for you.\n\n\nSimply click the button below to get started:\n\n\n\n\nNote:\n After deploying, we recommend \nejecting from the template\n to create your own GitHub repository. This will give you full control over the project and source code.\n\n\nNext Steps\n\n\nExplore these resources to learn how you can maximize your experience with Railway:\n\n\n\n\nMonitoring\n\n\nDeployments\n\n\nPrev\n \nPlay\nNext\n \nDjango\nEdit this file on GitHub\nOn This Page\nCreate a Sails App\nDeploy Sails App on Railway\nOne-Click Deploy from a Template\nDeploy from the CLI\nDeploy from a GitHub Repo\nThe Boring JavaScript Stack Sails Starter\nNext Steps"
  },
  {
    "url": "https://docs.railway.app/guides/services",
    "title": "Managing Services | Railway Docs",
    "content": "Managing Services\nA Railway Service is a deployment target for your application.\n\n\nAs you create and manage your services, your changes will be collected in a set of \nstaged changes\n that you must review and deploy, in order to apply them.\n\n\nCreating a Service\n\n\nCreate a service by clicking the \nNew\n button in the top right corner of your project canvas, or by typing new service from the \ncommand palette\n, accessible via \nCMD + K\n (Mac) or \nCtrl + K\n(Windows).\n\n\n\n\nServices on Railway can be deployed from a GitHub repository, a local directory, or a Docker image.\n\n\nAccessing Service Settings\n\n\nTo access a service's settings, simply click on the service tile from your project canvas and go to the Settings tab.\n\n\nDefining a Deployment Source\n\n\nIf you've created an empty service, or would like to update the source for a deployed service, you can do so in the Service settings.\n\n\nClick on the service, go to the Settings tab, and find the \nService Source\n setting.\n\n\n\n\nDeploying From a GitHub Repo\n\n\nDefine a GitHub repository as your service source by selecting \nConnect Repo\n and choosing the repository you'd like to deploy.\n\n\nWhen a new commit is pushed to the linked branch, Railway will automatically build and deploy the new code.\n\n\n\n\nYou must link your Railway account to GitHub, to enable Railway to connect to your GitHub repositories. \nYou can configure the Railway App in GitHub by clicking this link.\n\n\nDeploying a Public Docker Image\n\n\nTo deploy a public Docker image, specify the path of the image when prompted in the creation flow.\n\n\nRailway can deploy images from \nDocker Hub\n, \nGitHub Container Registry\n, \nQuay.io\n, or \nGitLab Container Registry\n. Example paths -\n\n\nDocker Hub:\n\n\n\n\nbitnami/redis\n\n\n\n\nGitHub Container Registry:\n\n\n\n\nghcr.io/railwayapp-templates/postgres-ssl:latest\n\n\n\n\nGitLab Container Registry:\n\n\n\n\nregistry.gitlab.com/gitlab-cicd15/django-project\n\n\n\n\nMicrosoft Container Registry:\n\n\n\n\nmcr.microsoft.com/dotnet/aspire-dashboard\n\n\n\n\nQuay.io:\n\n\n\n\nquay.io/username/repo:tag\n\n\n\n\nDeploying a Private Docker Image\n\n\nIf you'd like to deploy from a private Docker registry, ensure you're on the \nPro plan\n.\n\n\nTo deploy from a private Docker registry, specify the path of the image when prompted in the creation flow, as well as authentication credentials (username, password) to the registry.\n\n\n\n\nIf deploying an image from \nGitHub Container Registry\n, provide a \npersonal access token (classic)\n.\n\n\nDeploying From a Local Directory\n\n\nUse the CLI\n to deploy a local directory to a service -\n\n\n\n\nCreate an Empty Service by choosing \nEmpty Service\n during the service creation flow.\n\n\nIn a Terminal, navigate to the directory you would like to deploy.\n\n\nLink to your Railway project using the \nrailway link\n CLI command.\n\n\nDeploy the directory using \nrailway up\n. The CLI will prompt you to choose a service target, be sure to choose the empty service you created.\n\n\n\n\nDeploying a Monorepo\n\n\nFor information on how to deploy a Monorepo click \nhere\n.\n\n\nMonitoring\n\n\nLogs, metrics, and usage information is available for services and projects. Check out the \nmonitoring guides\n for information on how to track this data.\n\n\nChanging the Service Icon\n\n\nCustomize your project canvas for easier readability by changing the service icon.\n\n\n\n\nRight click on the service\n\n\nChoose \nUpdate Info\n\n\nChoose \nIcon\n\n\nBegin typing to see a list of available icons, pulled from our \ndevicons\nservice.\n\n\n\n\nYou can also access this configuration from the command palette.\n\n\nApproving a Deployment\n\n\nIf a member of a GitHub repo doesn't have a linked Railway account. Railway by default will not deploy any pushes to a connected GitHub branch within Railway.\n\n\nRailway will then create a Deployment Approval within a Service prompting a user to determine if they want to deploy their commit or not.\n\n\n\n\nDeploy the queued deployment by clicking the \"Approve\" button. You can dismiss the request by clicking the three dots menu and clicking \"Reject\".\n\n\nStoring Data\n\n\nEvery service has access to 10GB of ephemeral storage. If your service requires data to persist between deployments, or needs more than 10GB of storage, you should add a \nvolume\n.\n\n\nDeleting a Service\n\n\nDelete a service by opening the project's settings and scrolling to the danger section.\nPrev\n \nStaged Changes\nNext\n \nVariables\nEdit this file on GitHub\nOn This Page\nCreating a Service\nAccessing Service Settings\nDefining a Deployment Source\nDeploying From a GitHub Repo\nDeploying a Public Docker Image\nDeploying a Private Docker Image\nDeploying From a Local Directory\nDeploying a Monorepo\nMonitoring\nChanging the Service Icon\nApproving a Deployment\nStoring Data\nDeleting a Service"
  },
  {
    "url": "https://docs.railway.app/guides/solid",
    "title": "Deploy a SolidJS App | Railway Docs",
    "content": "Deploy a SolidJS App\nSolidJS\n is a modern JavaScript library for building responsive and high-performing user interfaces for web applications.\n\n\nIt uses fine-grained reactivity, meaning it updates only when the data your app actually depends on changes. This minimizes unnecessary work, leading to faster load times and a seamless user experience.\n\n\nThis guide covers how to deploy a Solid app to Railway in four ways:\n\n\n\n\nOne-click deploy from a template\n.\n\n\nFrom a GitHub repository\n.\n\n\nUsing the CLI\n.\n\n\nUsing a Dockerfile\n.\n\n\n\n\nNow, let's create a Solid app!\n\n\nCreate a Solid App\n\n\nNote:\n If you already have a Solid app locally or on GitHub, you can skip this step and go straight to the \nDeploy Solid App on Railway\n.\n\n\nTo create a new Solid app, ensure that you have \nNode\n installed on your machine.\n\n\nRun the following command in your terminal to create a new Solid app from a template:\n\n\nnpx degit solidjs/templates/js solidjsapp\n\n\nA new Solid app will be provisioned for you in the \nsolidjsapp\n directory.\n\n\nRun the Solid App locally\n\n\nNext, \ncd\n into the directory and install the dependencies.\n\n\nnpm\n \ninstall\n\n\nStart the Vite development server by running the following command:\n\n\nnpm\n run dev\n\n\nOpen your browser and go to \nhttp://localhost:3000\n to see your app.\n\n\nDeploy the Solid App to Railway\n\n\nRailway offers multiple ways to deploy your Solid app, depending on your setup and preference.\n\n\nOne-Click Deploy from a Template\n\n\nIf youâ€™re looking for the fastest way to get started, the one-click deploy option is ideal.\n\n\nClick the button below to begin:\n\n\n\n\nWe highly recommend that \nyou eject from the template after deployment\n to create a copy of the repo on your GitHub account.\n\n\nDeploy from the CLI\n\n\n\n\nInstall the Railway CLI\n:\n\n\n\n\nInstall the CLI\n and \nauthenticate it\n using your Railway account.\n\n\n\n\n\n\nInitialize a Railway Project\n:\n\n\n\n\nRun the command below in your Solid app directory.\n\n\nrailway init\n\n\n\n\nFollow the prompts to name your project.\n\n\nAfter the project is created, click the provided link to view it in your browser.\n\n\n\n\n\n\nDeploy the Application\n:\n\n\n\n\nUse the command below to deploy your app:\n\n\nrailway up\n\n\n\n\nThis command will scan, compress and upload your app's files to Railway. Youâ€™ll see real-time deployment logs in your terminal.\n\n\nOnce the deployment completes, go to \nView logs\n to check if the service is running successfully.\n\n\n\n\n\n\nSet Up a Public URL\n:\n\n\n\n\nNavigate to the \nNetworking\n section under the \nSettings\n tab of your new service.\n\n\nClick \nGenerate Domain\n to create a public URL for your app.\n\n\n\n\n\n\n\n\n\n\nDeploy from a GitHub Repo\n\n\nTo deploy a Solid app to Railway directly from GitHub, follow the steps below:\n\n\n\n\nCreate a New Project on Railway\n:\n\n\n\n\nGo to \nRailway\n to create a new project.\n\n\n\n\n\n\nDeploy from GitHub\n:\n\n\n\n\nSelect \nDeploy from GitHub repo\n and choose your repository.\n\n\n\n\nIf your Railway account isnâ€™t linked to GitHub yet, youâ€™ll be prompted to do so.\n\n\n\n\n\n\n\n\n\n\nDeploy the App\n:\n\n\n\n\nClick \nDeploy\n to start the deployment process.\n\n\nOnce deployed, a Railway \nservice\n will be created for your app, but it wonâ€™t be publicly accessible by default.\n\n\n\n\n\n\nVerify the Deployment\n:\n\n\n\n\nOnce the deployment completes, go to \nView logs\n to check if the server is running successfully.\n\n\n\n\n\n\nSet Up a Public URL\n:\n\n\n\n\nNavigate to the \nNetworking\n section under the \nSettings\n tab of your new service.\n\n\nClick \nGenerate Domain\n to create a public URL for your app.\n\n\n\n\n\n\n\n\nUse a Dockerfile\n\n\n\n\nCreate a \nDockerfile\n in the \nsolidjsapp\n or Solid app's root directory.\n\n\nAdd the content below to the \nDockerfile\n:\n\n\n# Use the Node alpine official image\n\n\n# https://hub.docker.com/_/node\n\n\nFROM\n node:lts-alpine \nAS\n build\n\n\n\n\n# Set config\n\n\nENV\n NPM_CONFIG_UPDATE_NOTIFIER=false\n\n\nENV\n NPM_CONFIG_FUND=false\n\n\n\n\n# Create and change to the app directory.\n\n\nWORKDIR\n /app\n\n\n\n\n# Copy the files to the container image\n\n\nCOPY\n package*.json ./\n\n\n\n\n# Install packages\n\n\nRUN\n npm ci\n\n\n\n\n# Copy local code to the container image.\n\n\nCOPY\n . ./\n\n\n\n\n# Build the app.\n\n\nRUN\n npm run build\n\n\n\n\n# Use the Caddy image\n\n\nFROM\n caddy\n\n\n\n\n# Create and change to the app directory.\n\n\nWORKDIR\n /app\n\n\n\n\n# Copy Caddyfile to the container image.\n\n\nCOPY\n Caddyfile ./\n\n\n\n\n# Copy local code to the container image.\n\n\nRUN\n caddy fmt Caddyfile --overwrite\n\n\n\n\n# Copy files to the container image.\n\n\nCOPY\n \n--from\n=\nbuild\n /app/dist ./dist\n\n\n\n\n# Use Caddy to run/serve the app\n\n\nCMD\n [\n\"caddy\"\n, \n\"run\"\n, \n\"--config\"\n, \n\"Caddyfile\"\n, \n\"--adapter\"\n, \n\"caddyfile\"\n]\n\n\nThe \nDockerfile\n will use Caddy to serve the Solid app.\n\n\nAdd a \nCaddyfile\n to the app's root directory:\n\n\n{\n\n\n    \n# global options\n\n\n    admin off \n# theres no need for the admin api in railway's environment\n\n\n    persist_config off \n# storage isn't persistent anyway\n\n\n    auto_https off \n# railway handles https for us, this would cause issues if left enabled\n\n\n    \n# runtime logs\n\n\n    log \n{\n\n\n        \nformat\n json \n# set runtime log format to json mode \n\n\n    \n}\n\n\n    \n# server options\n\n\n    servers \n{\n\n\n        trusted_proxies static private_ranges \n100.0\n.0.0/8 \n# trust railway's proxy\n\n\n    \n}\n\n\n}\n\n\n\n\n# site block, listens on the $PORT environment variable, automatically assigned by railway\n\n\n:\n{\n$PORT\n:3000\n}\n \n{\n\n\n    \n# access logs\n\n\n    log \n{\n\n\n        \nformat\n json \n# set access log format to json mode\n\n\n    \n}\n\n\n\n\n    \n# health check for railway\n\n\n    rewrite /health /*\n\n\n\n    \n# serve from the 'dist' folder (Vite builds into the 'dist' folder)\n\n\n    root * dist\n\n\n\n    \n# enable gzipping responses\n\n\n    encode \ngzip\n\n\n\n\n    \n# serve files from 'dist'\n\n\n    file_server\n\n\n\n    \n# if path doesn't exist, redirect it to 'index.html' for client side routing\n\n\n    try_files \n{\npath\n}\n /index.html\n\n}\n\n\n\n\nEither deploy via the CLI or from GitHub.\n\n\n\n\nRailway automatically detects the \nDockerfile\n, \nand uses it to build and deploy the app.\n\n\nNote:\n Railway supports also \ndeployment from public and private Docker images\n.\n\n\nThis guide covers the main deployment options on Railway. Choose the approach that suits your setup, and start deploying your Solid apps seamlessly!\n\n\nNext Steps\n\n\nExplore these resources to learn how you can maximize your experience with Railway:\n\n\n\n\nAdd a Database Service\n\n\nMonitor your app\n\n\nPrev\n \nSvelteKit\nNext\n \nPhoenix\nEdit this file on GitHub\nOn This Page\nCreate a Solid App\nRun the Solid App locally\nDeploy the Solid App to Railway\nOne-Click Deploy from a Template\nDeploy from the CLI\nDeploy from a GitHub Repo\nUse a Dockerfile\nNext Steps"
  },
  {
    "url": "https://docs.railway.app/guides/spring-boot",
    "title": "Deploy a Spring Boot App | Railway Docs",
    "content": "Deploy a Spring Boot App\nSpring Boot\n is a Java framework designed to simplify the creation of stand-alone, production-ready Spring applications that are easy to run right out of the box.\n\n\nThis guide covers how to deploy a Spring Boot app to Railway in four ways:\n\n\n\n\nOne-click deploy from a template\n.\n\n\nFrom a GitHub repository\n.\n\n\nUsing the CLI\n.\n\n\nUsing a Dockerfile\n.\n\n\n\n\nNow, let's create a Spring Boot app!\n\n\nCreate a Spring Boot App\n\n\nNote:\n If you already have a Spring Boot app locally or on GitHub, you can skip this step and go straight to the \nDeploy Spring Boot App to Railway\n.\n\n\nTo create a new Spring Boot app, ensure that you have \nJDK\n installed on your machine.\n\n\nGo to \nstart.spring.io\n to initialize a new Spring Boot app. Select the options below to customize and generate your starter app.\n\n\n\n\nProject: Maven\n\n\nLanguage: Java\n\n\nSpring Boot: 3.3.4\n\n\nProject Metadata:\n\n\n\n\nGroup: com.railwayguide\n\n\nArtifact: helloworld\n\n\nName: helloworld\n\n\nDescription: Demo project for Railway Guide\n\n\nPackage name: com.railwayguide.helloworld\n\n\nPackaging: jar\n\n\nJava: 17\n\n\n\n\n\n\nDependencies:\n\n\n\n\nClick the \nAdd Dependencies\n button and search for \nSpring Web\n. Select it.\n\n\n\n\n\n\n\n\n\n\nConfig to initialize our new app\n\n\nNow, click on the \nGenerate\n button, download the zipped file and unpack it into a folder on your machine.\n\n\nModify the Application File\n\n\nNext, open the app in your IDE and navigate to the \nsrc/main/java/com/railwayguide/helloworld/HelloWorldApplication.java\n file.\n\n\nReplace the content with the code below:\n\n\npackage\n \ncom\n.\nrailwayguide\n.\nhelloworld\n;\n\n\n\n\nimport\n \norg\n.\nspringframework\n.\nboot\n.\nSpringApplication\n;\n\n\nimport\n \norg\n.\nspringframework\n.\nboot\n.\nautoconfigure\n.\nSpringBootApplication\n;\n\n\nimport\n \norg\n.\nspringframework\n.\nweb\n.\nbind\n.\nannotation\n.\nGetMapping\n;\n\n\nimport\n \norg\n.\nspringframework\n.\nweb\n.\nbind\n.\nannotation\n.\nRestController\n;\n\n\n\n\n@SpringBootApplication\n\n\n@RestController\n\n\npublic\n \nclass\n \nHelloworldApplication\n \n{\n\n\n\n\n\t\npublic\n \nstatic\n \nvoid\n \nmain\n(\nString\n[\n]\n args\n)\n \n{\n\n\n\t\t\nSpringApplication\n.\nrun\n(\nHelloworldApplication\n.\nclass\n,\n args\n)\n;\n\n\n\t\n}\n\n\n\n\n\t\n@GetMapping\n(\n\"/\"\n)\n\n\n    \npublic\n \nString\n \nhello\n(\n)\n \n{\n\n\n      \nreturn\n \nString\n.\nformat\n(\n\"Hello world from Java Spring Boot!\"\n)\n;\n\n\n    \n}\n\n\n\n\n}\n\n\nWe added a \nhello()\n method that returns the response: \nHello world from Java Spring Boot!\n.\n\n\nThe \n@RestController\n annotation designates this class as a web controller, while \n@GetMapping(\"/\")\n maps the \nhello()\n method to handle requests sent to the root URL, \n/\n.\n\n\nRun the Spring Boot App locally\n\n\nNext, \ncd\n into the \nhelloworld\n directory via the terminal and run the following Maven command:\n\n\n./mvnw spring-boot:run\n\n\nNote:\n This is a Maven wrapper for Linux and macOS, which uses a bundled version of Maven from \n.mvn/wrapper/maven-wrapper.jar\n instead of relying on the system-installed version.\n\n\nOpen your browser and go to \nhttp://localhost:8080\n to see your app.\n\n\nDeploy the Spring Boot App to Railway\n\n\nRailway offers multiple ways to deploy your Spring Boot app, depending on your setup and preference.\n\n\nOne-Click Deploy from a Template\n\n\nIf youâ€™re looking for the fastest way to get started, the one-click deploy option is ideal.\n\n\nClick the button below to begin:\n\n\n\n\nWe highly recommend that \nyou eject from the template after deployment\n to create a copy of the repo on your GitHub account.\n\n\nNote:\n You can also choose from a \nvariety of Spring Boot app templates\n created by the community.\n\n\nDeploy from the CLI\n\n\n\n\nInstall the Railway CLI\n:\n\n\n\n\nInstall the CLI\n and \nauthenticate it\n using your Railway account.\n\n\n\n\n\n\nInitialize a Railway Project\n:\n\n\n\n\nRun the command below in your Spring Boot app directory.\n\n\nrailway init\n\n\n\n\nFollow the prompts to name your project.\n\n\nAfter the project is created, click the provided link to view it in your browser.\n\n\n\n\n\n\nDeploy the Application\n:\n\n\n\n\nUse the command below to deploy your app:\n\n\nrailway up\n\n\n\n\nThis command will scan, compress and upload your app's files to Railway. Youâ€™ll see real-time deployment logs in your terminal.\n\n\nOnce the deployment completes, go to \nView logs\n to check if the service is running successfully.\n\n\n\n\n\n\nSet Up a Public URL\n:\n\n\n\n\nNavigate to the \nNetworking\n section under the \nSettings\n tab of your new service.\n\n\nClick \nGenerate Domain\n to create a public URL for your app.\n\n\n\n\n\n\n\n\n\n\nDeploy from a GitHub Repo\n\n\nTo deploy a Spring Boot app to Railway directly from GitHub, follow the steps below:\n\n\n\n\n\n\nCreate a New Project on Railway\n:\n\n\n\n\nGo to \nRailway\n to create a new project.\n\n\n\n\n\n\n\n\nDeploy from GitHub\n:\n\n\n\n\nSelect \nDeploy from GitHub repo\n and choose your repository.\n\n\n\n\nIf your Railway account isnâ€™t linked to GitHub yet, youâ€™ll be prompted to do so.\n\n\n\n\n\n\n\n\n\n\n\n\nDeploy the App\n:\n\n\n\n\nClick \nDeploy\n to start the deployment process.\n\n\nOnce the deployed, a Railway \nservice\n will be created for your app, but it wonâ€™t be publicly accessible by default.\n\n\n\n\n\n\n\n\nVerify the Deployment\n:\n\n\n\n\nOnce the deployment completes, go to \nView logs\n to check if the server is running successfully.\n\n\n\n\nNote:\n During the deployment process, Railway will automatically \ndetect that itâ€™s a Java app\n.\n\n\n\n\n\n\nSet Up a Public URL\n:\n\n\n\n\nNavigate to the \nNetworking\n section under the \nSettings\n tab of your new service.\n\n\nClick \nGenerate Domain\n to create a public URL for your app.\n\n\n\n\n\n\n\n\nUse a Dockerfile\n\n\n\n\nCreate a \nDockerfile\n in the \nhelloworld\n or Spring Boot app's root directory.\n\n\nAdd the content below to the \nDockerfile\n:\n\n\n# Use the Eclipse temurin alpine official image\n\n\n# https://hub.docker.com/_/eclipse-temurin\n\n\nFROM eclipse-temurin:21-jdk-alpine\n\n\n\n# Create and change to the app directory.\n\n\nWORKDIR /app\n\n\n\n# Copy local code to the container image.\n\n\nCOPY \n.\n ./\n\n\n\n# Build the app.\n\n\nRUN ./mvnw -DoutputFile\n=\ntarget/mvn-dependency-list.log -B -DskipTests clean dependency:list \ninstall\n\n\n\n\n# Run the app by dynamically finding the JAR file in the target directory\n\n\nCMD \n[\n\"sh\"\n, \n\"-c\"\n, \n\"java -jar target/*.jar\"\n]\n\n\n\n\nEither deploy via the CLI or from GitHub.\n\n\n\n\nRailway automatically detects the \nDockerfile\n, \nand uses it to build and deploy the app.\n\n\nNote:\n Railway supports also \ndeployment from public and private Docker images\n.\n\n\nThis guide covers the main deployment options on Railway. Choose the approach that suits your setup, and start deploying your Spring Boot apps seamlessly!\n\n\nNext Steps\n\n\nExplore these resources to learn how you can maximize your experience with Railway:\n\n\n\n\nAdd a Database Service\n\n\nMonitor your app\n\n\nPrev\n \nNuxt\nNext\n \nAstro\nEdit this file on GitHub\nOn This Page\nCreate a Spring Boot App\nModify the Application File\nRun the Spring Boot App locally\nDeploy the Spring Boot App to Railway\nOne-Click Deploy from a Template\nDeploy from the CLI\nDeploy from a GitHub Repo\nUse a Dockerfile\nNext Steps"
  },
  {
    "url": "https://docs.railway.app/guides/staged-changes",
    "title": "Staged Changes | Railway Docs",
    "content": "Staged Changes\nChanges made in your Railway project, like adding, removing, or making changes to components, will be staged in a changeset for you to review and apply.\n\n\nIt is important to be familiar with this flow as you explore the upcoming guides.\n\n\nWhat to Expect\n\n\nAs you create or update components within your project:\n\n\n\n\nThe number of staged changes will be displayed in a banner on the canvas\n\n\nStaged changes will appear as purple in the UI\n\n\n\n\n\n\nReview and Deploy Changes\n\n\nTo review the staged changes, click the \"Details\" button in the banner.  Here, you will see a diff of old and new values.  You can discard a change by clicking the \"x\" to the right of the change.\n\n\nYou can optionally add a commit message that will appear in the \nactivity feed\n.\n\n\n\n\nClicking \"Deploy\" will deploy all of the changes at once. Any services that are affected will be redeployed.\n\n\nHolding the \"Alt\" key while clicking the \"Deploy\" button allows you to commit the changes without triggering a redeploy.\n\n\nCaveats\n\n\n\n\nNetworking changes are not yet staged and are applied immediately\n\n\nAdding databases or templates will only affect the current environment. However, they do not yet create a commit in the history\n\n\nPrev\n \nProjects\nNext\n \nServices\nEdit this file on GitHub\nOn This Page\nWhat to Expect\nReview and Deploy Changes\nCaveats"
  },
  {
    "url": "https://docs.railway.app/guides/start-command",
    "title": "Set a Start Command | Railway Docs",
    "content": "Set a Start Command\nA start command is the process used to run a Deployment's code, for example \npython main.py\n or \nnpm run start\n.\n\n\nRailway automatically configures the start command based on the code being\ndeployed, see \nBuild and Start Commands\n for more details\n\n\nConfigure the Start Command\n\n\nWhen necessary, start commands may be overridden, like for advanced use-cases such as deploying multiple projects from a single \nmonorepo\n.\n\n\nWhen specifying a start command, the behavior depends on the type of deployment:\n\n\n\n\n\n\nDockerfile / Image\n: the start command overrides the image's \nENTRYPOINT\n in \nexec form\n.\n\n\nIf you need to use environment variables in the start command for services deployed from a Dockerfile or image you will need to wrap your command in a shell -\n\n\n/bin/sh -c \n\"exec python main.py --port \n$PORT\n\"\n\n\nThis is because commands ran in exec form do not support variable expansion.\n\n\n\n\n\n\nNixpacks\n: the start command is ran in a shell process.\n\n\nThis supports the use of environment variables without needing to wrap your command in a shell.\n\n\n\n\n\n\n\n\nDockerfiles & Images\n\n\nIf your service deploys with a Dockerfile or from an image, the start command defaults to the \nENTRYPOINT\n and / or \nCMD\n defined in the Dockerfile.\nPrev\n \nPre-Deploy Command\nNext\n \nDeployment Actions\nEdit this file on GitHub\nOn This Page\nConfigure the Start Command\nDockerfiles & Images"
  },
  {
    "url": "https://docs.railway.app/guides/sveltekit",
    "title": "Deploy a SvelteKit App | Railway Docs",
    "content": "Deploy a SvelteKit App\nSvelteKit\n is a framework for rapidly developing robust, performant web applications using Svelte.\n\n\nThis guide covers how to deploy a SvelteKit app to Railway in four ways:\n\n\n\n\nOne-click deploy from a template\n.\n\n\nFrom a GitHub repository\n.\n\n\nUsing the CLI\n.\n\n\nUsing a Dockerfile\n.\n\n\n\n\nNow, let's create a SvelteKit app!\n\n\nCreate a SvelteKit App\n\n\nNote:\n If you already have a SvelteKit app locally or on GitHub, you can skip this step and go straight to the \nDeploy SvelteKit App to Railway\n.\n\n\nTo create a new SvelteKit app, ensure that you have \nNode\n installed on your machine.\n\n\nRun the following command in your terminal to create a new SvelteKit app using \nVite\n:\n\n\nnpx sv create svelteapp\n\n\nFollow the prompts:\n\n\n\n\nSelect the \nSvelteKit demo\n template.\n\n\nAdd typechecking with Typescript.\n\n\nAdd prettier, eslint, and tailwindcss.\n\n\nNo tailwindcss plugins. Hit enter and move on.\n\n\nSelect \nnpm\n as the package manager to install dependencies.\n\n\n\n\nA new SvelteKit app will be provisioned for you in the \nsvelteapp\n directory.\n\n\nRun the SvelteKit App locally\n\n\nNext, \ncd\n into the directory and start the Vite development server by running the following command:\n\n\nnpm\n run dev\n\n\nOpen your browser and go to \nhttp://localhost:5173\n to see the app. You can play the demo game by visiting the \n/sverdle\n route.\n\n\nPrepare SvelteKit App for deployment\n\n\nFirst, we need to enable SvelteKit Node adapter.\n\n\nSvelteKit adapters\n are plugins that take the built app as input and generate output for deployment. These adapters are used to run your project on deployment platforms.\n\n\nLet's add the Node adapter to the app. Run the command below in your terminal:\n\n\nnpm\n i -D @sveltejs/adapter-node\n\n\nOnce it is installed, add the adapter to the app's \nsvelte.config.js\n file.\n\n\nThe \nsvelte.config.js\n file should look like this:\n\n\nimport\n adapter \nfrom\n \n'@sveltejs/adapter-node'\n;\n\n\nimport\n \n{\n vitePreprocess \n}\n \nfrom\n \n'@sveltejs/vite-plugin-svelte'\n;\n\n\n\n\n/** @type {import('@sveltejs/kit').Config} */\n\n\nconst\n config \n=\n \n{\n\n\n\t\n// Consult https://svelte.dev/docs/kit/integrations\n\n\n\t\n// for more information about preprocessors\n\n\n\t\npreprocess\n:\n \nvitePreprocess\n(\n)\n,\n\n\n\n\n\t\nkit\n:\n \n{\n\n\n\t\t\n// adapter-auto only supports some environments, see https://svelte.dev/docs/kit/adapter-auto for a list.\n\n\n\t\t\n// If your environment is not supported, or you settled on a specific environment, switch out the adapter.\n\n\n\t\t\n// See https://svelte.dev/docs/kit/adapters for more information about adapters.\n\n\n\t\t\nadapter\n:\n \nadapter\n(\n)\n\n\n\t\n}\n\n\n}\n;\n\n\n\n\nexport\n \ndefault\n config\n;\n\n\nNext, we need to add the start script to the \npackage.json\n file.\n\n\nSvelte builds your project into a \nbuild\n directory. The server starts when the server entry point is executed, which is by default located at \nbuild/index.js\n.\n\n\nOpen up the \npackage.json\n file and add the start script. Set it to \nnode build/index.js\n like so:\n\n\n{\n\n\n\t\n\"name\"\n:\n \n\"svelteapp\"\n,\n\n\n\t\n\"version\"\n:\n \n\"0.0.1\"\n,\n\n\n\t\n\"type\"\n:\n \n\"module\"\n,\n\n\n\t\n\"scripts\"\n:\n \n{\n\n\n\t\t\n\"dev\"\n:\n \n\"vite dev\"\n,\n\n\n\t\t\n\"build\"\n:\n \n\"vite build\"\n,\n\n\n\t\t\n\"start\"\n:\n \n\"node build/index.js\"\n,\n\n\n\t\t\n\"preview\"\n:\n \n\"vite preview\"\n,\n\n\n\t\t\n\"check\"\n:\n \n\"svelte-kit sync && svelte-check --tsconfig ./tsconfig.json\"\n,\n\n\n\t\t\n\"check:watch\"\n:\n \n\"svelte-kit sync && svelte-check --tsconfig ./tsconfig.json --watch\"\n,\n\n\n\t\t\n\"format\"\n:\n \n\"prettier --write .\"\n,\n\n\n\t\t\n\"lint\"\n:\n \n\"prettier --check . && eslint .\"\n\n\n\t\n}\n,\n\n\n\t\n\"devDependencies\"\n:\n \n{\n\n\n\t\t\n\"@fontsource/fira-mono\"\n:\n \n\"^5.0.0\"\n,\n\n\n\t\t\n\"@neoconfetti/svelte\"\n:\n \n\"^2.0.0\"\n,\n\n\n\t\t\n\"@sveltejs/adapter-auto\"\n:\n \n\"^3.0.0\"\n,\n\n\n\t\t\n\"@sveltejs/adapter-node\"\n:\n \n\"^5.2.9\"\n,\n\n\n\t\t\n\"@sveltejs/kit\"\n:\n \n\"^2.0.0\"\n,\n\n\n\t\t\n\"@sveltejs/vite-plugin-svelte\"\n:\n \n\"^4.0.0\"\n,\n\n\n\t\t\n\"@types/eslint\"\n:\n \n\"^9.6.0\"\n,\n\n\n\t\t\n\"autoprefixer\"\n:\n \n\"^10.4.20\"\n,\n\n\n\t\t\n\"eslint\"\n:\n \n\"^9.7.0\"\n,\n\n\n\t\t\n\"eslint-config-prettier\"\n:\n \n\"^9.1.0\"\n,\n\n\n\t\t\n\"eslint-plugin-svelte\"\n:\n \n\"^2.36.0\"\n,\n\n\n\t\t\n\"globals\"\n:\n \n\"^15.0.0\"\n,\n\n\n\t\t\n\"prettier\"\n:\n \n\"^3.3.2\"\n,\n\n\n\t\t\n\"prettier-plugin-svelte\"\n:\n \n\"^3.2.6\"\n,\n\n\n\t\t\n\"prettier-plugin-tailwindcss\"\n:\n \n\"^0.6.5\"\n,\n\n\n\t\t\n\"svelte\"\n:\n \n\"^5.0.0\"\n,\n\n\n\t\t\n\"svelte-check\"\n:\n \n\"^4.0.0\"\n,\n\n\n\t\t\n\"tailwindcss\"\n:\n \n\"^3.4.9\"\n,\n\n\n\t\t\n\"typescript\"\n:\n \n\"^5.0.0\"\n,\n\n\n\t\t\n\"typescript-eslint\"\n:\n \n\"^8.0.0\"\n,\n\n\n\t\t\n\"vite\"\n:\n \n\"^5.0.3\"\n\n\n\t\n}\n\n\n}\n\n\npackage.json\n\n\nNow, we are ready to deploy!\n\n\nDeploy the SvelteKit App to Railway\n\n\nRailway offers multiple ways to deploy your SvelteKit app, depending on your setup and preference.\n\n\nOne-Click Deploy from a Template\n\n\nIf youâ€™re looking for the fastest way to get started, the one-click deploy option is ideal.\n\n\nClick the button below to begin:\n\n\n\n\nWe highly recommend that \nyou eject from the template after deployment\n to create a copy of the repo on your GitHub account.\n\n\nNote:\n You can also choose from a \nvariety of Svelte app templates\n created by the community.\n\n\nDeploy from the CLI\n\n\n\n\nInstall the Railway CLI\n:\n\n\n\nInstall the CLI\n and \nauthenticate it\n using your Railway account.\n\n\n\n\n\n\nInitialize a Railway Project\n:\n\n\n\nRun the command below in your SvelteKit app directory.\n\nrailway init\n\n\n\n\nFollow the prompts to name your project.\n\n\nAfter the project is created, click the provided link to view it in your browser.\n\n\n\n\n\n\nDeploy the Application\n:\n\n\n\nUse the command below to deploy your app:\n\nrailway up\n\n\n\n\nThis command will scan, compress and upload your app's files to Railway. Youâ€™ll see real-time deployment logs in your terminal.\n\n\nOnce the deployment completes, go to \nView logs\n to check if the service is running successfully.\n\n\n\n\n\n\nSet Up a Public URL\n:\n\n\n\nNavigate to the \nNetworking\n section under the \nSettings\n tab of your new service.\n\n\nClick \nGenerate Domain\n to create a public URL for your app.\n\n\n\n\n\n\n\n\n\n\nDeploy from a GitHub Repo\n\n\nTo deploy a SvelteKit app to Railway directly from GitHub, follow the steps below:\n\n\n\n\nCreate a New Project on Railway\n:\n\n\n\nGo to \nRailway\n to create a new project.\n\n\n\n\n\n\nDeploy from GitHub\n:\n\n\n\nSelect \nDeploy from GitHub repo\n and choose your repository.\n\n\n\nIf your Railway account isnâ€™t linked to GitHub yet, youâ€™ll be prompted to do so.\n\n\n\n\n\n\n\n\n\n\nDeploy the App\n:\n\n\n\nClick \nDeploy\n to start the deployment process.\n\n\nOnce the deployed, a Railway \nservice\n will be created for your app, but it wonâ€™t be publicly accessible by default.\n\n\n\n\n\n\nVerify the Deployment\n:\n\n\n\nOnce the deployment completes, go to \nView logs\n to check if the server is running successfully.\n\n\n\n\n\n\nSet Up a Public URL\n:\n\n\n\nNavigate to the \nNetworking\n section under the \nSettings\n tab of your new service.\n\n\nClick \nGenerate Domain\n to create a public URL for your app.\n\n\n\n\n\n\n\n\nUse a Dockerfile\n\n\n\n\nCreate a \nDockerfile\n in the SvelteKit app's root directory.\n\n\nAdd the content below to the \nDockerfile\n:\n\n# Use the Node alpine official image\n\n\n# https://hub.docker.com/_/node\n\n\nFROM node:lts-alpine\n\n\n# Create and change to the app directory.\n\n\nWORKDIR /app\n\n\n# Copy the files to the container image\n\n\nCOPY package*.json ./\n\n\n# Install packages\n\n\nRUN \nnpm\n ci\n\n\n\n# Copy local code to the container image.\n\n\nCOPY \n.\n ./\n\n\n\n# Build the app.\n\n\nRUN \nnpm\n run build\n\n\n\n# Serve the app\n\n\nCMD \n[\n\"npm\"\n, \n\"run\"\n, \n\"start\"\n]\n\n\n\n\nEither deploy via the CLI or from GitHub.\n\n\n\n\nRailway automatically detects the \nDockerfile\n, \nand uses it to build and deploy the app.\n\n\nNote:\n Railway supports also \ndeployment from public and private Docker images\n.\n\n\nThis guide covers the main deployment options on Railway. Choose the approach that suits your setup, and start deploying your SvelteKit apps seamlessly!\n\n\nNext Steps\n\n\nExplore these resources to learn how you can maximize your experience with Railway:\n\n\n\n\nAdd a Database Service\n\n\nMonitor your app\n\n\nPrev\n \nAstro\nNext\n \nSolid\nEdit this file on GitHub\nOn This Page\nCreate a SvelteKit App\nRun the SvelteKit App locally\nPrepare SvelteKit App for deployment\nDeploy the SvelteKit App to Railway\nOne-Click Deploy from a Template\nDeploy from the CLI\nDeploy from a GitHub Repo\nUse a Dockerfile\nNext Steps"
  },
  {
    "url": "https://docs.railway.app/guides/symfony",
    "title": "Deploy a Symfony App | Railway Docs",
    "content": "Deploy a Symfony App\nSymfony\n is a PHP web framework composed of a set of decoupled and reusable components all working together in harmony to create websites and web applications.\n\n\nThis guide covers how to deploy a Symfony app to Railway in three ways:\n\n\n\n\nOne-click deploy from a template\n.\n\n\nFrom a GitHub repository\n.\n\n\nUsing the CLI\n.\n\n\n\n\nNow, let's create a Symfony app!\n\n\nCreate a Symfony App\n\n\nNote:\n If you already have a Symfony app locally or on GitHub, you can skip this step and go straight to the \nDeploy Symfony App to Railway\n.\n\n\nTo create a new Symfony app, ensure that you have \nComposer\n, \nPHP\n and \nSymfony\n installed on your machine.\n\n\nRun the following command in your terminal to create a new Symfony app:\n\n\nsymfony new --webapp apphelloworld\n\n\nA new Symfony app will be provisioned for you in the \napphelloworld\n directory.\n\n\nRun the Symfony App locally\n\n\nTo start your app, run:\n\n\nsymfony server:start\n\n\nOnce the app is running, open your browser and navigate to \nhttp://localhost:8000\n to view it in action.\n\n\nDeploy the Symfony App to Railway\n\n\nRailway offers multiple ways to deploy your Symfony app, depending on your setup and preference.\n\n\nOne-Click Deploy from a Template\n\n\n\n\nThis template sets up a starter Symfony application along with a Postgres database on Railway. You can also choose from a \nvariety of Symfony app templates\n created by the community.\n\n\nWe highly recommend that \nyou eject from the template after deployment\n to create a copy of the repo on your GitHub account.\n\n\nDeploy from the CLI\n\n\nIf you have your Symfony app locally, you can follow these steps:\n\n\n\n\nInstall the Railway CLI\n:\n\n\n\n\nInstall the CLI\n and \nauthenticate it\n using your Railway account.\n\n\n\n\n\n\nInitialize a Railway Project\n:\n\n\n\n\nRun the command below in your Symfony app directory.\n\n\nrailway init\n\n\n\n\nFollow the prompts to name your project.\n\n\nAfter the project is created, click the provided link to view it in your browser.\n\n\n\n\n\n\nAdd a Postgres Database Service\n:\n\n\n\n\nRun \nrailway add -d postgres\n.\n\n\nHit \nEnter\n to add it to your project.\n\n\nA database service will be added to your Railway project.\n\n\n\n\n\n\nAdd a Service and Environment Variable\n:\n\n\n\n\nRun \nrailway add\n.\n\n\nSelect \nEmpty Service\n from the list of options.\n\n\nIn the \nEnter a service name\n prompt, enter \napp-service\n.\n\n\nIn the \nEnter a variable\n prompt, enter \nDATABASE_URL=${{Postgres.DATABASE_URL}}\n.\n\n\n\n\nThe value, \n${{Postgres.DATABASE_URL}}\n, references the URL of your new Postgres database. Learn more about \nreferencing service variables\n.\n\n\n\n\n\n\nSet the other environment variables:\n\n\n\n\nAPP_ENV=prod\n - This setting informs Symfony that the app is running in a production environment, optimizing it for performance.\n\n\nAPP_SECRET=secret\n where \nsecret\n is your generated app secret.\n\n\nCOMPOSER_ALLOW_SUPERUSER=\"1\"\n - This is necessary to allow Composer to run as root, enabling the plugins that Symfony requires during installation.\n\n\nNIXPACKS_PHP_ROOT_DIR=\"/app/public\"\n - This ensures the Nginx configuration points to the correct \nroot directory path to serve the app\n.\n\nNote:\n Explore the \nRailway CLI reference\n for a variety of options.\n\n\n\n\n\n\n\n\n\n\nDeploy the Application\n:\n\n\n\n\nRun \nrailway up\n to deploy your app.\n\n\n\n\nThis command will scan, compress and upload your app's files to Railway. Youâ€™ll see real-time deployment logs in your terminal.\n\n\n\n\n\n\nOnce the deployment is complete, we can proceed to generate a domain for the app service.\n\n\n\n\n\n\nSet Up a Public URL\n:\n\n\n\n\nRun \nrailway domain\n to generate a public URL for your app.\n\n\nVisit the new URL to see your app live in action!\n\n\n\n\n\n\n\n\n\n\nDeploy from a GitHub Repo\n\n\nTo deploy a Symfony app to Railway directly from GitHub, follow the steps below:\n\n\n\n\n\n\nCreate a New Project on Railway\n:\n\n\n\n\nGo to \nRailway\n to create a new project.\n\n\n\n\n\n\n\n\nDeploy from GitHub\n:\n\n\n\n\nSelect \nDeploy from GitHub repo\n and choose your repository.\n\n\n\n\nIf your Railway account isnâ€™t linked to GitHub yet, youâ€™ll be prompted to do so.\n\n\n\n\n\n\n\n\n\n\n\n\nAdd Environment Variables and Provision a Database Service\n:\n\n\n\n\nClick \nAdd Variables\n, but hold off on adding anything just yet. First, proceed with the next step.\n\n\nRight-click on the Railway project canvas or click the \nCreate\n button, then select \nDatabase\n and choose \nAdd PostgreSQL\n.\n\n\n\n\nThis will create and deploy a new PostgreSQL database for your project.\n\n\n\n\n\n\nOnce the database is deployed, you can return to adding the necessary environment variables:\n\n\n\n\nDATABASE_URL\n: Set the value to \n${{Postgres.DATABASE_URL}}\n (this references the URL of your new Postgres database). Learn more about \nreferencing service variables\n.\n\n\nAPP_ENV=prod\n - This setting informs Symfony that the app is running in a production environment, optimizing it for performance.\n\n\nAPP_SECRET=secret\n where \nsecret\n is your generated app secret.\n\n\nCOMPOSER_ALLOW_SUPERUSER=\"1\"\n - This is necessary to allow Composer to run as root, enabling the plugins that Symfony requires during installation.\n\n\nNIXPACKS_PHP_ROOT_DIR=\"/app/public\"\n - This ensures the Nginx configuration points to the correct \nroot directory path to serve the app\n.\n\n\n\n\n\n\n\n\n\n\n\n\nDeploy the App Service\n:\n\n\n\n\nClick \nDeploy\n on the Railway project canvas to apply your changes.\n\n\n\n\n\n\n\n\nVerify the Deployment\n:\n\n\n\n\nOnce the deployment completes, go to \nView logs\n to check if the server is running successfully.\n\n\n\n\nNote:\n During the deployment process, Railway will automatically \ndetect that itâ€™s a PHP app via Nixpacks\n.\n\n\n\n\n\n\nSet Up a Public URL\n:\n\n\n\n\nNavigate to the \nNetworking\n section under the \nSettings\n tab of your new service.\n\n\nClick \nGenerate Domain\n to create a public URL for your app.\n\n\n\n\n\n\n\n\nNote:\n The next step shows how to run your Symfony app along with a database, migrations, cron jobs, and workers.\n\n\nSet Up Database, Migrations, Crons and Workers\n\n\nThis setup deploys your Symfony app on Railway, ensuring that your database, scheduled tasks (crons), and queue workers are all fully operational.\n\n\nThe deployment structure follows a \"majestic monolith\" architecture, where the entire Symfony app is managed as a single codebase but split into four separate services on Railway:\n\n\n\n\nApp Service\n: Handles HTTP requests and user interactions.\n\n\nCron Service\n: Manages scheduled tasks (e.g., sending emails or running reports).\n\n\nWorker Service\n: Processes background jobs from the queue.\n\n\nDatabase Service\n: Stores and retrieves your application's data.\n\n\n\n\n\n\nMy Majestic Monolith Symfony app\n\n\nPlease follow these steps to get started:\n\n\n\n\n\n\nCreate three bash scripts in the root directory of your Symfony app: \nrun-app.sh\n, \nrun-worker.sh\n, and \nrun-cron.sh\n.\n\n\nThese scripts will contain the commands needed to deploy and run the app, worker, and cron services for your Symfony app on Railway.\n\n\n\n\n\n\nAdd the content below to the \nrun-app.sh\n file:\n\n\nNote:\n This is required to start your app service after the build phase is complete. This script will execute the migrations and then start the Nginx server.\n\n\n#!/bin/bash\n\n\n# Make sure this file has executable permissions, run `chmod +x run-app.sh`\n\n\n# Run migrations, process the Nginx configuration template and start Nginx\n\n\nphp bin/console doctrine:migrations:migrate --no-interaction \n&&\n \nnode\n /assets/scripts/prestart.mjs /assets/nginx.template.conf /nginx.conf \n&&\n \n(\nphp-fpm -y /assets/php-fpm.conf \n&\n nginx -c /nginx.conf\n)\n\n\n\n\n\n\nAdd the content below to the \nrun-worker.sh\n file. This script will run the queue worker:\n\n\n#!/bin/bash\n\n\n# Make sure this file has executable permissions, run `chmod +x run-worker.sh`\n\n\n\n\n# This command runs the queue worker. \n\n\nphp bin/console messenger:consume async --time-limit\n=\n3600\n --memory-limit\n=\n128M \n&\n\n\n\n\n\n\nSymfony doesn't natively include a scheduler. So, please install the \nCronBundle\n to define and run scheduled tasks. With that set up, add the content below to the \nrun-cron.sh\n file:\n\n\n#!/bin/bash\n\n\n# Make sure this file has executable permissions, run `chmod +x run-cron.sh`\n\n\n\n\n# This block of code runs the scheduler every minute\n\n\nwhile\n \n[\n \ntrue\n \n]\n\n\n    \ndo\n\n\n        \necho\n \n\"Running the scheduler...\"\n\n\n        php bin/console cron:start \n[\n--blocking\n]\n --no-interaction \n&\n\n\n        \nsleep\n \n60\n\n\n    \ndone\n\n\n\n\n\n\n\n\n\n\nCreate a Postgres Database service on the \nProject Canvas.\n\n\n\n\nClick on \nDeploy\n.\n\n\n\n\n\n\n\n\nCreate a new service on the \nProject Canvas.\n\n\n\n\nName the service \nApp Service\n, and click on \nSettings\n to configure it.\n\n\nConnect your GitHub repo to the  \nSource Repo\n in the \nSource\n section.\n\n\nAdd \nchmod +x ./run-app.sh && sh ./run-app.sh\n to the \nCustom Start Command\n in the \nDeploy\n section.\n\n\nHead back to the top of the service and click on \nVariables\n.\n\n\nAdd all the necessary environment variables required for the Symfony app especially the ones listed below.\n\n\n\n\nAPP_ENV=prod\n\n\nAPP_SECRET=secret\n where \nsecret\n is your generated app secret.\n\n\nCOMPOSER_ALLOW_SUPERUSER=\"1\"\n - This is necessary to allow Composer to run as root, enabling the plugins that Symfony requires during installation.\n\n\nNIXPACKS_PHP_ROOT_DIR=\"/app/public\"\n - This ensures the Nginx configuration points to the correct \nroot directory path to serve the app\n.\n\n\nDATABASE_URL=${{Postgres.DATABASE_URL}}\n (this references the URL of your Postgres database).\n\n\n\n\n\n\nClick \nDeploy\n.\n\n\n\n\n\n\n\n\nCreate a new service on the \nProject Canvas\n.\n\n\n\n\nName the service \nCron Service\n, and click on \nSettings\n.\n\n\nConnect your GitHub repo to the  \nSource Repo\n in the \nSource\n section.\n\n\nAdd \nchmod +x ./run-cron.sh && sh ./run-cron.sh\n to the \nCustom Start Command\n in the \nDeploy\n section.\n\n\nHead back to the top of the service and click on  \nVariables\n.\n\n\nAdd all the necessary environment variables especially those highlighted already in step 3.\n\n\nClick \nDeploy\n.\n\n\n\n\n\n\n\n\nCreate a new service again on the \nProject Canvas\n.\n\n\n\n\nName the service \nWorker Service\n, and click on \nSettings\n.\n\n\nConnect your GitHub repo to the  \nSource Repo\n in the \nSource\n section.\n\n\nAdd \nchmod +x ./run-worker.sh && sh ./run-worker.sh\n to the \nCustom Start Command\n in the \nDeploy\n section.\n\n\nHead back to the top of the service and click on \nVariables\n.\n\n\nAdd all the necessary environment variables especially those highlighted already in step 3.\n\n\nClick \nDeploy\n.\n\n\n\n\n\n\n\n\nAt this point, you should have all three services deployed and connected to the Postgres Database service:\n\n\n\n\n\n\nCron Service\n: This service should run the cron bundler Scheduler to manage scheduled tasks.\n\n\n\n\n\n\n\n\nWorker Service\n: This service should be running and ready to process jobs from the queue.\n\n\n\n\n\n\n\n\nApp Service\n: This service should be running and is the only one that should have a public domain, allowing users to access your application.\n\n\n\n\n\n\nApp service\n\n\nNote:\n There is a \ncommunity template\n available that demonstrates this deployment approach. You can easily deploy this template and then connect it to your own GitHub repository for your application.\n\n\nNext Steps\n\n\nExplore these resources to learn how you can maximize your experience with Railway:\n\n\n\n\nMonitoring\n\n\nDeployments\n\n\nPrev\n \nLaravel\nNext\n \nLuminus\nEdit this file on GitHub\nOn This Page\nCreate a Symfony App\nRun the Symfony App locally\nDeploy the Symfony App to Railway\nOne-Click Deploy from a Template\nDeploy from the CLI\nDeploy from a GitHub Repo\nSet Up Database, Migrations, Crons and Workers\nNext Steps"
  },
  {
    "url": "https://docs.railway.app/guides/templates",
    "title": "Templates | Railway Docs",
    "content": "Templates\nLet's talk templates!\n\n\nTemplates provide a way to jumpstart a project by giving users the means to package a service or set of services into a reusable and distributable format.\n\n\nHighlights\n\n\nBootstrap Projects\nTemplates are the best way to bootstrap a project by enabling you to provision a service or set of services in a matter of clicks.  Choose a template to deploy from the marketplace, or create your own from your personal scaffold.\nCommunity Clout\nWhen you publish a template, it is placed into our template marketplace for all users of the Railway community to take advantage.\nKickback Program\nUsage incurred by deployed templates from the marketplace are automatically eligible for a 50% kickback of the usage. In short, get paid for building templates!\n\n\nExcited about templates?  Dig into the next pages to learn how to create, publish, and deploy them.\nPrev\n \nWebhooks\nNext\n \nCreate\nEdit this file on GitHub\nOn This Page\nHighlights"
  },
  {
    "url": "https://docs.railway.app/guides/templates-best-practices",
    "title": "Template Best Practices | Railway Docs",
    "content": "Template Best Practices\nCreating templates can get complex, but these best practices will help you create templates that are easy to use and maintain.\n\n\nChecklist\n\n\nDepending on the type of template, there are different things to consider:\n\n\n\n\nTemplate and Service Icons\n\n\nNaming Conventions\n\n\nEnvironment Variables\n\n\nHealth Checks\n\n\nOverview\n\n\n\n\nTemplate and Service Icons\n\n\nTemplate and service icons are important for branding and recognition, they give the template a more professional look and feel.\n\n\nAlways use 1:1 Aspect Ratio icons with transparent backgrounds, for both the template itself and the services it includes.\n\n\nNaming Conventions\n\n\nNaming conventions are important for readability and consistency; using proper names enhances the overall quality and credibility of your template.\n\n\nAlways follow the naming conventions for the software that the template is made for.\n\n\nExample, if the template is for ClickHouse, the service and template name should be named \nClickHouse\n with a capital C and H, since that is how the brand name is spelled.\n\n\nFor anything else, such as custom software, use capital case and avoid using special characters or dashes, space-delimited is the way to go.\n\n\nEnvironment Variables\n\n\nProperly set up environment variables are a great way to increase the usability of your template.\n\n\nWhen using environment variables:\n\n\n\n\n\n\nAlways include a description of what the variable is for.\n\n\n\n\n\n\nFor any secrets, passwords, keys, etc., use \ntemplate variable functions\n to generate them.\n\n\n\n\n\n\nUse \nreference variables\n when possible.\n\n\n\n\n\n\nInclude helpful pre-built variables that the user may need, such as database connection strings, API keys, ports, etc.\n\n\n\n\n\n\nHealth Checks\n\n\nHealth checks are important for ensuring that the service is running properly, before traffic is routed to it.\n\n\nAlthough a health check might not be needed for all software, such as Discord bots, when it is applicable, it is a good idea to include a health check.\n\n\nA readiness probe is the best option; if that's not possible, then a liveness probe should be used.\n\n\nOverview\n\n\nThe overview is the first thing users will see when they click on the template, so it is important to make it count.\n\n\nThe overview should include the following:\n\n\n\n\n\n\nH1: Deploy and Host [X] with Railway\n\n\nWhat is X? Your description in roughly ~ 50 words.\n\n\n\n\n\n\nH2: About Hosting [X]\n\n\nRoughly 100 word description what's involved in hosting/deploying X\n\n\n\n\n\n\nH2: Common Use Cases\n\n\nIn 3-5 bullets, what are the most common use cases for [X]?\n\n\n\n\n\n\nH2: Dependencies for [X] Hosting\n\n\nIn bullet form, what other technologies are incorporated in using this template besides [X]?\n\n\n\n\n\n\nH3: Deployment Dependencies\n\n\nInclude any external links relevant to the template.\n\n\n\n\n\n\nH3: Implementation Details (Optional)\n\n\nInclude any code snippets or implementation details. This section is optional. Exclude if nothing to add.\n\n\n\n\n\n\nH3: Why Deploy [X] on Railway?\n\n\nRailway is a singular platform to deploy your infrastructure stack. Railway will host your infrastructure so you don't have to deal with configuration, while allowing you to vertically and horizontally scale it.\n\n\nBy deploying [X] on Railway, you are one step closer to supporting a complete full-stack application with minimal burden. Host your servers, databases, AI agents, and more on Railway.\n\n\n\n\nPrev\n \nCreate\nNext\n \nPublish and Share\nEdit this file on GitHub\nOn This Page\nChecklist\nTemplate and Service Icons\nNaming Conventions\nEnvironment Variables\nHealth Checks\nOverview"
  },
  {
    "url": "https://docs.railway.app/guides/variables",
    "title": "Using Variables | Railway Docs",
    "content": "Using Variables\nVariables provide a way to manage configuration and secrets across services in Railway.\n\n\nWhen defined, they are made available to your application as environment variables in the following scenarios:\n\n\n\n\nThe build process for each service deployment.\n\n\nThe running service deployment.\n\n\nThe command invoked by \nrailway run <COMMAND>\n\n\nThe local shell via \nrailway shell\n\n\n\n\nIn Railway, there is also a notion of configuration variables which allow you to control the behavior of the platform.\n\n\nAdding, updating, or removing variables, results in a set of \nstaged changes\n that you must review and deploy, in order to apply them.\n\n\nService Variables\n\n\nVariables scoped to individual services can be defined by navigating to a service's \"Variables\" tab.\n\n\n\n\nDefine a Service Variable\n\n\nFrom a service's variables tab, click on \nNew Variable\n to enter your variable into a form field, or use the \nRAW Editor\n to paste the contents of your \n.env\n or json-formatted file.\n\n\nShared Variables\n\n\nShared variables help reduce duplication of variables across multiple services within the same project.\n\n\n\n\nDefine a Shared Variable\n\n\nFrom your Project Settings -> Shared Variables page, choose the Environment, enter the variable name and value, and click \nAdd\n.\n\n\nUse a Shared Variable\n\n\nTo use a shared variable, either click the Share button from the Project Settings -> Shared Variables menu and select the services with which to share, or visit the Variables tab within the service itself and click \"Shared Variable\".\n\n\nAdding a shared variables to a service creates a \nReference Variable\n in the service.\n\n\nReference Variables\n\n\nReference variables are those defined by referencing variables in other services, shared variables, or even variables in the same service.\n\n\nWhen using reference variables, you also have access to \nRailway-provided variables\n.\n\n\nRailway's \ntemplate syntax\n is used when defining reference variables.\n\n\nReferencing a Shared Variable\n\n\nUse the following syntax to reference a shared variable:\n\n\n\n\n${{ shared.VARIABLE_KEY }}\n\n\n\n\nExample\n\n\nYou have a shared variable defined in your project called \nAPI_KEY\n, and you need to make the API key available to a service.  Go to the service's variables tab, and add a variable with the following value:\n\n\n\n\nAPI_KEY=${{shared.API_KEY}}\n\n\n\n\n\n\n\n\nReferencing Another Service's Variable\n\n\nUse the following syntax to reference variables in another service:\n\n\n\n\n${{SERVICE_NAME.VAR}}\n\n\n\n\nExample\n\n\n\n\nYou have a variable set on your database service called \nDATABASE_URL\n which contains the connection string to connect to the database.  The database service name is \nClickhouse\n.\n\n\n\n\n\n\nYou need to make this connection string available to another service in the project. Go to the service's variables that needs the connection string and add a variable with the following value:\n\n\n\n\nDATABASE_URL=${{ Clickhouse.DATABASE_URL }}\n\n\n\n\n\n\n\n\nYour frontend service needs to make requests to your backend. You do not want to hardcode the backend URL in your frontend code. Go to your frontend service settings and add the \nRailway-provided variable\n for the backend URL\n\n\n\n\nAPI_URL=https://${{ backend.RAILWAY_PUBLIC_DOMAIN }}\n\n\n\n\n\n\n\n\nReferencing Variables in the Same Service\n\n\nUse the following syntax to reference variables in the same service:\n\n\n\n\n${{ VARIABLE_NAME }}\n\n\n\n\nExample\n\n\nYou have the variables needed to construct an API endpoint already defined in your service - \nBASE_URL\n and \nAUTH_PATH\n - and you would like to combine them to create a single variable.  Go to your service variables and add a new variable referencing other variables in the same service -\n\n\n\n\nAUTH_ENDPOINT=https://${{ BASE_URL }}/${{ AUTH_PATH }}\n\n\n\n\n\n\n\n\nAutocomplete Dropdown\n\n\nThe Railway dashboard provides an autocomplete dropdown in both the name and value fields to help create reference variables.\n\n\n\n\nSealed Variables\n\n\nThis feature is in beta. For questions or feedback, please use the \nfeedback thread\n.\n\n\nRailway provides the ability to seal variable values for extra security. When a variable is sealed, its value is provided to builds and deployments but is never visible in the UI nor can it be retrieved via the API.\n\n\nSealing a Variable\n\n\nTo seal an existing variable, click the 3-dot menu on the right-side of the variable and choose the \"Seal\" option.\n\n\n\n\nUpdating a Sealed Variable\n\n\nSealed variables can be updated by clicking the edit option in the 3-dot menu just like normal variables but they cannot be updated via the Raw Editor.\n\n\nCaveats\n\n\nSealed variables are a security-first feature and with that come some constraints:\n\n\n\n\nSealed variables cannot be un-sealed.\n\n\nSealed variable values are not provided when using \nrailway variables\n or \nrailway run\n via the CLI.\n\n\nSealed variables are not copied over when creating PR environments.\n\n\nSealed variables are not copied when duplicating an environment.\n\n\nSealed variables are not copied when duplicating a service.\n\n\nSealed variables are not shown as part of the diff when syncing environment changes.\n\n\nSealed variables are not synced with external integrations.\n\n\n\n\nRailway-provided Variables\n\n\nRailway provides many variables to help with development operations. Some of the commonly used variables include -\n\n\n\n\nRAILWAY_PUBLIC_DOMAIN\n\n\nRAILWAY_PRIVATE_DOMAIN\n\n\nRAILWAY_TCP_PROXY_PORT\n\n\n\n\nFor an exhaustive list, please check out the \nVariables Reference\n page.\n\n\nMultiline Variables\n\n\nVariables can span multiple lines. Press \nControl + Enter\n (\nCmd + Enter\n on Mac) in the variable value input field to add a newline, or simply type a newline in the Raw Editor.\n\n\nUsing Variables in Your Services\n\n\nVariables are made available at runtime as environment variables. To use them in your application, simply use the interface appropriate for your language to retrieve environment variables.\n\n\nFor example, in a node app -\n\n\nprocess.env.VARIABLE_NAME;\n\n\nLocal Development\n\n\nUsing the Railway CLI, you can run your code locally with the environment variables configured in your Railway project.\n\n\n\n\nEnsure that you have the Railway CLI installed and linked to your project\n\n\nIn your terminal, execute \nrailway run <run command>\n\n-> for example, \nrailway run npm run dev\n\n\n\n\nCheck out the \nCLI guide\n for more information on using the CLI.\n\n\nImport Variables from Heroku\n\n\nYou can import variables from an existing Heroku app using the command palette\non the service variables page. After connecting your Heroku account you can\nselect any of your Heroku apps and the config variables will be added to the current service and environment.\n\n\n\n\nUsing Doppler for Secrets Management\n\n\nOur friends at Doppler maintain an integration that makes it easy to sync your secrets in Doppler to your project(s) in Railway.\n\n\nYou can get instructions on how to use Doppler with Railway on the \nDoppler Docs\nintegration\n.\nPrev\n \nServices\nNext\n \nVolumes\nEdit this file on GitHub\nOn This Page\nService Variables\nDefine a Service Variable\nShared Variables\nDefine a Shared Variable\nUse a Shared Variable\nReference Variables\nReferencing a Shared Variable\nReferencing Another Service's Variable\nReferencing Variables in the Same Service\nAutocomplete Dropdown\nSealed Variables\nSealing a Variable\nUpdating a Sealed Variable\nCaveats\nRailway-provided Variables\nMultiline Variables\nUsing Variables in Your Services\nLocal Development\nImport Variables from Heroku\nUsing Doppler for Secrets Management"
  },
  {
    "url": "https://docs.railway.app/guides/volumes",
    "title": "Using Volumes | Railway Docs",
    "content": "Using Volumes\nVolumes allow you to store persistent data for services on Railway.\n\n\n\n\nCreating A Volume\n\n\nYou can create a new volume through the Command Palette (\nâŒ˜K\n)\nor by right-clicking the project canvas to bring up a menu:\n\n\nvia command palette\nvia right-click menu\n\n\nWhen creating a volume, you will be prompted to select a service to connect the volume to:\n\n\n\n\nYou must configure the mount path of the volume in your service:\n\n\n\n\nUsing the Volume\n\n\nThe volume mount point you specify will be available in your service as a directory to which you can read/write.  If you mount a volume to \n/foobar\n, your application will be able to access it at the absolute path \n/foobar\n.\n\n\nRelative Paths\n\n\nNixpacks, the default buildpack used by Railway, puts your application files in an \n/app\n folder at the root of the container.  If your application writes to a directory at a relative path, and you need to persist that data on the volume, your mount path should include the app path.\n\n\nFor example, if your application writes data to \n./data\n, you should mount the volume to \n/app/data\n.\n\n\nProvided Variables\n\n\nAttaching a Volume to a service will automatically make these environment variables available\nto the service at runtime:\n\n\n\n\nRAILWAY_VOLUME_NAME\n: Name of the volume (e.g. \nfoobar\n)\n\n\nRAILWAY_VOLUME_MOUNT_PATH\n: Mount path of the volume (e.g. \n/foobar\n)\n\n\n\n\nYou do not need to define these variables on the service, they are automatically set by Railway at runtime.\n\n\nVolume Availability\n\n\nVolumes are mounted to your service's container when it is started, not during build time.\n\n\nIf you write data to a directory at build time, it will not persist on the volume, even if it writes to the directory to which you have mounted the volume.\n\n\nNote:\n Volumes are not mounted during pre-deploy time, if your pre-deploy command attempts to read or write data to a volume, it should be done as part of the start command.\n\n\nVolumes are not mounted as overlays.\n\n\nPermissions\n\n\nVolumes are mounted as the \nroot\n user.  If you run an image that uses a non-root user, you should set the following variable on your service:\n\n\nRAILWAY_RUN_UID\n=\n0\n\n\nGrowing the Volume\n\n\nOnly available to Pro users and above.\n\n\nTo increase capacity in a volume, you can \"grow\" it from the volume settings.\n\n\n\n\nClick on the volume to open the settings\n\n\nClick \nGrow\n\n\nFollow the prompts to grow the volume\n\n\n\n\n\n\nNote: growing a volume requires a restart of the attached service.\n\n\nBackups\n\n\nServices with volumes support manual and automated backups, backups are covered in the \nbackups\n reference guide.\nPrev\n \nVariables\nNext\n \nEnvironments\nEdit this file on GitHub\nOn This Page\nCreating A Volume\nUsing the Volume\nRelative Paths\nProvided Variables\nVolume Availability\nPermissions\nGrowing the Volume\nBackups"
  },
  {
    "url": "https://docs.railway.app/guides/vue",
    "title": "Deploy a Vue App | Railway Docs",
    "content": "Deploy a Vue App\nVue\n, also known as Vue.js or VueJS, is a popular JavaScript library for building snappy, performant and versatile user interfaces for web applications.\n\n\nVue prides itself as \nThe Progressive JavaScript Framework\n.\n\n\nThis guide covers how to deploy a Vue app to Railway in four ways:\n\n\n\n\nOne-click deploy from a template\n.\n\n\nFrom a GitHub repository\n.\n\n\nUsing the CLI\n.\n\n\nUsing a Dockerfile\n.\n\n\n\n\nNow, let's create a Vue app!\n\n\nCreate a Vue App\n\n\nNote:\n If you already have a Vue app locally or on GitHub, you can skip this step and go straight to the \nDeploy Vue App on Railway\n.\n\n\nTo create a new Vue app, ensure that you have \nNode\n installed on your machine.\n\n\nRun the following command in your terminal to create a new Vue app using \nVite\n:\n\n\nnpm\n create vue@latest\n\n\nYou'll be presented with choices for different options in the prompts. Give the app a name, \nhelloworld\n and answer \nYes\n to the other options or select what you want.\n\n\nA new Vue app will be provisioned for you in the \nhelloworld\n directory.\n\n\nRun the Vue App locally\n\n\nNext, \ncd\n into the directory and install the dependencies.\n\n\nnpm\n \ninstall\n\n\nStart the Vite development server by running the following command:\n\n\nnpm\n run dev\n\n\nOpen your browser and go to \nhttp://localhost:5173\n to see your app.\n\n\nDeploy the Vue App to Railway\n\n\nRailway offers multiple ways to deploy your Vue app, depending on your setup and preference.\n\n\nOne-Click Deploy from a Template\n\n\nIf youâ€™re looking for the fastest way to get started, the one-click deploy option is ideal. It sets up a Vue app with \nCaddy\n to serve the dist folder.\n\n\nClick the button below to begin:\n\n\n\n\nWe highly recommend that \nyou eject from the template after deployment\n to create a copy of the repo on your GitHub account.\n\n\nNote:\n You can also choose from a \nvariety of Vue app templates\n created by the community.\n\n\nDeploy from the CLI\n\n\n\n\nInstall the Railway CLI\n:\n\n\n\n\nInstall the CLI\n and \nauthenticate it\n using your Railway account.\n\n\n\n\n\n\nInitialize a Railway Project\n:\n\n\n\n\nRun the command below in your Vue app directory.\n\n\nrailway init\n\n\n\n\nFollow the prompts to name your project.\n\n\nAfter the project is created, click the provided link to view it in your browser.\n\n\n\n\n\n\nDeploy the Application\n:\n\n\n\n\nUse the command below to deploy your app:\n\n\nrailway up\n\n\n\n\nThis command will scan, compress and upload your app's files to Railway. Youâ€™ll see real-time deployment logs in your terminal.\n\n\nOnce the deployment completes, go to \nView logs\n to check if the service is running successfully.\n\n\n\n\n\n\nSet Up a Public URL\n:\n\n\n\n\nNavigate to the \nNetworking\n section under the \nSettings\n tab of your new service.\n\n\nClick \nGenerate Domain\n to create a public URL for your app.\n\n\n\n\n\n\n\n\n\n\nDeploy from a GitHub Repo\n\n\nTo deploy a Vue app to Railway directly from GitHub, follow the steps below:\n\n\n\n\nCreate a New Project on Railway\n:\n\n\n\n\nGo to \nRailway\n to create a new project.\n\n\n\n\n\n\nDeploy from GitHub\n:\n\n\n\n\nSelect \nDeploy from GitHub repo\n and choose your repository.\n\n\n\n\nIf your Railway account isnâ€™t linked to GitHub yet, youâ€™ll be prompted to do so.\n\n\n\n\n\n\n\n\n\n\nDeploy the App\n:\n\n\n\n\nClick \nDeploy\n to start the deployment process.\n\n\nOnce the deployed, a Railway \nservice\n will be created for your app, but it wonâ€™t be publicly accessible by default.\n\n\n\n\n\n\nVerify the Deployment\n:\n\n\n\n\nOnce the deployment completes, go to \nView logs\n to check if the server is running successfully.\n\n\n\n\n\n\nSet Up a Public URL\n:\n\n\n\n\nNavigate to the \nNetworking\n section under the \nSettings\n tab of your new service.\n\n\nClick \nGenerate Domain\n to create a public URL for your app.\n\n\n\n\n\n\n\n\nUse a Dockerfile\n\n\n\n\nCreate a \nDockerfile\n in the \nhelloworld\n or Vue app's root directory.\n\n\nAdd the content below to the \nDockerfile\n:\n\n\n# Use the Node alpine official image\n\n\n# https://hub.docker.com/_/node\n\n\nFROM node:lts-alpine AS build\n\n\n\n# Set config\n\n\nENV \nNPM_CONFIG_UPDATE_NOTIFIER\n=\nfalse\n\nENV \nNPM_CONFIG_FUND\n=\nfalse\n\n\n\n# Create and change to the app directory.\n\n\nWORKDIR /app\n\n\n\n# Copy the files to the container image\n\n\nCOPY package*.json ./\n\n\n\n# Install packages\n\n\nRUN \nnpm\n ci\n\n\n\n# Copy local code to the container image.\n\n\nCOPY \n.\n ./\n\n\n\n# Build the app.\n\n\nRUN \nnpm\n run build\n\n\n\n# Use the Caddy image\n\n\nFROM caddy\n\n\n\n# Create and change to the app directory.\n\n\nWORKDIR /app\n\n\n\n# Copy Caddyfile to the container image.\n\n\nCOPY Caddyfile ./\n\n\n\n# Copy local code to the container image.\n\n\nRUN caddy \nfmt\n Caddyfile --overwrite\n\n\n\n# Copy files to the container image.\n\n\nCOPY --from\n=\nbuild /app/dist ./dist\n\n\n\n# Use Caddy to run/serve the app\n\n\nCMD \n[\n\"caddy\"\n, \n\"run\"\n, \n\"--config\"\n, \n\"Caddyfile\"\n, \n\"--adapter\"\n, \n\"caddyfile\"\n]\n\n\nThe \nDockerfile\n will use Caddy to serve the Vue app.\n\n\nAdd a \nCaddyfile\n to the app's root directory:\n\n\n# global options\n\n\n{\n\n\n    admin off \n# theres no need for the admin api in railway's environment\n\n\n    persist_config off \n# storage isn't persistent anyway\n\n\n    auto_https off \n# railway handles https for us, this would cause issues if left enabled\n\n\n    \n# runtime logs\n\n\n    log \n{\n\n\n        \nformat\n json \n# set runtime log format to json mode \n\n\n    \n}\n\n\n    \n# server options\n\n\n    servers \n{\n\n\n        trusted_proxies static private_ranges \n100.0\n.0.0/8 \n# trust railway's proxy\n\n\n    \n}\n\n\n}\n\n\n\n\n# site block, listens on the $PORT environment variable, automatically assigned by railway\n\n\n:\n{\n$PORT\n:3000\n}\n \n{\n\n\n    \n# access logs\n\n\n    log \n{\n\n\n        \nformat\n json \n# set access log format to json mode\n\n\n    \n}\n\n\n\n\n    \n# health check for railway\n\n\n    rewrite /health /*\n\n\n\n    \n# serve from the 'dist' folder (Vite builds into the 'dist' folder)\n\n\n    root * dist\n\n\n\n    \n# enable gzipping responses\n\n\n    encode \ngzip\n\n\n\n\n    \n# serve files from 'dist'\n\n\n    file_server\n\n\n\n    \n# if path doesn't exist, redirect it to 'index.html' for client side routing\n\n\n    try_files \n{\npath\n}\n /index.html\n\n}\n\n\n\n\nEither deploy via the CLI or from GitHub.\n\n\n\n\nRailway automatically detects the \nDockerfile\n, \nand uses it to build and deploy the app.\n\n\nNote:\n Railway supports also \ndeployment from public and private Docker images\n.\n\n\nThis guide covers the main deployment options on Railway. Choose the approach that suits your setup, and start deploying your Vue apps seamlessly!\n\n\nNext Steps\n\n\nExplore these resources to learn how you can maximize your experience with Railway:\n\n\n\n\nAdd a Database Service\n\n\nMonitor your app\n\n\nPrev\n \nRemix\nNext\n \nNuxt\nEdit this file on GitHub\nOn This Page\nCreate a Vue App\nRun the Vue App locally\nDeploy the Vue App to Railway\nOne-Click Deploy from a Template\nDeploy from the CLI\nDeploy from a GitHub Repo\nUse a Dockerfile\nNext Steps"
  },
  {
    "url": "https://docs.railway.app/guides/webhooks",
    "title": "Webhooks | Railway Docs",
    "content": "Webhooks\nWebhooks can be used to notify your own application of deployment status changes.  They are configured per project.\n\n\nSetup a Webhook\n\n\n\n\nComplete the following steps to setup a webhook:\n\n\n\n\nOpen an existing Project on Railway.\n\n\nClick on the \nSettings\n button in the top right-hand corner.\n\n\nNavigate to the Webhooks tab.\n\n\nInput your desired webhook URL.\n\n\nOptional: specify which events to recieve notifications for.\n\n\nClick \nSave Webhook\n.\n\n\n\n\nThe URL you provide will receive a webhook payload when any service's deployment status changes or an alert is triggered. This will be executed across all environments in the project.\n\n\nExample Payload\n\n\n{\n\n\n  \n\"type\"\n:\n \n\"DEPLOY\"\n,\n\n\n  \n\"timestamp\"\n:\n \n\"2025-02-01T00:00:00.000Z\"\n,\n\n\n  \n\"project\"\n:\n \n{\n\n\n    \n\"id\"\n:\n \n\"[project ID]\"\n,\n\n\n    \n\"name\"\n:\n \n\"[project name]\"\n,\n\n\n    \n\"description\"\n:\n \n\"...\"\n,\n\n\n    \n\"createdAt\"\n:\n \n\"2025-02-01T00:00:00.000Z\"\n\n\n  \n}\n,\n\n\n  \n\"environment\"\n:\n \n{\n\n\n    \n\"id\"\n:\n \n\"[environment ID]\"\n,\n\n\n    \n\"name\"\n:\n \n\"[environment name]\"\n\n\n  \n}\n,\n\n\n  \n\"deployment\"\n:\n \n{\n\n\n    \n\"id\"\n:\n \n\"[deploy ID]\"\n,\n\n\n    \n\"creator\"\n:\n \n{\n\n\n      \n\"id\"\n:\n \n\"[user id]\"\n,\n\n\n      \n\"name\"\n:\n \n\"...\"\n,\n\n\n      \n\"avatar\"\n:\n \n\"...\"\n\n\n    \n}\n,\n\n\n    \n\"meta\"\n:\n \n{\n}\n\n\n  \n}\n\n\n}\n\n\nMuxers: Provider-specific Webhooks\n\n\nFor certain webhook URLs, Railway will automatically transform the payload to match the destination (we call the Muxers). This makes it easy to use webhooks without having to write your own middleware to format the request body. Below are the currently supported providers:\n\n\n\n\nDiscord\n\n\nSlack\n\n\n\n\nSetting Up a Webhook for Discord\n\n\nDiscord supports integrating directly with webhooks. To enable this on a server you will need to be an admin or otherwise have the appropriate permissions.\n\n\n\n\nOn Discord, open the settings for a server text channel. This menu can be accessed via the cogwheel/gear icon where the channel is listed on the server.\n\n\nClick on the integrations tab.\n\n\nClick on the webhooks option.\n\n\nYou will see an option to create a new webhook, click this button and fill out your preferred bot name and channel.\n\n\nOnce created, you will have the option to copy the new webhook URL. Copy that URL.\n\n\nBack in Railway, open the project you wish to integrate with.\n\n\nClick on the project's deployments menu.\n\n\nNavigate to the settings tab.\n\n\nInput the copied webhook URL into the input under \"Build and Deploy Webhooks\".\n\n\nClick the checkmark to the right of the input to save.\n\n\n\n\nAt this point, the Discord Muxer will identify the URL and change the payload to accommodate the Discord integration. You can see this if you expand the payload preview panel.\n\n\nYou are now done! When your project deploys again, that Discord channel will get updates on the deployment!\n\n\nSetting Up a Webhook for Slack\n\n\nSlack supports integrating directly with webhooks.\n\n\n\n\nEnable incoming webhooks for your Slack instance (Tutorial \nhere\n)\n\n\nGenerate a \nhooks.slack.com\n webhook URL for your channel (Tutorial \nhere\n)\n\n\nOpen up Railway, navigate to your project's Webhook tab.\n\n\nPaste the url from slack\n\n\n\n\nPrev\n \nMetrics\nNext\n \nTemplates\nEdit this file on GitHub\nOn This Page\nSetup a Webhook\nExample Payload\nMuxers: Provider-specific Webhooks\nSetting Up a Webhook for Discord\nSetting Up a Webhook for Slack"
  },
  {
    "url": "https://docs.railway.app/maturity/compare-to-digitalocean",
    "title": "Railway vs. DigitalOcean | Railway Docs",
    "content": "Railway vs. DigitalOcean\nRailway is a modern, developer-centric cloud platform that streamlines the deployment process while maintaining the power and flexibility of traditional cloud providers. We focus on making infrastructure management intuitive and efficient.\n\n\nSummary\n\n\nRailway offers a comprehensive platform that combines the best aspects of traditional cloud providers with modern developer workflows. While DigitalOcean provides robust infrastructure, Railway simplifies the deployment and management process significantly.\n\n\nRailway also offers\n\n\n\n\n\n\nZero configuration required\n - We automatically detect your language and deploy your application without complex setup.\n\n\n\n\n\n\nOSS templates\n - Access our extensive collection of templates for popular frameworks and software.\n\n\n\n\n\n\nZero maintenance\n - We handle infrastructure management, updates, and scaling automatically.\n\n\n\n\n\n\nPersistent storage\n - Built-in support for persistent disks and volumes.\n\n\n\n\n\n\nUniversal deployment support\n - Deploy any type of application, from static sites to complex microservices.\n\n\n\n\n\n\nContainer flexibility\n - Support for Dockerfiles and container images.\n\n\n\n\n\n\nRailway excels with\n\n\n\n\n\n\nResource-based pricing\n - Pay only for the resources you use, with no hidden fees or complex billing structures.\n\n\n\n\n\n\nCron jobs\n - Built-in scheduling system that runs as a native service.\n\n\n\n\n\n\nRich OSS ecosystem\n - Extensive collection of templates for popular open-source projects.\n\n\n\n\n\n\nDeveloper-centric experience\n - Intuitive interface with real-time collaboration features.\n\n\n\n\n\n\nGlobal distribution\n - Deploy your applications across multiple regions with automatic routing.\n\n\n\n\n\n\nBest in Class Support\n - Active community and dedicated support channels.\n\n\n\n\n\n\nPrivate networking\n - Secure, global network for service communication.\n\n\n\n\n\n\nKey Differences\n\n\nDeveloper Experience\n\n\nWhile DigitalOcean requires extensive DevOps knowledge and manual configuration, Railway offers an intuitive interface that makes deployment and management accessible to developers at any skill level.\n\n\nOur Project Canvas offers a visual representation of your connected infrastructure, making it easy to understand and manage service relationships. This modern approach stands in stark contrast to DigitalOcean's traditional dashboard.\n\n\nOur \nreal-time collaboration\n feature lets you see exactly who's working with you on the Project Canvas, making teamwork seamless and intuitive.\n\n\nBuild Process\n\n\nDigitalOcean requires manual configuration of build processes and deployment pipelines. Railway's \nRailpack\n automatically detects your application's requirements and handles the build process seamlessly.\n\n\nWith more coming soon, we support 5+ languages out of the box, with automatic dependency detection and build optimization. This eliminates the need for complex build configurations or custom Dockerfiles that are often required with DigitalOcean.\n\n\nRuntime Environment\n\n\nOn Railway your applications only use the resources they, your bill is based on actual resource usage, not machine size.\n\n\nIf they need more resources, they can scale up vertically, if they need less, they can scale down.\n\n\nIn contrast, DigitalOcean requires you to pay for fixed-size droplets or VMs, which often leads to overprovisioning and higher costs due to manual scaling requirements.\n\n\nPR Environments\n\n\nRailway's PR Environments allow you to deploy and test your code in a staging environment for each pull request.\n\n\nDatabase Deployment\n\n\nRailway offers native support for multiple database types (PostgreSQL, MySQL, Redis, MongoDB) with built-in UI. DigitalOcean requires separate setup and management of database services.\n\n\nOur database UI provides direct access to your data without needing external tools, while DigitalOcean users often solely rely on third-party software.\n\n\nNetworking\n\n\nRailway's private networking operates globally, allowing services in different regions to communicate securely. DigitalOcean's networking is more traditional and requires manual configuration for cross-region communication.\n\n\nWe handle SSL/TLS certificates automatically, while DigitalOcean users need to manage certificates separately.\n\n\nPricing\n\n\nRailway's pricing is based on actual resource usage. You can find \nspecific per-minute pricing here\n.\n\n\nDigitalOcean's pricing is based on fixed-size droplets or VMs and requires manual scaling, which will lead to overprovisioning and higher costs.\n\n\nSupport and Community\n\n\nRailway provides immediate support through our active Discord community and Central Station. DigitalOcean's support varies by plan, with basic support limited to community forums.\n\n\nReady to Switch?\n\n\nThinking about migrating from DigitalOcean to Railway? We've created a \nmigration guide\n to help you transition smoothly.\n\n\nSign up on Railway\n today and get $5 in free credits to explore the platform.\n\n\nFor companies and large organizations, we'd love to chat! \nBook a call with us\n to see how Railway will fit your needs.\nPrev\n \nCompare to Vercel\nNext\n \nMigrate from Render\nEdit this file on GitHub\nOn This Page\nSummary\nRailway also offers\nRailway excels with\nKey Differences\nDeveloper Experience\nBuild Process\nRuntime Environment\nPR Environments\nDatabase Deployment\nNetworking\nPricing\nSupport and Community\nReady to Switch?"
  },
  {
    "url": "https://docs.railway.app/maturity/compare-to-fly",
    "title": "Railway vs. Fly | Railway Docs",
    "content": "Railway vs. Fly\nRailway is a modern, developer-centric cloud platform designed to simplify app deployment, scaling, and managementâ€”all while optimizing for developer happiness and efficiency.\n\n\nWe provide a robust, feature-rich platform comparable to other cloud providers, with a focus on ease of use and developer productivity.\n\n\nRailway offers:\n\n\n\n\nBroad Language and Framework Support\n: Deploy apps in \nany language or framework\n.\n\n\nFlexible Deployment Options\n: Use GitHub, Dockerfiles, Docker images from any registry, or local deployments via the Railway CLI.\n\n\nIntegrated Tools\n: Simplify environment variable management, CI/CD, observability, and service scaling.\n\n\nNetworking Features:\n Public and private networking.\n\n\nBest in Class Support:\n Very active community and support on Slack, \nDiscord\n and our \nCentral Station\n.\n\n\n\n\nWe differ in the following:\n\n\n\n\nA vibrant, highly engaged community with fast, reliable support.\n\n\nA superior developer experience designed for simplicity and efficiency.\n\n\nTransparent, flexible pricing that scales with your needs.\n\n\nAnd much more...\n\n\n\n\nDifferences\n\n\nProduct and Deploy UX\n\n\nAt Railway, we believe DevOps should be effortless, intuitive, and even enjoyable. From the instant simplicity of \ndev.new\n to managing interconnected services with ease on your Project Canvas, our platform is designed to be both powerful and visually refined. Who says DevOps has to be ugly or boring? On our platform, itâ€™s fluid, engaging, and a pleasure to use.\n\n\nOne of our standout features is \nreal-time collaboration\n. See exactly which teammates are working alongside you on the Project Canvas, fostering seamless teamwork and collaboration.\n\n\nDeploy UI and GitHub Repo Deployments\n\n\nFly.io currently supports GitHub repository deployments for Node.js, Phoenix, Laravel, Django, Python, and Golang via their Launch UI, but these are still considered experimental. They strongly recommend using the CLI for more reliable and flexible deployments.\n\n\nAt Railway, you can deploy any language repository seamlessly through our fast and intuitive deploy UI. Additionally, you have the flexibility to use our CLI whenever it suits your workflow.\n\n\nWe make it incredibly simple to deploy exactly what you needâ€”whether it's a template, database, Docker image, or even an empty serviceâ€”all from the dashboard. With just a right-click on the Project Canvas or a tap on the Create button, you can instantly spin up new resources. Fly.io does not offer this level of convenience in its dashboard.\n\n\nNative Crons\n\n\nRailway provides \nnative cron jobs\n directly in the dashboardâ€”no setup, no extra packages, just seamless scheduling. Simply define a cron schedule in your service settings, and Railway will automatically execute the start command at the specified times.\n\n\nWith Railwayâ€™s built-in cron management, you can:\n\n\n\n\nEasily create and manage cron jobs from the dashboard\n\n\nView all past and running jobs in one place\n\n\nAvoid unnecessary installations and configurationsâ€”just set and go!\n\n\n\n\nFly.io does not offer native crons. To schedule tasks, youâ€™ll need to manually configure crontab using supercronic, adding extra setup and maintenance overhead.\n\n\nWith Railway, scheduled tasks are simple, streamlined, and built-in. No extra stepsâ€”just reliable automation.\n\n\nPR Environments\n\n\nRailway offers a \npowerful environments feature\n that makes managing complex development workflows seamlessâ€”all from the dashboard. With just a few clicks, you can enable multiple environments such as \nstaging, development, QA,\n \nand more\n, ensuring your project scales efficiently with your workflow.\n\n\nAdditionally, Railway provides \nPR environments\nâ€”ephemeral environments automatically created when a pull request is opened and cleaned up when itâ€™s closed. No need to manually configure or integrate with GitHub Actionsâ€”Railway handles everything for you, so you can focus on building and shipping faster.\n\n\nFly.io recommends setting up Git branch preview environments manually via GitHub Actions and workflows, requiring additional setup and maintenance.\n\n\nWebhooks\n\n\nRailway provides native support for \nwebhooks\n, allowing you to receive real-time notifications about key project events such as \ndeployments, build status changes, and more\n. Stay in sync with your workflow effortlessly and build anything on top of it!\n\n\nFly.io does not offer built-in webhook support, meaning users must rely on external integrations or manual setups to track application events.\n\n\nWith Railway, webhooks are built-in and ready to goâ€”no extra setup required.\n\n\nVariables and Secrets\n\n\nRailway offers an intuitive and delightful variable management feature where you can \neasily reference variables(a.k.a shared variables) in the same service or from another service\n within your project. We also provide the ability to \nseal variable values\n for extra security.\n\n\nAdditionally, Railway offers \nvariable functions\n that automatically generate secure secrets for your environment variablesâ€”eliminating the need for manual secret creation.\n\n\n\n\nNeed a random secret? Simply use: \n${{ secret() }}\n\n\nNeed a hex-encoded secret of a specific length? Just specify the length and character set: \n${{ secret(128, \"abcdef0123456789\") }}\n\n\n\n\nFly.io provides a basic secrets management feature, allowing users to store secrets with a digest. However, it lacks the advanced functionality of Railwayâ€™s shared variables and dynamic secret generation.\n\n\nDatabases\n\n\nMany applications rely on databases, and we believe managing them should be seamless and hassle-free. Thatâ€™s why Railway allows you to natively provision and deploy PostgreSQL, MySQL, Redis, and MongoDB directly within the platformâ€”no external setup required.\n\n\nFly.io, on the other hand, provisions Postgres, Upstash Redis, Upstash Kafka, and Upstash Vector. If you need MySQL or MongoDB, youâ€™ll have to manually set up and manage them via Docker. Alternatively, Fly recommends several external providers for these databases.\n\n\nRailway goes further by offering a built-in database UI, making management effortless. You can view tables, add and edit data directly from the platformâ€”no need for third-party tools. Fly does not provide an equivalent UI, requiring external tools for database management.\n\n\nTemplates\n\n\nRailway's \nTemplates Marketplace\n is rapidly expanding, with 940+ templates and counting. Any user can create and publish pre-configured starter setups or templates, making it effortless for developers to deploy apps and services with just one clickâ€”eliminating the hassle of manual setup.\n\n\nOur templates cover a wide range of frameworks and tools, including \nDjango\n, \nLaravel\n, \nMetabase\n, \nStrapi\n, \nMinIO\n, \nClickHouse\n, \nRedash\n, and \nPrometheus\nâ€”all deployable in seconds. From your dashboard, you can turn your project into a reusable template in under two minutes.\n\n\nWe also reward our creators through the \nKickback Program\n. When you publish a template and itâ€™s deployed by other users, you receive 50% of the usage costs as a kickback, credited either as cash (USD) or Railway creditsâ€”allowing you to earn while supporting the developer community.\n\n\nFly.io offers a selection of official and community-contributed application templates, mainly available through their GitHub fly-apps repositories. However, Fly does not have a centralized marketplace like Railway, nor does it provide any incentives for community templates.\n\n\nPricing\n\n\nAt Railway, we believe in transparent, \nflexible pricing\nâ€”\nyou only pay for what you use\n. With our pay-as-you-go model, you get an affordable flat fee for your selected plan, plus usage-based billing that scales with your needs. No overpaying, no hidden feesâ€”just straightforward pricing.\n\n\n\n\nTrial:\n Free + a one-time $5 credit for resource usage\n\n\nHobby:\n $5/month, includes $5 in usage credits every month\n\n\nPro:\n $20 per teammate/month\n\n\nEnterprise:\n Custom pricing\n\n\n\n\nFly.io follows a pure usage-based pricing modelâ€”there are no subscription tiers, meaning you pay based on the exact resources you consume. Check out \nFlyâ€™s pricing here\n.\n\n\nWant to see the savings?\n\n\nExplore our \ndetailed pricing breakdown\n to see how Railway keeps costs predictable while still giving you the flexibility to scale as needed.\n\n\nCustomer Support and Community\n\n\nAt Railway, we take pride in offering best-in-class support through our \nvibrant Discord community\n and our custom-built \nCentral Station\nâ€”a support platform powered by Railway itself. We believe that every project matters, no matter how big or small. If you run into an issue, weâ€™re here to help, and our engineers are always available to ensure you get the support you need.\n\n\nWith over \n880,000 users\n who love what we do, weâ€™re committed to continuous improvement. \nEvery week\n, we ship new features and updates to make Railway even betterâ€”because great support isnâ€™t just about answering questions, itâ€™s about building a platform that just works.\n\n\nFly.io offers paid support plans starting at $29/month for standard support, $199/month for premium, and $2,500+ for enterprise-level assistance. If you canâ€™t afford these plans, your only option is their community forum for help.\n\n\nWe are similar to Fly.io in the following ways:\n\n\n\n\nDatabase Backups\n\n\nBare Metal\n\n\nDocker Image deployments\n\n\nDockerfile deployments\n\n\nHealth checks\n\n\nZero downtime deploys.\n\n\nCustom domains\n\n\nStateful Services a.k.a Persistent Disks and Volumes\n\n\nPrivate Networking\n\n\nInstant Rollbacks\n\n\nInfrastructure as code\n\n\nCI/CD\n\n\nMonitoring, Observability and In-Dashboard logs\n\n\nAutoscaling and Scale to Zero\n\n\nMonorepo and multi-environment deployments.\n\n\nMulti-region deployments\n\n\nCLI tooling\n\n\nProgrammatic deployments via API\n\n\nServing static sites\n\n\n\n\nMigrate to Railway\n\n\nThinking about migrating from Fly.io to Railway? Weâ€™ve put together a \nquick and simple guide\n to make the transition effortless and fast.\n\n\nSign up on Railway\n today and get a $5 in free credits to explore the platform.\n\n\nFor companies and large organizations, weâ€™d love to chat! \nBook a call with us\n to see how Railway fit your needs.\nPrev\n \nCompare to Render\nNext\n \nCompare to Vercel\nEdit this file on GitHub\nOn This Page\nDifferences\nProduct and Deploy UX\nDeploy UI and GitHub Repo Deployments\nNative Crons\nPR Environments\nWebhooks\nVariables and Secrets\nDatabases\nTemplates\nPricing\nWant to see the savings?\nCustomer Support and Community\nWe are similar to Fly.io in the following ways:\nMigrate to Railway"
  },
  {
    "url": "https://docs.railway.app/maturity/compare-to-heroku",
    "title": "Railway vs. Heroku | Railway Docs",
    "content": "Railway vs. Heroku\nSummary\n\n\nRailway is a simple and powerful deployment platform that focuses on giving you and your team a deployment plane that radically increases developer efficiency.\n\n\nWe are alike in the following ways:\n\n\n\n\nGitHub repo deployments\n\n\nCLI tooling\n\n\nBuilt-in databases\n\n\n\n\nWe differ in the following:\n\n\n\n\nWe have an outsized focus on support and developer experience. A highly engaged community and the Railway team stand at the ready to help you scale\n\n\nResource-based pricing, only pay for what you use.\n\n\nBetter developer experience. We offer PR deploys, variable management, rapid builds, and local development flows.\n\n\nAnd much more...\n\n\n\n\nDifferences\n\n\nBuilds\n\n\nIn the current era of software development, using Docker adds a large workload to the average developer. We want to offer the developer all the benefits of reproducibility, speed, and ease of use when deploying images without the clunky boilerplate of Docker.\n\n\nHeroku's buildpacks are decent, but we want to offer the user a better experience. This is why we built Nixpacks.\n\n\nNixpacks is open source (\nhttps://github.com/railwayapp/nixpacks\n). It detects more languages, builds are faster, and builds are reproducible. (A common frustration of Heroku's Buildpacks).\n\n\nThose moving from Heroku to Railway will find an easy switch from Heroku's Buildpacks to Railway's Nixpacks.\n\n\nProduct\n\n\nDeploying a project on Railway is incredibly easy thanks to Nixpacks and our templating system. We have a \nquick start guide\n that will walk you through the process.\n\n\nIt's possible to go from zero â†’ 3 services in < 30 seconds. Adding new services is trivial and meshing them together means you don't need to deal with headaches based on your infrastructure.\n\n\nPricing\n\n\nPay only for what you useâ€”no need to size dynos.\n\n\nContainers scale vertically up to 8 GB/CPU Cores (on the Hobby Plan) and 32 GB/CPU Cores (on Teams Plans).\n\n\nDid traffic spike for an hour? Only pay for that hour, no manual scaling intervention required.\n\n\nFor those who prefer to pay upfront. We offer credit-based Developer plans who wish to load their account with credits.\n\n\nDevelop and Deploy\n\n\nYou can use the CLI to run every service locally, hooking in with your cloud infrastructure.\n\n\nFor example, running \nrailway run yarn start\n in a project with Postgres will automatically inject required enviroment variables such as \nDATABASE_URL\n.\n\n\nIf your changes look good, you can even run \nrailway up\n from the terminal to trigger a new deployment on demand.\n\n\nLifecycle Management\n\n\nWe offer guardrails to prevent new deployments from knocking your app offline, such as \nHealthchecks\n. By providing an endpoint for Railway to hit, we will make a series of requests, checking for a 200 OK response before we switch deploys to the most recent one.\n\n\nWant to revert a change? Because we image all builds, you can \nrollback\n to an earlier working deploy in just one click.\n\n\nSupport + Community\n\n\nRailway serves hundreds of thousands of thousands of builders who deploy applications that bring tremendous impact to themselves, their friends, and their customers.\n\n\nWe feel no project, big or small- is never not important. This is our guiding philosophy to our users.\n\n\nAs a result, we make great pains to be very communicative in our support channels, \noptimistically gather feedback\n, provide informative docs, and encourage our community to help each other.\n\n\nHaving an issue with a deployment? \nJoin over 25k Railway users on our Discord Server!\n With our dedicated support channels, you can get help from the Railway team and our community of builders.\nPrev\n \nIncident Management\nNext\n \nCompare to Render\nEdit this file on GitHub\nOn This Page\nSummary\nDifferences\nBuilds\nProduct\nPricing\nDevelop and Deploy\nLifecycle Management\nSupport + Community"
  },
  {
    "url": "https://docs.railway.app/maturity/compare-to-render",
    "title": "Railway vs. Render | Railway Docs",
    "content": "Railway vs. Render\nRailway is a modern, developer-focused cloud platform that simplifies app deployment and scaling. We are optimised for developer happiness and efficiency!\n\n\nNote:\n \nMigrate your app from Render to Railway in less than 4 steps.\n\n\nWe are similar in the following ways:\n\n\n\n\nGitHub repo deployments\n\n\nDocker Image deployments\n\n\nDockerfile deployments\n\n\nHealth checks\n\n\nZero downtime deploys.\n\n\nCustom domains\n\n\nStateful Services a.k.a Persistent Disks and Volumes.\n\n\nPrivate Networking\n\n\nInstant Rollbacks\n\n\nInfrastructure as code\n\n\nMonitoring, Observability and In-Dashboard logs\n\n\nAutoscaling\n\n\nPreview environments\n\n\nNative Crons\n\n\nMulti-region deployments\n\n\nCLI tooling\n\n\nProgrammatic deployments via API\n\n\n\n\nDifferences\n\n\nProduct and Deploy UX\n\n\nAt Railway, we take pride in delivering a superior user experienceâ€”from the simplicity of starting with \ndev.new\n to managing multiple interconnected services on your Project Canvas. The interface is not only functional but visually appealing, redefining how DevOps can feel. Who says DevOps has to be ugly or boring? On our platform, itâ€™s intuitive, refreshing, and even fun.\n\n\nOne delightful feature we offer is real-time collaboration. You can see exactly which of your teammates are working on the same Project Canvas, fostering seamless teamwork and collaboration.\n\n\nBuilds\n\n\nRender includes a build pipeline where each task consumes pipeline minutes. These minutes are allocated monthly based on your pricing tier and are billable. If you exceed your allotted pipeline minutes within a month, additional charges may apply, or your builds may be canceled.\n\n\nAt Railway, thereâ€™s no need to worry about managing build costs or minutes. Builds are always freeâ€”no matter how often you run them. Itâ€™s one less thing to plan, letting you focus entirely on building and deploying your apps.\n\n\nWe provide an exceptional deployment experience through \nNixpacks\nâ€”our custom-built, open-source solution that delivers incredibly fast, reproducible builds while automatically detecting and supporting over 22 languages. For advanced and customizable deployments, we also automatically detect and utilize your Dockerfile, giving you complete control.\n\n\nDatabases\n\n\nMany apps require the use of databases. We want to ensure that itâ€™s very convenient and easy to use and deploy as part of your services so we offer the ability to provision PostgreSQL, MySQL, Redis and MongoDB natively in the platform. Render only offers PostgreSQL and Redis natively and allows you install other alternatives via blueprints.\n\n\nRender charges a base amount for compute (CPU and Memory) for using a managed database plus storage while we charge \nfor only what you use\n in compute and storage. For example, if you use only 2 GB (RAM) and 1 CPU, we will charge you for only that plus storage.\n\n\nIf youâ€™re aware that there will be periods of inactivity, you can also enable \nApp Sleeping\n which reduces \nthe cost of usage\n by ensuring it runs only when absolutely necessary!\n\n\nThereâ€™s a resource-based calculator on our \npricing page\n that you can use to estimate how much youâ€™ll be charged based on \nCPU\n, \nMemory\n, \nVolume\n and \nNetwork Egress\n.\n\n\nWe also provide built-in UI for managing your database easily without the need for external tools. You can see your tables, add and edit data. Render does not.\n\n\nDatabase Backups\n\n\nWe provide \nnative database backups\n for users on our platform. Customers can create, delete and restore backups for services with volumes (or persistent disks) directly from the dashboard.\n\n\nRender provides a Point-in-Time Recovery to restore your database from 3 or 7 days max and on-demand logical backups.\n\n\nTemplates\n\n\nWe have an increasingly \ngrowing templates marketplace (850+)\n where any user can build and publish a pre-configured starter app setup or template to help developers quickly deploy apps or services on Railway.\n\n\nThey simplify the deployment process by providing one-click deploy buttons for popular frameworks, tools, saving developers the time and effort of setting up projects from scratch. From your dashboard, you can turn your project into a reusable template in less than 2 minutes. For example, you can deploy \nDjango\n, \nLaravel\n, \nMetabase\n, \nStrapi\n, \nMinIO\n, \nClickHouse\n, \nRedash\n, \nPrometheus\n instantly just by clicking on these links.\n\n\nWe offer a rewarding \nkickback program\n for our creators. When you publish a template and itâ€™s deployed into other usersâ€™ projects, you become instantly eligible for a 50% kickback of the usage costs incurredâ€”credited to you either as cash in USD or as Railway credits added to your account.\n\n\nRender has example templates on GitHub that you can deploy and no incentives for community templates.\n\n\nPrivate Networking\n\n\nRenderâ€™s private network is regional. Services in different regions canâ€™t communicate directly over a private network.\n\n\nAt Railway, private networking operates globally. This means services in different regions can communicate with each other privately without any barriers or extra configuration. Additionally, you have the flexibility to move services between regions effortlessly.\n\n\nPricing\n\n\nWe believe in the principle of \npay only for what you use\n. With Railway, you pay an affordable flat fee for the plan you choose, and additional costs are based solely on the resources (compute) you consume each month. In summary, a flexible pay-as-you-go model!\n\n\n\n\nTrial\n: Free, plus one-time $5 credit for resource usage\n\n\nHobby\n: $5/month, plus $5 credit for resource usage monthly\n\n\nPro\n: $20 per teammate/month\n\n\nEnterprise\n: Custom pricing\n\n\n\n\nRender Pricing\n:\n\n\n\n\nHobby\n: Free\n\n\nPro\n: $19/month\n\n\nOrg\n: $29 per teammate/month\n\n\nEnterprise\n: Custom pricing\n\n\n\n\nCurious about the savings? Check out a \ndetailed breakdown of our pricing\n and see how much you can save by running your workloads on Railway. Itâ€™s more cost-effective than \nRender\n.\n\n\nCustomer Support and Community\n\n\nAt Railway, we take pride in providing best-in-class support through our \nvibrant Discord community\n and our custom-built \nCentral Station\nâ€”a platform powered by Railway itself. We firmly believe that no project is too small or unimportant when it comes to addressing support needs. If an issue arises, weâ€™re here to help.\n\n\nWith over \n900,000 users\n who think weâ€™re the best thing since sliced bread, weâ€™re committed to continuously improving. \nWeek after week\n, we ship new features and updates to better support our customers.\n\n\nTo meet the unique needs of our customers, we offer tailored \nsupport tiers\n, ensuring users receive the assistance they need at every step.\nPrev\n \nCompare to Heroku\nNext\n \nCompare to Fly\nEdit this file on GitHub\nOn This Page\nDifferences\nProduct and Deploy UX\nBuilds\nDatabases\nDatabase Backups\nTemplates\nPrivate Networking\nPricing\nCustomer Support and Community"
  },
  {
    "url": "https://docs.railway.app/maturity/compare-to-vercel",
    "title": "Compare to Vercel | Railway Docs",
    "content": "Compare to Vercel\nSummary\n\n\nRailway is an intuitive cloud platform that streamlines your deployment workflow, letting developers focus on building great products instead of managing infrastructure.\n\n\nRailway also offers\n\n\n\n\n\n\nZero configuration required\n - We automatically detect your language and deploy your application.\n\n\n\n\n\n\nFramework templates\n - We have templates for many popular frameworks, including Next.js, Nuxt, Express, \nand more\n.\n\n\n\n\n\n\nZero maintenance\n - We handle the underlying infrastructure, so you don't have to.\n\n\n\n\n\n\nGlobal distribution\n - We deploy your application to multiple regions, so you can serve your users faster.\n\n\n\n\n\n\nCron jobs\n - Cron jobs are just another service that run on a schedule, no extra packages, no extra setup.\n\n\n\n\n\n\nThis is just scratching the surface of the similarities between Railway and Vercel!\n\n\nRailway excels with\n\n\n\n\n\n\nStraightforward pricing\n - We charge based on the resources your application uses, rather than function invocations, config reads, observability, etc.\n\n\n\n\n\n\nUniversal deployment support\n - Deploy any application or service, from static sites to complex backends.\n\n\n\n\n\n\nRich OSS ecosystem\n - We have templates for many popular OSS projects, including Supabase, N8N, and Typebot.\n\n\n\n\n\n\nDeveloper-centric experience\n - We prioritize intuitive workflows, providing a unique dashboard to manage your services, including scaling, logs, and more.\n\n\n\n\n\n\nPersistent Disks\n - We provide persistent disks for your application, so you don't have to worry about data loss.\n\n\n\n\n\n\nBest in Class Support\n - Incredibly fast personalized support on Slack, and the \nCentral Station\n.\n\n\n\n\n\n\nPrivate networking\n - Seamlessly and securely connect your services together through the global wireguard network.\n\n\n\n\n\n\nDeploy any container\n - We support Dockerfiles, and we also support deploying container images from both public and private registries.\n\n\n\n\n\n\nImprovements over Vercel\n\n\nProduct and Deploy UX\n\n\nWe offer a unique dashboard to manage your many projects, the services within them, and the collaborators on your projects.\n\n\nWithin each project can be found the \nProject Canvas\n which is a real-time collaborative canvas that lets you see all your services and the connections between them. This visual approach makes it easy to understand your entire infrastructure at a glance - from databases and APIs to frontend services and their relationships.\n\n\nIt is your mission control center, where all aspects of your project come together. Monitor your services in real-time, manage environment variables, scale resources up or down, and view logs - all from one unified interface. The Project Canvas makes infrastructure management intuitive by showing you exactly how your services connect and interact, while enabling real-time collaboration with your team.\n\n\nThis unified view eliminates the need to jump between different dashboards and tools, making infrastructure management more intuitive and efficient.\n\n\nBuilds\n\n\nWe provide native support for 22 languages (including Node.js, Python, Ruby, Go, and more) with our custom-built, open-source solution, \nNixpacks\n, delivering incredibly fast, reproducible builds.\n\n\nSimply give us a GitHub repository and we'll automatically detect the language and build it for you, completely hands off.\n\n\nFor advanced and customizable deployments, we also automatically detect and utilize your Dockerfile, giving you complete control over your deployment.\n\n\nRuntime\n\n\nWe run with a serverfull container runtime for maximum compatibility and performance, this allows for greater flexibility in what you can deploy since you aren't limited by available runtimes.\n\n\nA container runtime also means your application will be ran as-is, meaning you don't have to worry about how a runtime will modify your application or its state, we just run your application as-is.\n\n\nSince we are serverfull, there are no cold starts, or pre-warming, your application will be up and running to handle requests at all times instantaneously.\n\n\nThere are so many benefits to a serverfull runtime, and we are just scratching the surface of what benefits you get from it.\n\n\nMulti-Region Deployments\n\n\nWith a few clicks, you can deploy your application to multiple regions globally, and we'll automatically route your users to the closest region.\n\n\nThis is incredibly useful for reducing latency and improving the performance of your application, and it is all managed from the dashboard and transparently handled by us.\n\n\nUse Cases\n\n\nWhile Vercel's focus is on frontend, Railway is a complete platform for both frontend and backend deployments.\n\n\nThis very website is built with Next.js and deployed on Railway, let alone \nrailway.com\n itself is deployed on Railway, and it is also built with Next.js.\n\n\nYou can deploy anything from a simple static site to a complex backend built out with microservices all connected privately through our global wireguard network.\n\n\nDatabases\n\n\nInstead of 3rd party integrations, we natively support PostgreSQL, MySQL, Redis, MongoDB, and more â€” all manageable directly from our platform without external providers, and best of all, they are billed the same as any other service on Railway.\n\n\nOur built-in database UI lets you view tables and manage data directly from the dashboard, eliminating the need for third-party tools. Plus, with our \nnative database backups\n, you can easily create, delete, and restore backups for your databases.\n\n\nPrivate Networking\n\n\nWe provide a private wireguard network to connect your services together, this allows for private communication between services without the need for public internet, ex. between a backend and a database.\n\n\nThis is incredibly useful for reducing latency and improving the performance of your application, and it is all managed from the dashboard and transparently handled by us.\n\n\nYou don't pay egress fees for private networking, meaning you don't pay for the data that flows between your services, this is incredibly useful for reducing costs.\n\n\nCron Jobs\n\n\nCron jobs are just another service that run on a schedule, no extra packages, no extra setup.\n\n\nOnly pay for the time they run, and only for the resources they use while running, this makes them outstandingly cost effective.\n\n\nTemplates\n\n\nRailway's \nTemplates Marketplace\n features 940+ templates and counting. Any user can deploy pre-configured starter setups, making it effortless to deploy apps and services with just one click.\n\n\nThe template marketplace contains templates for many popular OSS projects, including Supabase, N8N, and Typebot. Deploying these templates is as easy as clicking a button, and they are all configured to deploy with the best practices for Railway.\n\n\nBest of all, through our \nKickback Program\n, template creators receive 50% of the usage costs when others deploy their templatesâ€”either as cash (USD) or Railway credits.\n\n\nPricing\n\n\nRailway offers straightforward and transparent, \nresource-based pricing\n that scales with your needs, pay only for the resources you use. You can find \nspecific per-minute pricing here\n.\n\n\nUnlike Vercel's function-based pricing, we charge based on actual resource usage (CPU, Memory, Storage), making costs more predictable and often more economical for backend services.\n\n\nAnd fortunately, this simple pricing model does not change based on the region you deploy to.\n\n\nSupport\n\n\nWe offer incredibly fast and personalized support on Slack, and the \nCentral Station\n.\n\n\nOur Central Station is built in house from the ground up to allow us to provide the best possible support to you, the user.\n\n\nPro and enterprise users get priority support within Slack, and entrpise can also book a call with our team to get direct help from the Railway team.\n\n\nReady to Switch?\n\n\nThinking about migrating from Vercel to Railway? We've made it simple! Check out our \nmigration guide\n to get started.\n\n\nSign up on Railway\n today and get $5 in free credits to explore the platform.\n\n\nFor companies and large organizations, we'd love to chat! \nBook a call with us\n to see how Railway will fit your needs.\nPrev\n \nCompare to Fly\nNext\n \nCompare to DigitalOcean\nEdit this file on GitHub\nOn This Page\nSummary\nRailway also offers\nRailway excels with\nImprovements over Vercel\nProduct and Deploy UX\nBuilds\nRuntime\nMulti-Region Deployments\nUse Cases\nDatabases\nPrivate Networking\nCron Jobs\nTemplates\nPricing\nSupport\nReady to Switch?"
  },
  {
    "url": "https://docs.railway.app/maturity/compliance",
    "title": "Compliance | Railway Docs",
    "content": "Compliance\nRailway is designed to be used by companies of all sizes. We understand that companies have different needs when it comes to compliance and security. We are happy to work with you to ensure that Railway meets your needs. We have worked with teams in gov't, healthcare, and finance to ensure that Railway meets their needs.\n\n\nCompanies choose Railway so that they can speed up their development velocity while also maintaining their security and compliance posture.\n\n\nWe are happy to sign NDAs with your company to provide additional information about our security and compliance practices. Please reach out to us at \nteam@railway.com\n to get started, or click \nhere\n to book some time to chat.\n\n\nCertifications\n\n\nWe know that your businesses need to develop strong and lasting relationships with your vendors to build confidence that we can be trusted to deliver your workloads. Part of that is through certifications, audits, and continual refinement of our practices. Railway aims to comply with all the distributions of workloads and privacy procedures.\n\n\nSOC 2\n\n\nRailway is SOC 2 Type I certified.\n\n\nHighly motivated customers (Pro tier and higher) who are in the process of securing SOC 2 certification can request a copy of the Railway security audit.\n\n\nTo make this request, please book a session with a Railway team member \nhere\n.\n\n\nSOC 2 Type II certification is expected by the \nend of May 2025\n.\n\n\nHIPAA BAA\n\n\nRailway follows a shared responsibility model for HIPAA compliance and PHI. Railway will make its best effort to advise your company on setting up encryption for your data, auditing the storage of keys, establishing access control, and ensuring secure storage of sensitive patient data. When a BAA is in effect, the Railway team will no longer be able to directly access your running workloads.\n\n\nHIPAA BAA is an add-on with a paid monthly spend threshold. All pricing goes towards your \nusage on Railway\n. Monthly thresholds for addons is found in our \ncommited spend pricing\n.\n\n\nIf your company needs a BAA, you can contact our solutions team at \nteam@railway.com\n, or click \nhere\n to schedule some time to chat.\n\n\nWe are working on operationalized BAAs and continually gathering requirements for health-focused workloads for Enterprises. You can share your feedback in \nCentral Station\n.\n\n\nPrivacy\n\n\nRailway is committed to protecting the privacy of our users. We understand that when working with user code and data, it is important to have a clear understanding of how we handle your data. Railway, on behalf of our users, may remove offending workloads but at no point will a Railway team member modify your application without your expressed permission through an approved communication channel.\n\n\nClick here to see our Privacy Policy.\n\n\nVAT Tax ID and Address\n\n\nCustomers in the EU may need to add their VAT Tax ID to their invoices for compliance and reporting purposes.\n\n\nYou can add your VAT Tax ID and address in \nWorkspace settings\n -> Billing -> Manage Subscription.\n\n\nIf you have multiple workspaces, you need to add your VAT Tax information to each respective Workspace's Subscription.\n\n\nAfter adding your information, it will appear on your future invoices.\n\n\nEU Dora\n\n\nFor European organizations in finance that need to comply with \nEU Dora\n - Railway is willing to provide documents after a click through NDA that describe disaster recovery procedures, uptime statistics, and IT controls for organizations to who need to submit compliance documents to local regulators. You can get information on our \nTrust Page\nPrev\n \nUse Cases\nNext\n \nIncident Management\nEdit this file on GitHub\nOn This Page\nCertifications\nSOC 2\nHIPAA BAA\nPrivacy\nVAT Tax ID and Address\nEU Dora"
  },
  {
    "url": "https://docs.railway.app/maturity/incident-management",
    "title": "Incident Management | Railway Docs",
    "content": "Incident Management\nIntroduction\n\n\nRailway understands the importance of effective incident management procedures. We do what we can to minimize downtime, mitigate the impact of incidents, and ensure the smooth operation of our systems. In the interest of transparency, we publish as much of our procedure to keep our customers in the know on how we handle and learn from incidents.\n\n\nMonitoring + Reporting\n\n\nRailway has a robust monitoring system in place to proactively detect and address any potential incidents. We continuously monitor our infrastructure, including servers, networks, and applications, to ensure their smooth operation. By monitoring key metrics and performance indicators, we can identify any anomalies or potential issues before they escalate into full-blown incidents.\n\n\nHowever, it's important to note that while we strive to stay ahead of incidents, there may be situations where unforeseen issues arise. In such cases, we rely on qualitative customer feedback to help us identify and address any issues promptly. We encourage our customers to report any problems they encounter through our \nCentral Station\n, \nSlack\n, or \nDiscord\n.\n\n\nStatus Page + Uptime\n\n\nRailway's uptime and incident retrospective can be accessed on the Railway Instatus page at \nhttps://railway.instatus.com/\n. On this page, you can view the historical uptime of Railway's systems and services. Additionally, you can find detailed information about past incidents, including retrospectives that provide insights into how incidents were handled and what measures were taken to prevent similar issues in the future.\n\n\nFor Enterprise customers, we offer SLOs and guarantees of service that may not be represented on the uptime dashboard.\n\n\nIncident Severity\n\n\nRailway catalogues incident's in the following buckets.\n\n\n\n\nHigh\n: the incident is potentially catastrophic to Railway Corporation and/or disrupts\nRailway Corporationâ€™s day-to-day operations; violation of contractual requirements is likely. Ex. Any business level impact to 25 percent of our customers for one hour or more. All incidents within this severity get public communications.\n\n\nMedium\n: the incident will cause harm to one or more business units within Railway\nCorporation and/or will cause delays to a customer business unitâ€™s activities.\n\n\nLow\n: the incident is a clear failure of a component, but will not substantively impact the business. Railway still performs retrospectives within this severity.\n\n\n\n\nResponsible Disclosure\n\n\nEnterprise customers get Root Cause Analysis, and we attempt to publish event retrospectives on \nhttps://blog.railway.com/engineering\nPrev\n \nCompliance\nNext\n \nCompare to Heroku\nEdit this file on GitHub\nOn This Page\nIntroduction\nMonitoring + Reporting\nStatus Page + Uptime\nIncident Severity\nResponsible Disclosure"
  },
  {
    "url": "https://docs.railway.app/maturity/philosophy",
    "title": "Philosophy | Railway Docs",
    "content": "Philosophy\nRailway is a deployment platform that helps developers deliver their software through the entire application life-cycle through git native tooling, composable infrastructure, and built-in instrumentation.\n\n\nWe design and develop our product features to serve what we consider to be the three primary stages of software development:\n\n\n\n\nDevelopment\n\n\nDeployment\n\n\nDiagnosis\n\n\n\n\nMost developer-oriented products attempt to target one or more stages within the software development cycle. Railway provides solutions for developers for all of these stages, whereas some vendors focus on specific stages.\n\n\nRailway is a company staffed with people who know developers would prefer to use tools they are familiar with. We believe software should be \"take what you need, and leave what you don't.\" As a result, we are comfortable recommending additional vendors if they might acutely meet their needs. Our goal is for your unique need to be served so you can focus on delivering for your customers.\n\n\nCompanies should be as upfront as possible about their product and offerings to help you decide what is best for your team and users.\n\n\nLet's talk about the number one use case: delivering apps to users in a Production environment. Railway, the company, is sustainable, building our product, team, and company to last as your projects.\n\n\nObjective\n\n\nThe goal of this section is to describe the processes, internal and external that companies have requested in our years of operation to help them build confidence to determine if Railway is a good fit for their company.  Railway maintains a policy to be forthcoming and frank at all times. We would rather have a developer make the correct choice for their company than to adopt Railway and then come to regret that decision.\n\n\nIf you have any additional questions or if you require any additional disclosure you can contact us to set up a call at \nteam@railway.com\n.\n\n\nProduct Philosophy\n\n\nRailway is focused on building an amazing developer experience.  Our goal is to enable developers to deploy their code and see their work in action, without thinking about CI/CD, deployments, networking, and so forth, until they need to.\n\n\nTake What You Need\n\n\nTo achieve our goal, we've designed Railway to \"just work\", with all the necessary magic built in to achieve that. Railway at a high level reads your code repo, makes a best guess effort to build it into an \nOCI compliant image\n, and runs the image with a start command.\n\n\n\n\nHave a code repository but have yet to think about deployment? We got you. Connect your code repository and let Railway take care of the rest.\n\n\nAlready built the perfect Dockerfile?  Bring it.  If you have a Dockerfile in your repo, we'll find it and use that to build your image.\n\n\n\n\nIf you've outgrown the \"magic\" built into deployment platforms, or are suspicious of things that are just too magical, we are happy to provide a high level overview of our architecture.\n\n\nLeave What You Don't\n\n\nStreamlined deployment workflows and sane defaults are inherited by every project in Railway out of the box; but as a team of engineers, we at Railway are very aware that what works for one project does not always work for another.  Or sometimes, you just need to be in control - maybe you already have a workflow you like, or maybe you need to layer Railway into existing infrastructure, and abstractions only get in your way.\n\n\nThat's why we've designed the platform for flexibility, wherever you need it.\n\n\nOn Railway, you can use the default pattern for deployment or opt to use vendor. In fact, we will even support you in your effort to integrate Railway in a unique way.  Here are a couple of use cases we've helped customers take advantage of -\n\n\n\n\nDeploying to Railway from Gitlab CI/CD\n\n\nSupporting the development of a Terraform provider\n\n\nRegion based routing to workloads via Cloudflare\n\n\n\n\nWe love working with our customers to solve interesting use cases. If you're not seeing a track for you, get in touch at \nteam@railway.com\n and we'll find it!\n\n\nHigh-level Architecture\n\n\nAs mentioned before, Railway at a high level takes your code, builds it, and throws it on running infrastructure on GCP. At a granular level Railway relies on a few systems to maintain workloads.\n\n\n\n\nBuild Layer\n\n\n\n\nWhere archived folders of code or a Dockerfile (via GitHub or \nrailway up\n) is sent to be built into an image\n\n\nNixpacks\n: the OSS software that reads your code and builds it via Nix\n\n\nImage Registry: either via Dockerhub/GitHub packages, or a previously built image from Railway's Build servers\n\n\n\n\n\n\nDeployment Layer\n\n\n\n\nWhere images are ran in containers, images are pulled from the Build Layer\n\n\nDatabases on Railway are images + volumes mounted on a machine\n\n\nCron services are containers ran on a defined schedule\n\n\n\n\n\n\nRouting Layer\n\n\n\n\nThis is the system that Railway maintains that routes requests into your running containers and provides private networks to suites of containers.\n\n\n\n\n\n\nLogging Layer\n\n\n\n\nA suite of machines networked running Clickhouse that store container logs. This is accessed when you open the service logs pane.\n\n\n\n\n\n\nDashboard Layer\n\n\n\n\nInfrastructure and code that is used to manage the above layers.\n\n\nThis also incudes any monitors that Railway uses to maintain the state of the Deployment Layer to maintain application state. (ex. Removing a deployment.)\n\n\n\n\n\n\n\n\nYour code will either be in some, or all steps depending on the amount of Railway that you choose to adopt.\n\n\nOperational Procedures\n\n\nRailway uses a suite of alerting vendors, additional internal tools, and PagerDuty to ensure uptime of our services described above. You can see Railway's uptime on our \nInstatus page\n. Operational incident management reports and RCAs are available by request for those on an Enterprise plan.\n\n\nDo I have to change how I write code?\n\n\nNo, Railway is a deployment platform that works with your existing code. We don't require you to change how you write code or use any specific frameworks. We support all languages and frameworks that can be run in a Docker container or within Nixpacks.\n\n\nIs Railway serverless?\n\n\nNo, services on Railway are deployed in stateful Docker containers. The old deployments are removed on every new deploy.\n\n\nWe do have a feature, \nApp Sleeping\n, that allows you to configure your service to \"sleep\" when it is inactive, and therefore will stop it from incurring usage cost while not in use.\n\n\nBook a Demo\n\n\nIf you're looking to adopt Railway for your business, we'd love to chat and ensure your questions are answered.  \nClick here to book some time with us\n.\nPrev\n \nProduction Readiness Checklist\nNext\n \nUse Cases\nEdit this file on GitHub\nOn This Page\nObjective\nProduct Philosophy\nTake What You Need\nLeave What You Don't\nHigh-level Architecture\nOperational Procedures\nDo I have to change how I write code?\nIs Railway serverless?\nBook a Demo"
  },
  {
    "url": "https://docs.railway.app/maturity/use-cases",
    "title": "Use Cases | Railway Docs",
    "content": "Use Cases\nRailway is suited for a variety of use-cases. This page will walk-through what the platform is perfect for today and our recommendations for apps of all sizes.\n\n\nAs mentioned in our philosophy document. Railway will make a best effort to provide all the information a developer needs to make the best choice for their workload.\n\n\nIs Railway Production Ready?\n\n\nMany of our customers use Railway to reliably deploy their applications to customers at scale. With that said, Production standards are going to be different depending on what your users expect. We have companies that use Railway in a variety of different verticals such as:\n\n\n\n\nEnterprise SaaS\n\n\nConsumer Social\n\n\nEducation\n\n\nE-Commerce\n\n\nCrypto\n\n\nML/AI\n\n\nAgencies\n\n\n\n\nCompanies on Railway range from hobby projects, to extremely fast growing startups, to publicly traded companies. Railway has been incrementally adopted from using the platform as a developer's scratchpad before writing Terraform to hand off to an Ops. team or being implemented end to end.\n\n\nRailway's been in operation for now for more than three years and we have served billions of requests, with 100s of millions of deploys serving millions of end-users simultaneously.\n\n\nRailway Scale\n\n\nAll of these verticals deploy workloads that may require high bandwidth operations or intensive compute.\n\n\nHowever, service scale on the platform is not unbounded. As a foundational infrastructure company, we understand that customers may outpace our pace of improvement for the platform. Even though 32 vCPU and 32 GB of memory sounds like a lot (with up to 20 replicas) on the Pro plan, when faced with hyper-growth: throwing more resources at the issue might be your best bet until long term optimizations can be made by your team.\n\n\nRailway will gladly bump up your service limits within your tier of service to meet your needs. Even so, we will be frank and honest if you may need to seek elsewhere to augment your workloads with extra compute. If your compute needs outpace our Pro offering, consider our Enterprise plans where we offer even greater limits and capacity planning, \nemail us to learn more\n, or \nclick here\n to schedule some time to chat.\n\n\nDatabases\n\n\nWe have customers using our databases for their production environment with no issue. Railway's plugins are optimized for a batteries included development experience. They are good for applications that are prioritizing velocity and iteration speed over scale.\n\n\nOur databases are provided with no SLAs, are not highly available, and scale only to the limits of your plan. We don't think they are suitable for anything mission-critical, like if you wanted to start a bank.\n\n\nWe advise developers to:\n\n\n\n\nConfigure backups\n\n\nRun-book and restore their backups\n\n\nConfigure secondaries to connect to in-case of a disaster situation\n\n\n\n\nIncluded in our planned near-term work for databases on Railway are additional database metrics, and SSH access into the running database.\n\n\nAs mentioned before: we don't believe in vendor lock-in here at Railway, if your needs outpace us, consider other vendors like PlanetScale (for MySQL) or Cockroach (for Postgres).\n\n\nMetrics\n\n\nRailway provides up to 7 days worth of data on service information such as:\n\n\n\n\nCPU\n\n\nMemory\n\n\nDisk Usage\n\n\nNetwork\n\n\n\n\nWe also overlay commit and deployment behavior to correlate issues with application health to deployments. This is on top of the service logs that are continually delivered to users viewing a particular deployment of a service.\n\n\nFor service logs, we store logs for up to 90 days for Pro plan workspaces.\n\n\nIncluded in our planned near-term work for logging and observability on Railway are improvements to structured logging, and OpenTelemetry compatible endpoints.\n\n\nIt is common for teams who wish to have additional observability to use an additional monitoring tool that maintains a longer time horizon of data such as New Relic, Sentry, or Datadog. Within projects, deploying a Datadog Agent is as easy as deploying the template and providing your Datadog API Keys.\n\n\nNetworking\n\n\nRailway doesn't have a hard bandwidth limit to the broader internet.\n\n\nWe may throttle your outbound bandwidth and reach out to you when it exceeds 100GB/month to ensure the legitimacy of your workloads. If you need to control where your traffic is allowed to come from such as setting up firewall rules, we recommend setting up Cloudflare or an external load balancer/L7 application firewall to handle it.\n\n\nPrivate networking bandwidth is un-metered.\n\n\nWe intend to provide advanced traffic-shaping controls within Railway in the future.\n\n\nService Level Objectives\n\n\nRailway does meet SLOs for companies who have greater need for incident, support, and business planning responsiveness. We provide this via Business Class, offered as an add-on to Pro plans and included in all Enterprise plans. \nMore info.\n\n\nWill Railway exist in 10 years?\n\n\nA common question we get in conversations with (rightly) skeptical developers is the above question. Most documentation pages don't address the meta question of a company's existence but how we run \nour\n business affects yours.\n\n\nThe short and simple answer is: \nYes\n.\n\n\nRailway aims to exist for a very long time. Railway has presence on existing public clouds, while also building out presence on co-location providers. As a company, we have been structured sustainably with a first principles approach to every expense while growing sustainably.\n\n\nUnsupported Use-Cases\n\n\nUnfortunately, our platform isn't yet well-equipped to handle the following verticals that require extensive Gov't certification or GPU compute:\n\n\n\n\nGovernment\n\n\nTraditional Banking\n\n\nMachine Learning Compute\n\n\n\n\nGeneral Recommendations\n\n\nA document like this can only go so far. We have a standing invitation for any team who needs an extended scale use-case to reach out to us directly by e-mailing \nteam@railway.com\n, or via our \nDiscord server\n.  You can also schedule some time with us directly by clicking \nhere\n.\n\n\nWe would be happy to answer any additional questions you may have.\nPrev\n \nPhilosophy\nNext\n \nCompliance\nEdit this file on GitHub\nOn This Page\nIs Railway Production Ready?\nRailway Scale\nDatabases\nMetrics\nNetworking\nService Level Objectives\nWill Railway exist in 10 years?\nUnsupported Use-Cases\nGeneral Recommendations"
  },
  {
    "url": "https://docs.railway.app/migration/migrate-from-digital-ocean",
    "title": "Not Found",
    "content": "Page not found\nMaybe you were looking for one of the following\nHome\nGetting Started\nCLI Quick Start\nRailway Up"
  },
  {
    "url": "https://docs.railway.app/migration/migrate-from-digitalocean",
    "title": "Migrate from DigitalOcean to Railway | Railway Docs",
    "content": "Migrate from DigitalOcean to Railway\nThis guide demonstrates how to migrate your WordPress site from DigitalOcean to Railway's modern cloud platform. Railway provides a streamlined deployment experience with powerful infrastructure features.\n\n\nRailway offers:\n\n\n\n\n\n\nModern Infrastructure\n: High-performance cloud platform\n\n\n\n\n\n\nQuick Setup\n: WordPress-ready deployment template\n\n\n\n\n\n\nDatabase Support\n: MariaDB database capabilities\n\n\n\n\n\n\nIntegrated SSL\n: Automatic SSL certificate management\n\n\n\n\n\n\nScalable Infrastructure\n: Easily handle traffic spikes and growth\n\n\n\n\n\n\nCollaborative Features\n: Team management, deployment protection, and role-based access\n\n\n\n\n\n\nPriority Support\n: Dedicated support for Railway users\n\n\n\n\n\n\nMigration Steps\n\n\nLet's walk through migrating a WordPress site from DigitalOcean to Railway. This process involves backing up your existing installation, deploying WordPress on Railway and then restoring from your backup.\n\n\n1. Backup your WordPress site\n\n\n\n\n\n\nEnsure you have a backup of your existing site. Use a WordPress backup plugin of your choice to export your site data.\n\n\nMake sure this backup includes, All WordPress files, All WordPress database tables, All WordPress uploads.\n\n\n\n\n\n\nDocument your current configuration\n\n\n\n\n\n\nNote any custom domain settings\n\n\n\n\n\n\nKeep track of your username and password for wp-admin.\n\n\n\n\n\n\n\n\n\n\n2. Deploy WordPress\n\n\n\n\n\n\nOpen the \nWordPress Template\n page\n\n\n\n\n\n\n\n\nClick \"Deploy Now\" to Deploy the WordPress template.\n\n\n\n\n\n\nSince this template doesnâ€™t require any configuration, Click \"Deploy\" and wait for the deployment to complete.\n\n\n\n\n\n\nThe template will automatically configure -\n\n\n\n\n\n\nA MariaDB database\n\n\n\n\n\n\nInitial WordPress setup\n\n\n\n\n\n\nRequired environment variables\n\n\n\n\n\n\nA temporary service domain\n\n\n\n\n\n\n\n\n3. Restore your site content\n\n\nAfter the template deployment completes -\n\n\n\n\n\n\nAccess your WordPress installation via the temporary service domain.\n\n\n\n\n\n\nConfigure your WordPress settings\n\n\n\n\n\n\nInstall your preferred backup plugin\n\n\n\n\n\n\nRestore your site content from your backup\n\n\n\n\n\n\n4. Configure Domain Settings\n\n\nTo set up your custom domain:\n\n\n\n\n\n\nOpen your service's Settings in Railway\n\n\n\n\n\n\nNavigate to the \"Networking\" section\n\n\n\n\n\n\nAdd your custom domain\n\n\n\n\n\n\nUpdate your DNS records according to the instructions given.\n\n\n\n\n\n\nNote:\n You will need to redeploy your service for WordPress to pick up the new domain.\n\n\n\n\n5. Verify Migration\n\n\nBefore finalizing your migration -\n\n\n\n\n\n\nTest all WordPress functionality\n\n\n\n\n\n\nVerify all pages and posts are displaying correctly\n\n\n\n\n\n\nCheck media files are properly loaded\n\n\n\n\n\n\nTest user authentication\n\n\n\n\n\n\nVerify contact forms and other interactive elements\n\n\n\n\n\n\n6. Performance Optimization\n\n\nConsider these optimization options for your WordPress deployment:\n\n\n\n\n\n\nConfigure caching by placing Cloudflare or a similar CDN in front of your site.\n\n\n\n\n\n\nOptimize database performance by setting up a caching plugin.\n\n\n\n\n\n\nSet up appropriate scaling configurations.\n\n\n\n\n\n\nImplement CDN if needed\n\n\n\n\n\n\nThat's all you need to migrate your WordPress site from DigitalOcean to Railway! Need assistance? The \nCentral Station\n is there to help you with any questions during your migration process.\nPrev\n \nMigrate from Vercel\nNext\n \nThe Conductor Program\nEdit this file on GitHub\nOn This Page\nMigration Steps\n1. Backup your WordPress site\n2. Deploy WordPress\n3. Restore your site content\n4. Configure Domain Settings\n5. Verify Migration\n6. Performance Optimization"
  },
  {
    "url": "https://docs.railway.app/migration/migrate-from-fly",
    "title": "Migrate from Fly to Railway | Railway Docs",
    "content": "Migrate from Fly to Railway\nThis guide walks you through the steps needed to seamlessly migrate your app and data from Fly.io to Railway. This process is straightforward and typically takes an average of \n5 - 20 minutes\n, depending on the size of your database and app complexity.\n\n\nTL;DR: Quick Migration Steps\n\n\n\n\nSet up new app on Railway\n\n\nExport data from Fly.io and Import into Railway DB\n\n\nDeploy app (including auto-migration of app config & variables)\n\n\n\n\nWe provide everything Fly.io offersâ€”and more! Check out our \ncomparison guide\n to see the differences and make an informed choice.\n\n\nWhy take our word for it? Experience the \nRailway advantage yourselfâ€”give it a spin today!\n\n\nMigration Steps\n\n\nIn this guide, we will migrate a Go (Gin) app with a Postgres database from Fly.io to Railway. While we are using this app as an example, the process applies to any app, making it easy to transition your projects smoothly.\n\n\nHereâ€™s the link to the \napp\n.\n\n\n1. Set Up a Railway Project\n\n\nNavigate to \nRailway's Project Creation Page\n.\n\n\nSelect the \nDeploy from GitHub Repo\n option and connect your repository. If your Railway account isnâ€™t linked to GitHub yet, youâ€™ll be prompted to do so.\n\n\n\n\n2. Deploy the App\n\n\nRailway auto-imports all the build configurations, deploy commands, environment variables from your Fly.io app repoâ€”no manual setup needed.\n\n\nIf the environment variables are missing, you can easily add them manually by following these steps:\n\n\nAdding Environment Variables on Railway:\n\n\n\n\nNavigate to the \nVariables\n section of your service.\n\n\nSwitch to the \nRaw Editor\n and paste the copied environment variables.\n\n\nDeploy the changes to apply the configuration.\n\n\n\n\n\n\nRailway will deploy the Gin app as a service, as shown in the image above. You can monitor the service building and deploying in the \nProject Canvas\n.\n\n\nServerless (App Sleep) activated\n: In this \nFly.io\n app\n, the HTTP service is configured with \nauto_stop_machines='stop'\n and \nauto_start_machines=true\n, enabling automatic stopping and restarting of machines. On Railway import, we automatically enable this setting to effortlessly optimize resource usage.\n\n\n\n\n3. Database Migration\n\n\nRailway supports a variety of databases, including \nPostgreSQL\n, \nMongoDB\n, \nMySQL\n, and \nRedis\n, allowing you to deploy the one that best fits your application needs. We also support many more via our \ntemplates marketplace\n.\n\n\nIf you're migrating data to Railway from Fly, you can follow these steps:\n\n\n\n\nProvision a new database by right clicking on the dashboard canvas and selecting Postgres.\n\n\nExport your data from Flyio\n\n\n\n\nUse \nflyctl\n to connect to your Flyio Postgres instance\n\n\n\n\nfly postgres connect -a <postgres-app-name>\n\n\n\n\n\n\nUse \npg_dump\n to export your database\n\n\n\n\npg_dump -Fc --no-acl --no-owner -h localhost -p 5432 -U <your-db-username> -d <your-db-name> -f flyio_db_backup.dump\n\n\n\n\n\n\nUse \npg_restore\n to connect to your Railway database and restore the data from the dump.\n\n\n\n\npg_restore -U <username> -h <host> -p <port> -W -F t -d <db_name> <dump_file_name>\n\n\n\n\n\n\n\n\n\n\n\n\nFor detailed instructions, check out \nthis comprehensive tutorial on migrating PostgreSQL data between services.\n\n\nOnce the migration is complete, update the \nDATABASE_URL\n environment variable in your Railway app to point to the new PostgreSQL database and redeploy.\n\n\n4. Replicas & Multi-region deployments\n\n\nIn this \nFly.io app\n, the setting \nmin_machines_running=2\n ensures that at least \ntwo instances\n of the service remain active. On Railway import, we automatically translate this configuration to ensure that two \nservice instances\n are running without any extra setup.\n\n\n\n\nIf your app needs to use multi-region deployments, you can leverage Railwayâ€™s \nmulti-region replicas\n.\n\n\nEnable this in the \nSettings\n section of your Railway service to keep your app close to users worldwide.\n\n\nNote:\n Multi-region replicas is currently available to Pro users.\n\n\nAnd thatâ€™s it. Thatâ€™s all you need to migrate your app from Flyio to Railway.\nPrev\n \nMigrate from Render\nNext\n \nMigrate from Vercel\nEdit this file on GitHub\nOn This Page\nMigration Steps\n1. Set Up a Railway Project\n2. Deploy the App\nAdding Environment Variables on Railway:\n3. Database Migration\n4. Replicas & Multi-region deployments"
  },
  {
    "url": "https://docs.railway.app/migration/migrate-from-render",
    "title": "Migrate from Render to Railway | Railway Docs",
    "content": "Migrate from Render to Railway\nThis guide walks you through the steps needed to seamlessly migrate your app and data from Render to Railway.\n\n\nWith features like instant deployments, CI/CD integrations, private networking, observability, and effortless scaling, Railway helps developers focus on building rather than managing infrastructure.\n\n\nRailway boasts of a superior and intuitive user experience that makes deploying complex workloads easy to configure and manage.\n\n\nRailway offers:\n\n\n\n\nBroad Language and Framework Support\n: Deploy apps in \nany language or framework\n.\n\n\nFlexible Deployment Options\n: Use GitHub, Dockerfiles, Docker images from supported registries (Docker Hub, GitHub, RedHat, GitLab, Microsoft), or local deployments via the Railway CLI.\n\n\nIntegrated Tools\n: Simplify environment variable management, CI/CD, observability, and service scaling.\n\n\nNetworking Features:\n Public and private networking.\n\n\nBest in Class Support:\n Very active community on \nDiscord\n and our \nCentral Station\n.\n\n\n\n\n..and so much more. Want to see for yourself? \nTry Railway for a spin today!\n\n\nMigration Steps\n\n\nIn this guide, we will migrate a Go (Beego) app with a Postgres database from Render to Railway.\n\n\nHereâ€™s the link to the app. A simple chat app that have the options of Long polling and Web socket â€” \nhttps://github.com/unicodeveloper/beego-WebIM\n\n\n1. Set Up a Railway Project\n\n\nNavigate to \nRailway's Project Creation Page\n.\n\n\nSelect the \nDeploy from GitHub Repo\n option and connect your repository. If your Railway account isnâ€™t linked to GitHub yet, youâ€™ll be prompted to do so.\n\n\n\n\n2. Deploy the App\n\n\nRailway automatically detects a \nrender.yaml\n file in your repository and provisions the corresponding services, including databases, web (both public and private), crons, and workers.\n\n\nIf environment variables are defined in your \nrender.yaml\n, Railway will import them automatically to the appropriate services. If they are not defined, you can manually migrate them by following these steps:\n\n\nOn Render\n:\n\n\n\n\nGo to the \nEnvironment Variables\n page of your service.\n\n\nCopy all the variables and their values.\n\n\n\n\nOn Railway\n:\n\n\n\n\nOpen the \nVariables\n section for the relevant service.\n\n\nSwitch to the \nRaw Editor\n and paste the copied environment variables.\n\n\nDeploy the changes to apply the configuration.\n\n\n\n\n\n\nRailway will deploy both the Go app as a service and the database, as shown in the image above. You can monitor the service building and deploying in the \nProject Canvas\n.\n\n\n3. Database Migration\n\n\nRailway supports a variety of databases, including \nPostgreSQL\n, \nMongoDB\n, \nMySQL\n, and \nRedis\n, allowing you to deploy the one that best fits your application needs.\n\n\nWhen a \nrender.yaml\n file includes a \ndatabases\n section, Railway will automatically provision a \nPostgreSQL database\n for your app. If you're migrating data to Railway, you can follow these steps:\n\n\n\n\nExport your database from Render using tools like \npg_dump\n.\n\n\nImport the data into Railway using \npsql\n.\n\n\n\n\nFor detailed instructions, check out \nthis comprehensive tutorial on migrating PostgreSQL data between services.\n\n\nOnce the migration is complete, update the \nDATABASE_URL\n environment variable in your Railway app to point to the new PostgreSQL database.\n\n\n4. Multi-region deployments\n\n\nIf your app needs to use multi-region deployments, you can leverage Railwayâ€™s \nmulti-region replicas\n.\n\n\nEnable this in the \nSettings\n section of your Railway service to keep your app close to users worldwide.\n\n\nNote:\n Multi-region replicas is currently available to Pro users.\n\n\n\n\nAnd thatâ€™s it. Thatâ€™s all you need to migrate your app from Render to Railway.\nPrev\n \nCompare to DigitalOcean\nNext\n \nMigrate from Fly\nEdit this file on GitHub\nOn This Page\nMigration Steps\n1. Set Up a Railway Project\n2. Deploy the App\n3. Database Migration\n4. Multi-region deployments"
  },
  {
    "url": "https://docs.railway.app/migration/migrate-from-vercel",
    "title": "Migrate from Vercel to Railway | Railway Docs",
    "content": "Migrate from Vercel to Railway\nThis guide demonstrates how to transition your application from Vercel to Railway's developer-centric platform. Whether you're running a simple static site or a complex full-stack application, Railway streamlines your deployment workflow.\n\n\nWith features like instant rollbacks, integrated observability, and seamless environment management, Railway empowers developers to focus on building great applications rather than managing infrastructure.\n\n\nRailway offers -\n\n\n\n\n\n\nNext.js Optimization\n: Built-in support for all Next.js features including ISR, SSR, and API routes\n\n\n\n\n\n\nZero Config Deployments\n: Automatic framework detection and build optimization\n\n\n\n\n\n\nEnhanced Development Flow\n: Local development with production parity\n\n\n\n\n\n\nCollaborative Features\n: Team management, deployment protection, and role-based access\n\n\n\n\n\n\nPriority Support\n: Dedicated support for Railway users\n\n\n\n\n\n\nMigration Steps\n\n\nLet's walk through migrating a Next.js application to Railway. For this guide, we'll use a sample e-commerce app that showcases common Next.js features and configurations.\n\n\nDeploying Your Application\n\n\nTo get started deploying our NextJS app, we will first make a new \nproject\n.\n\n\n\n\nOpen up the \ndashboard\n â†’ Click \nNew Project\n.\n\n\nChoose the \nGitHub repo\n option.\n\n\n\n\n\n\nRailway requires a valid GitHub account to be linked. If your Railway account isn't associated with one, you will be prompted to link it.\n\n\n\n\nSearch for your GitHub project and click on it.\n\n\n\n\n\n\n\n\n\n\nChoose either \nDeploy Now\n or \nAdd variables\n.\n\n\nDeploy Now\n will immediately start to build and deploy your selected repo.\n\n\nAdd Variables\n will bring you to your service and ask you to add variables, when done you will need to click the \nDeploy\n button at the top of your canvas to initiate the first deployment.\n\n\nFor brevity we will choose \nDeploy Now\n.\n\n\n\n\n\n\n\n\nWhen you click \nDeploy Now\n, Railway will create a new project for you and kick off an initial deploy after the project is created.\n\n\nOnce the project is created you will land on your \nProject Canvas\n.\n\n\n\n\nFrom here Railway will automatically -\n\n\n\n\n\n\nDetect your Next.js configuration\n\n\n\n\n\n\nConfigure the appropriate Node.js version\n\n\n\n\n\n\nBuild your application\n\n\n\n\n\n\nRun your application\n\n\n\n\n\n\nEnvironment Configuration\n\n\nNext.js applications often rely on environment variables for API keys, database connections, and feature flags. Here's how to transfer them -\n\n\nFrom Vercel -\n\n\n\n\n\n\nVisit your Vercel project settings\n\n\n\n\n\n\nNavigate to the Environment Variables tab\n\n\n\n\n\n\nExport your variables (you can copy them directly)\n\n\n\n\n\n\nTo Railway -\n\n\n\n\n\n\nSelect your service in the Project Canvas\n\n\n\n\n\n\nOpen the Variables tab\n\n\n\n\n\n\nUse the Raw Editor for bulk variable import\n\n\n\n\n\n\nClick Deploy to apply changes\n\n\n\n\n\n\nDomain Configuration\n\n\nRailway makes it simple to set up custom domains or use our provided domains -\n\n\n\n\n\n\nOpen your service's Settings\n\n\n\n\n\n\nNavigate to the Public Networking section\n\n\n\n\n\n\nChoose between:\n\n\n\n\n\n\nGenerating a Railway service domain\n\n\n\n\n\n\nAdding your custom domain\n\n\n\n\n\n\n\n\n\n\nFollow the DNS configuration steps if using a custom domain\n\n\n\n\n\n\nDeployment Verification\n\n\nBefore finalizing your migration:\n\n\n\n\n\n\nCheck your application's core functionality\n\n\n\n\n\n\nVerify environment variables are properly set\n\n\n\n\n\n\nTest dynamic routes and API endpoints\n\n\n\n\n\n\nConfirm image optimization is working\n\n\n\n\n\n\nMonitor build and runtime logs\n\n\n\n\n\n\nRailway's integrated observability helps you catch any issues early in the migration process.\n\n\nLocal Development\n\n\nRailway makes local development seamless with your production environment:\n\n\n\n\n\n\nInstall the Railway CLI: \nnpm i -g @railway/cli\n\n\n\n\n\n\nRun \nrailway link\n to connect to your project\n\n\n\n\n\n\nUse \nrailway run\n to start your app locally with production variables\n\n\n\n\n\n\nThis ensures development/production parity and helps catch issues before they reach production.\n\n\nThat's all it takes to move your Next.js application to Railway! Need help? Our \nteam and community\n are always ready to assist.\n\n\nNeed more information on how we compare to Vercel? Check out our \ncomparison page\n.\nPrev\n \nMigrate from Fly\nNext\n \nMigrate from DigitalOcean\nEdit this file on GitHub\nOn This Page\nMigration Steps\nDeploying Your Application\nEnvironment Configuration\nDomain Configuration\nDeployment Verification\nLocal Development"
  },
  {
    "url": "https://docs.railway.app/overview/about-railway",
    "title": "About Railway | Railway Docs",
    "content": "About Railway\nRailway is a deployment platform designed to streamline the software development life-cycle, starting with instant deployments and effortless scale, extending to CI/CD integrations and built-in observability.\n\n\nDeploying on Railway\n\n\nPoint Railway to your deployment source and let the platform handle the rest.\n\n\nFlexible Deployment Sources\n\n\n\n\nCode Repositories\n: With or without Dockerfiles.  Railway will build an \nOCI compliant image\n based on what you provide.\n\n\nDocker Images\n: Directly from Docker Hub, GitHub Container Registry, GitLab Container Registry, Microsoft Container Registry, or Quay.io.  We support public and private image registries.\n\n\n\n\nHassle-Free Setup\n\n\n\n\nSane Defaults\n: Out of the box, your project is deployed with sane defaults to get you up and running as fast as possible.\n\n\nConfiguration Tuning\n: When you're ready, there are plenty of knobs and switches to optimize as needed.\n\n\n\n\nDevelopment Lifecycle\n\n\nSoftware development extends far beyond code deployment.  Railway's feature set is tailor-made, and continuously evolving, to provide the best developer experience we can imagine.\n\n\nConfiguration Management\n\n\n\n\nVariables & Secrets\n: Easily manage configuration values and sensitive data with variable management tools.\n\n\n\n\nEnvironment and Workflow\n\n\n\n\nEnvironment Management\n: Create both static and ephemeral environments to create workflows that complement your processes.\n\n\nOrchestration & Tooling\n: Build Railway into any workflow using our CLI or API.\n\n\n\n\nDeployment Monitoring\n\n\n\n\nObservability\n: Keep a pulse on your deployments with Railway's built-in observability tools.\n\n\n\n\nOperational Model\n\n\nRailway operates with an emphasis on reliability and transparency. We utilize a combination of alerting tools, internal systems, and operational procedures to maintain high uptime.  Read more about product philosophy and maturity \nhere\n.\n\n\nBook a Demo\n\n\nLooking to adopt Railway for your business?  We'd love to chat!  \nClick here to book some time with us\n.\nPrev\n \nRailway Metal\nNext\n \nThe Basics\nEdit this file on GitHub\nOn This Page\nDeploying on Railway\nFlexible Deployment Sources\nHassle-Free Setup\nDevelopment Lifecycle\nConfiguration Management\nEnvironment and Workflow\nDeployment Monitoring\nOperational Model\nBook a Demo"
  },
  {
    "url": "https://docs.railway.app/overview/advanced-concepts",
    "title": "Advanced Usage | Railway Docs",
    "content": "Advanced Usage\nThis document outlines the more advanced concepts of Railway.  It covers things like build and deploy options, networking, integrations, and observability.\n\n\nBuild and Deploy Options\n\n\nOut of the box, many defaults are applied to builds and deployments.  However, there are several ways to tailor things to your project spec.\n\n\nBuild Options\n\n\nRailway uses \nNixpacks\n to build and deploy your code with zero configuration.  When your needs require adjustments to the defaults, we make it easy to configure things like install, build, and start commands.\n\n\nDeploy Options\n\n\nDeployments are created with some default options that can be overridden.  Some of the options available are -\n\n\n\n\nReplicas\n:  By default, your deployment will go out with a single instance.  With replicas, you have the ability to scale up your deployment instances.\n\n\nDeployment Region\n: Deployments by default are pushed to your \npreferred region\n.\n\n\nScheduled Executions\n:  Your deployment will be run once by default.  If the service is intended to be a scheduled task of sorts, you can create a cron schedule.\n\n\nApp Sleep\n:  Services are serverful and always-on.  You can control this behavior, to spin down resources when they're not being used, by enabling App Sleep.\n\n\n\n\nNetworking\n\n\nNetworking can be tricky and time-consuming. We wanted to provide the best-in-class experience when it came to wiring things up.  There are two basic ways we accomplish this.\n\n\nPrivate Networking\n\n\nPrivate Networking is a feature within Railway that will open network communication through a IPv6 wireguard mesh only accessible to your Railway services within a project.\n\n\nAll projects have private networking enabled and services are assigned a DNS name under the \nrailway.internal\n domain. This DNS name resolves to the internal IPv6 address of the services in a project.\n\n\nRailway-Provided Domains\n\n\nWith the click of a button, Railway will expose your service to the internet and provide you with a domain.  In order to make this work, you must configure your application appropriately to ensure we know the port it is listening on.  Instructions for how to do this can be found in the \nPublic Networking guide\n.\n\n\nCustom Domains\n\n\nIf you have a custom domain, you can easily add it to your Railway service.\n\n\nIntegration Tools\n\n\nA \nCLI\n and an \nAPI\n are available to wire your Railway projects into any workflow.\n\n\nCLI\n\n\nThe Railway Command Line Interface (CLI) lets you interact with your Railway project from the command line, allowing you to do things like:\n\n\n\n\nTrigger deployments programmatically.\n\n\nRun services locally using environment variables from your Railway project.\n\n\nCreate new Railway projects from the Terminal.\n\n\nDeploy \ntemplates\n.\n\n\n\n\nPublic API\n\n\nThe Railway \npublic API\n is built with GraphQL and is the same API that powers the Railway dashboard.  Similar to the CLI, you can interact with your Railway project programmatically by communicating with the API.\n\n\nEnvironments\n\n\nRailway environments give you an isolated instance of all databases and services in a project. You can use them to\n\n\n\n\nHave development environments for each team member that are identical to the production environment\n\n\nHave separate staging and production environments\n\n\n\n\nWithin a service and environment, you can specify which branch to auto-deploy to that environment when a change is merged.\n\n\nObservability\n\n\nAny build or deployment logs emitted to standard output or standard error \n( eg. console.log(...))\n are captured by Railway so you can view or search for it later.\n\n\nService Logs\n\n\nLogs for a specific service deployment are available from a service's view in your project, useful when debugging build or deployment failures.\n\n\nCentralized Logs\n\n\nLogs for all of the services in a project can be viewed together in our Observability tool within a project. This is useful for debugging more general problems that may span multiple services.\nPrev\n \nBest Practices\nNext\n \nFoundations\nEdit this file on GitHub\nOn This Page\nBuild and Deploy Options\nBuild Options\nDeploy Options\nNetworking\nPrivate Networking\nRailway-Provided Domains\nCustom Domains\nIntegration Tools\nCLI\nPublic API\nEnvironments\nObservability\nService Logs\nCentralized Logs"
  },
  {
    "url": "https://docs.railway.app/overview/best-practices",
    "title": "Best Practices | Railway Docs",
    "content": "Best Practices\n\n\nRailway is a highly versatile platform, offering various ways to use it, though some may be less optimal than others for most use cases. These topics aim to help you maximize both your potential and the platform's capabilities.\n\n\nUse Private Networking When Possible\n\n\nPrivate networking\n allows services within a \nproject\n to communicate internally without the need to expose them \npublicly\n, while also providing faster communication and increased throughput.\n\n\nWhen configuring environment variables in your service to reference domains or URLs of other services, ensure you use the private versions of these variables, such as \nRAILWAY_PRIVATE_DOMAIN\n or \nDATABASE_URL\n.\n\n\nUsing the private network enables communication between services within the same project without incurring service-to-service egress costs, which is particularly beneficial when interacting with databases or other internal services.\n\n\n\n\nScreenshot showing the use of the \nRAILWAY_PRIVATE_DOMAIN\n \nvariable\n being used via \nreferencing\n.\n\n\nDeploying Related Services Into the Same Project\n\n\nIn Railway, a \nproject\n serves as a container for organizing infrastructure. It can encompass an application stack, a group of \nservices\n, or even multiple service groups.\n\n\nIf you're about to head back to the \ndashboard\n to deploy another service like a database, there's a quicker way - look for the \nCreate\n button at the top right of the Project canvas. This shortcut allows you to add new services directly to your current project.\n\n\nThere are a few key advantages of keeping related services within the same project -\n\n\n\n\n\n\nPrivate networking\n - The private network is scoped to a single environment within a project, having all related services within a single project will allow you to use private networking for faster networking along with no egress fees for service-to-service communication.\n\n\n\n\n\n\nProject clutter\n - Deploying a new service or database as an entire project will quickly become overwhelming and clutter your dashboard.\n\n\n\n\n\n\nVariable management\n - Variables can be referenced between services within a project, reducing redundancy and making it easier to manage instead of having to manually copy variables between services.\n\n\n\n\n\n\n\n\nScreenshot showing related services within a project and their connection links.\n\n\nUse Reference Variables Where Applicable\n\n\nReference variables\n allow you to dynamically reference another variable, either from a variable set on the current \nservice\n or from another service in the same \nproject\n.\n\n\nRather than manually copying, pasting, and hard-coding variables like a public domain or those from another service, you can use reference variables to build them dynamically. Example \nVITE_BACKEND_HOST=${{Backend.RAILWAY_PUBLIC_DOMAIN}}\n\n\nThis approach is better than hard-coding variables, as it keeps your variable values in sync. Change your \npublic domain\n? The variable updates. Change your \nTCP proxy\n? The variable updates.\n\n\n\n\nScreenshot showing a reference variable used to reference the Backend's domain.\nPrev\n \nThe Basics\nNext\n \nAdvanced Concepts\nEdit this file on GitHub\nOn This Page\nUse Private Networking When Possible\nDeploying Related Services Into the Same Project\nUse Reference Variables Where Applicable"
  },
  {
    "url": "https://docs.railway.app/overview/the-basics",
    "title": "The Basics | Railway Docs",
    "content": "The Basics\nThis document outlines the core concepts of Railway, providing foundational knowledge of the basic building blocks you'll work with in the platform.\n\n\nIn a Nutshell\n\n\n\n\nDashboard\n - Main entrypoint for all projects under your account.\n\n\nProject\n - A collection of services under the same network.\n\n\n\n\nProject Settings\n - Contains all project-level settings.\n\n\n\n\n\n\nService\n - A target for a deployment source (e.g. Web Application).\n\n\n\n\nService Variables\n - A collection of configurations and secrets.\n\n\nBackups\n - A collection of backups for a service.\n\n\nService Metrics\n - Rundown of metrics for a service.\n\n\nService Settings\n - Contains all service-level settings.\n\n\n\n\n\n\nDeployment\n - Built and deliverable unit of a service.\n\n\nVolumes\n - Persistent storage solution for services.\n\n\n\n\nVolume Metrics\n - Rundown of metrics for volumes (e.g. disk usage over time).\n\n\nVolume Settings\n - Contains all volume-level settings.\n\n\n\n\n\n\n\n\nDashboard / Projects\n\n\nYour main entrypoint to Railway where all your \nprojects\n are shown in the order they where last opened.\n\n\nProjects contain your \nservices\n and \nenvironments\n.\n\n\n\n\nProject / Project Canvas\n\n\nA project represents a capsule for composing infrastructure in Railway.  You can think of a project as an application stack, a service group, or even a collection of service groups.\n\n\nServices within a project are automatically joined to a \nprivate network\n scoped to that project.\n\n\n\n\nProject Settings\n\n\nThis page contains all the project level settings.\n\n\n\n\nSome of the most commonly used project settings are -\n\n\n\n\n\n\nTransfer Project\n - Transfer your project between workspaces.\n\n\n\n\n\n\nEnvironments\n - Manage various settings regarding environments.\n\n\n\n\n\n\nMembers\n - Add or remove members to collaborate on your project.\n\n\n\n\n\n\nDanger - Remove individual \nservices\n or delete the entire project.\n\n\n\n\n\n\nServices\n\n\nA Railway service is a deployment target for your deployment source. Deployment sources can be \ncode repositories\n or \nDocker Images\n. Once you create a service and choose a source, Railway will analyze the source, build a Docker image (if the source is a code repository), and deploy it to the service.\n\n\n\n\nOut of the box, your service is deployed with a set of default configurations which can be overridden as needed.\n\n\nService Variables\n\n\nService \nVariables\n provide a powerful way to manage configuration and secrets across services in Railway.\n\n\nYou can configure variables scoped to services. These variables are specific to each service and are not shared across the project by default.\n\n\nIf you want to access variables from this service in another service within the same project, you need to utilize a \nReference Variable\n.\n\n\n\n\nBackups\n\n\nIf your service has a \nvolume\n attached, this is where you can manage backups.\n\n\nBackups are incremental and Copy-on-Write, we only charge for the data exclusive to them, that aren't from other snapshots or the volume itself.\n\n\n\n\nFrom here you can perform the following actions -\n\n\n\n\n\n\nCreate a backup - Manually create a backup of the volume with a press of a button.\n\n\n\n\n\n\nDelete a backup - Remove a backup from the list via the backup's 3-dot menu.\n\n\n\n\n\n\nLock a backup - Prevent a backup from being deleted via the backup's 3-dot menu.\n\n\n\n\n\n\nRestore a backup\n - Click the \nRestore\n button on the backup.\n\n\n\n\n\n\nModify the backup schedule - Click the \nEdit schedule\n button on the header to make changes to the schedule.\n\n\n\n\n\n\nService Metrics\n\n\nService \nMetrics\n provide an essential overview of CPU, memory, and network usage for a given service.\n\n\n\n\nService Settings\n\n\nThis tab contains all the service level settings.\n\n\n\n\nSome of the most commonly used service settings are -\n\n\n\n\n\n\nSource\n - Here you can configure the deployment source, which can be either a GitHub repository with a specific branch or an image with optional credentials.\n\n\n\n\n\n\nNetworking\n - Generate a Railway-provided domain or add your own custom one.\n\n\n\n\n\n\nCustom Build Command - Here you can configure a custom build command if you need to overwrite the default, only applicable with \nNixpacks\n based builds.\n\n\n\n\n\n\nCustom Start Command - Here, you can configure a custom start command if you need to overwrite the default.\n\n\n\n\n\n\nDeployments\n\n\nDeployments\n involve building and delivering your \nService\n.\n\n\n\n\nVolumes\n\n\nVolumes\n are a feature that allows services on Railway to \nmaintain persistent data\n.\n\n\n\n\nVolume Metrics\n\n\nVolume Metrics show the amount of data stored in the volume and its maximum capacity.\n\n\n\n\nVolume Settings\n\n\nThis tab contains all the volume centric settings.\n\n\n\n\nSome of the most commonly used volume settings are -\n\n\n\n\n\n\nMount path - The absolute path where the volume will be mounted within the deployed service.\n\n\n\n\n\n\nVolume Size - Displays the current volume capacity and offers the option to expand it if your plan permits.\n\n\n\n\n\n\nWipe Volume - This action wipes all data in the volume and then redeploys the connected service.\n\n\n\n\n\n\nWhat Next?\n\n\nIf you've read enough for now and are ready to get started, we suggest checking out either of these two resources next -\n\n\n\n\n\n\nQuick Start guide\n to deploy a To Do app from a \ntemplate\n.\n\n\n\n\n\n\nGuides section\n to dive into how things work.\n\n\n\n\n\n\nIf you want to go deeper, click the Next button below to head to the next section - \nAdvanced Concepts\n.\nPrev\n \nAbout Railway\nNext\n \nBest Practices\nEdit this file on GitHub\nOn This Page\nIn a Nutshell\nDashboard / Projects\nProject / Project Canvas\nProject Settings\nServices\nService Variables\nBackups\nService Metrics\nService Settings\nDeployments\nVolumes\nVolume Metrics\nVolume Settings\nWhat Next?"
  },
  {
    "url": "https://docs.railway.app/quick-start",
    "title": "Quick Start Tutorial | Railway Docs",
    "content": "Quick Start Tutorial\nRailway is a deployment platform that lets you provision infrastructure, develop locally with that infrastructure, and deploy to the cloud or simply run ready-made software from our template marketplace.\n\n\nIn this guide we will cover two different topics to get you quickly started with the platform -\n\n\n\n\n\n\nDeploying your project\n - Bring your code and let Railway handle the rest.\n\n\nOption 1\n  - Deploying from \nGitHub\n.\n\n\nOption 2\n - Deploying with the \nCLI\n.\n\n\nOption 3\n - Deploying from a \nDocker Image\n.\n\n\n\n\n\n\nDeploying a \ntemplate\n - Ideal for deploying pre-configured software with minimal effort.\n\n\n\n\n\n\nTo demonstrate deploying directly from a GitHub repository through Railway's dashboard, we'll be using a basic \nNextJS app\n that was prepared for this guide.\n\n\nFor the template deployment, we'll use the \nUmami template\n from our \ntemplate marketplace\n.\n\n\nDeploying Your Project - From GitHub\n\n\nIf this is your first time deploying code on Railway, we recommend \nforking\n the previously mentioned \nNextJS app\n's repository so that you can follow along.\n\n\nTo get started deploying our NextJS app, we will first make a new \nproject\n.\n\n\n\n\n\n\nOpen up the \ndashboard\n â†’ Click \nNew Project\n.\n\n\n\n\n\n\nChoose the \nGitHub repo\n option.\n\n\n\n\n\n\n\n\nRailway requires a valid GitHub account to be linked. If your Railway account isn't associated with one, you will be prompted to link it.\n\n\n\n\nSearch for your GitHub project and click on it.\n\n\n\n\n\n\n\n\n\n\nChoose either \nDeploy Now\n or \nAdd variables\n.\n\n\nDeploy Now\n will immediately start to build and deploy your selected repo.\n\n\nAdd Variables\n will bring you to your service and ask you to add variables, when done you will need to click the \nDeploy\n button at the top of your canvas to initiate the first deployment.\n\n\nFor brevity we will choose \nDeploy Now\n.\n\n\n\n\n\n\n\n\nWhen you click \nDeploy Now\n, Railway will create a new project for you and kick off an initial deploy after the project is created.\n\n\nOnce the project is created you will land on your \nProject Canvas\n.\n\n\nDeploying Your Project - With the CLI\n\n\nAs with the \nDeploy from GitHub guide\n, if you're deploying code with the CLI for the first time, it's recommended to \nfork\n the \nNextJS app\n's repository to follow along. Since we'll be deploying local code, you'll also need to \nclone\n the forked repository.\n\n\nThe CLI can create a new project entirely from the command line, we will use it to scaffold our project.\n\n\n\n\n\n\nOpen up a command prompt inside of our local project.\n\n\n\n\n\n\nRun \nrailway init\n\n\nThis will create a new empty project with the name we provided, which will be used for any subsequent commands.\n\n\n\n\n\n\n\n\nDeploying your code is now only a single command away.\n\n\n\n\n\n\nRun \nrailway up\n\n\nThe CLI will now scan our project files, compress them, and upload them to Railway's backend for deployment.\n\n\n\n\n\n\n\n\nYou can now run \nrailway open\n and you will taken to your \nProject Canvas\n.\n\n\nDeploying Your Project - From a Docker Image\n\n\nRailway supports deploying pre-built Docker images from the following registries:\n\n\n\n\n\n\nDocker Hub\n\n\n\n\n\n\nGitHub Container Registry\n\n\n\n\n\n\nRedHat Container Registry\n\n\n\n\n\n\nGitLab Container Registry\n\n\n\n\n\n\nTo get started deploying a Docker image, we will first make a new \nproject\n.\n\n\n\n\n\n\nOpen up the \ndashboard\n â†’ Click \nNew Project\n.\n\n\n\n\n\n\nChoose the \nEmpty project\n option.\n\n\n\n\n\n\n\n\nAfter the project is created, you will land on the \nProject Canvas\n. A panel will appear prompting you to Add a Service.\n\n\n\n\n\n\nClick \nAdd a Service\n and select the \nDocker Image\n option from the modal that pops up.\n\n\n\n\n\n\n\n\nIn the \nImage name\n field, enter the name of the Docker image, e.g, \nblueriver/nextjs\n and press Enter.\n\n\n\n\n\n\nIf you're using a registry other than Docker Hub (such as GitHub, GitLab, Quay), you need to provide the full Docker image URL from the respective registry.\n\n\n\n\n\n\nPress Enter and click \nDeploy\n.\n\n\n\n\nRailway will now provision a new service for your project based on the specified Docker image.\n\n\nAnd that's it! ðŸŽ‰ Your project is now ready for use.\n\n\nNote:\n Deploying from a \nprivate Docker registry is available on the Pro plan\n.\n\n\nThe Canvas\n\n\nWhether you deploy your project through the dashboard with GitHub or locally using the CLI, you'll ultimately arrive at your project canvas.\n\n\n\n\nThis is your \nmission control\n. Your project's infrastructure, \nenvironments\n, and \ndeployments\n are all\ncontrolled from here.\n\n\nOnce the initial deployment is complete, your app is ready to go. If applicable, generate a domain by clicking \nGenerate Domain\n within the \nservice settings\n panel.\n\n\nAdditional Information -\n\n\nIf anything fails during this time, you can explore your \nbuild or deploy logs\n for clues. A helpful tip is to scroll through the entire log; important details are often missed, and the actual error is rarely at the bottom!\n\n\nIf you're stuck don't hesitate to open a \nHelp Thread\n.\n\n\nDeploying a Template\n\n\nRailway's \ntemplate marketplace\n offers over 650+ unique templates that have been created both by the community and Railway!\n\n\nDeploying a template is not too dissimilar to deploying a GitHub repo -\n\n\n\n\n\n\nOpen up the \ndashboard\n â†’ Click \nNew Project\n.\n\n\n\n\n\n\nChoose \nDeploy a template\n.\n\n\n\n\n\n\n\n\n\n\n\n\nSearch for your desired template.\n\n\nHint: If your desired template isn't found feel free to \nreach out to the community\n.\n\n\n\n\n\n\nClick on the template you want to deploy.\n\n\n\n\n\n\n\n\nHint: Generally it's best to choose the template with a combined higher deployment and success count.\n\n\n\n\n\n\nFill out any needed information that the template may require.\n\n\nIn the case of our Umami template, we don't need to provide any extra information.\n\n\n\n\n\n\n\n\n\n\nClick \nDeploy\n.\n\n\n\n\nRailway will now provision a new project with all services and configurations that were defined in the template.\n\n\nThat's it, deploying a template is as easy as a few clicks!\n\n\n\n\nClosing\n\n\nRailway aims to be the simplest way to develop, deploy, and diagnose issues with your application.\n\n\nAs your Project scales, Railway scales with you by supporting multiple Teams, vertical scaling, and horizontal scaling; leaving you to focus on what matters: your code.\n\n\nHappy Building!\n\n\nWhat to Explore Next\n\n\n\n\n\n\nEnvironments\n - Railway lets you create parallel, identical environments for PRs/testing.\n\n\n\n\n\n\nObservability Dashboard\n - Railway's built-in observability dashboard offers a customizable view of metrics, logs, and usage in one place.\n\n\n\n\n\n\nProject Members\n - Adding members to your projects is as easy as sending them an invite link.\n\n\n\n\n\n\nStaged Changes\n - When you make changes to your Railway project, such as adding or removing components and configurations, these updates will be gathered into a changeset for you to review and apply.\n\n\n\n\n\n\nJoin the Community\n\n\nChat with Railway members, ask questions, and hang out in our \nDiscord community\n with fellow builders! We'd love to have you!\nPrev\n \nHome\nNext\n \nRailway Metal\nEdit this file on GitHub\nOn This Page\nDeploying Your Project - From GitHub\nDeploying Your Project - With the CLI\nDeploying Your Project - From a Docker Image\nThe Canvas\nDeploying a Template\nClosing\nWhat to Explore Next\nJoin the Community"
  },
  {
    "url": "https://docs.railway.app/railway-metal",
    "title": "Railway Metal | Railway Docs",
    "content": "Railway Metal\nRailway Metal is the next generation of Railway's underlying infrastructure.\nIt is built on hardware that we own and operate in datacenters around the world.\n\n\n\n\nLearn more about how we built it in our blog post \nSo You Want to Build Your Own Data Center\n.\n\n\nWhy?\n\n\nWe are making this move as part of our commitment to providing best-in-class\ninfrastructure for our users. This change enables us to improve our platform's\nperformance, unlock additional features, increase reliability, and make\nRailway more cost-effective for all users.\n\n\nWith Railway Metal, you can expect the following benefits:\n\n\n\n\n\n\nRegions for Trial & Hobby plan users\n: Railway Metal will be available to\nall users, including Trial & Hobby Plan users. Trial & Hobby plan users will\nbe able to deploy services on all four Railway Metal regions in the US,\nEurope, and Southeast Asia.\n\n\n\n\n\n\nCheaper Pricing\n: Running our own hardware lets us reduce prices. Once\nRailway Metal is Generally Available, all users can expect to pay up to 50%\nless for Network Egress, and up to 40% less for Disk Usage.\n\n\n\n\n\n\nImproved Performance\n: Services on Railway will run faster. Our new CPUs\nare more powerful with higher core count and better performance per-core.\nVolume read/write performance will also be significantly faster as all\nof our disks are NVMe SSDs, which are faster than the disks we could offer\nbefore.\n\n\n\n\n\n\nEnhanced Reliability\n: With Railway Metal, we are able to manage the\nhardware, software, and networking stack end-to-end. This allows us to move\nfaster and fix problems more quickly. (For instance, before Railway Metal,\nincidents such as \na single host failure\n would often take us ~60 minutes to bring the host back up. With our own\nhardware, we can bring the host back up significantly faster.)\n\n\n\n\n\n\nImproved Networking\n: We connect directly to major internet providers and\nother cloud platforms worldwide, giving you faster connections in and out\nof Railway.\n\n\n\n\n\n\nHigher Available Resources\n: Railway Metal has greater capacity that we\nwill be increasing over time, allowing us to offer you more computing\nresources on-demand.\n\n\n\n\n\n\nUnlocks More Features\n: With our own hardware and networking stack, we\ncan power more advanced features that were not possible before, such as\nStatic Inbound IPs, Anycast Edge Network, High-Availability Volumes, etc.\n\n\n\n\n\n\nMetal Edge Network (Beta)\n\n\nRailway routes traffic through its own anycast Metal Edge network.\n\n\nYou can check if its enabled for your service in the Public Network section in the service settings tab.\n\n\n\n\nScreenshot showing a domain with the Metal Edge Network enabled\n\n\nBenefits include better routing, less latency, and underlying infrastructure improvements.\n\n\nRegions & Availability\n\n\nRailway Metal is available to all users, including Trial & Hobby Plan users.\n\n\nEach Railway Metal region is located in a datacenter that was chosen\nstrategically to provide the best possible performance and reliability.\n\n\nWe are in the process of expanding our Railway Metal regions, and we expect to\nhave all regions available by the end of Q1'2025 (by 31 March 2025).\n\n\nRailway Metal Region\nStatus\nUS West (California)\nðŸŸ¢ Active\nUS East (Virginia)\nðŸŸ¢ Active\nEurope West (Amsterdam)\nðŸŸ¢ Active\nSoutheast Asia (Singapore)\nðŸŸ¢ Active\n\n\nGradual Upgrade\n\n\nWe will gradually move services without a \nvolume\n\nto Railway Metal as we increase the pool of our hardware and its capabilities.\n\n\nWhen this happens, you may see a new deploy initiated by Railway in your service:\n\n\n\n\nBecause this is a new deploy of your latest Active deployment, the behaviour\nwill be the same as if you've manually issued a new deploy. As such, you may\nnotice that:\n\n\n\n\n\n\nThere may be a brief downtime during the upgrade. To prevent this, ensure\nyou have \nHealth Checks\n set up for your service\n\n\n\n\n\n\nAll ephemeral storage (such as \n/tmp\n, etc.) will be wiped. To prevent this,\nuse \nVolume\n to store data persistently. All storage is\nconsidered ephemeral unless they're on a Railway Volume\n\n\n\n\n\n\nNote that the above generally applies to deploying a new version of\nyour service. The upgrade to Railway Metal is irrelevant to the behaviour\nyou may run into above - they are the same as if you were to manually deploy\na new version of your service.\n\n\nFor services in \nUS West (Oregon)\n, Railway will not move your service to\nRailway Metal if your service \nreferences another service\n with a volume.\nThis is to prevent any cross-regional networking latency spikes for your\nservice. Refer to \nthis FAQ\n for more information.\n\n\nRollback\n\n\nIf you encounter any issues with your service after the upgrade, you can\nrollback to the previous version by clicking \nRollback\n button in the banner\nabove.\n\n\n\n\nManual rollback\n\n\nTo rollback manually, modify your service's \nSettings -> Deploy -> Regions\n\nand select regions without the \nMetal (New)\n tag.\n\n\n\n\nTimeline\n\n\nOur transition to Railway Metal will happen in phases. Here's what you can\nexpect:\n\n\nDate\nWhat's Happening\nStatus\nStarting December 26th, 2024\nAll new deploys on newly-created services without a \nvolume\n by Trial & Hobby users will use Railway Metal by default.\nðŸŸ¢\nStarting January 1st, 2025\nWe will be gradually upgrading services \nwithout a \nvolume\n to Railway Metal. You can learn more about the gradual upgrade \nhere\n.\nðŸŸ¢\nStarting January 31st, 2025\nAll new deploys on all services \nwithout a \nvolume\n by Trial & Hobby users will use Railway Metal by default.\nðŸŸ¢\nStarting February 14th, 2025\nAll new deploys on all services \nwithout a \nvolume\n by Pro & Enterprise users will use Railway Metal by default.\nðŸŸ¢\nStarting March 14th, 2025\nAll new deploys on services \nwith a \nvolume\n by Trial & Hobby users will use Railway Metal by default.\nðŸŸ¢\nStarting March 21st, 2025\nWe will begin migrating services to Railway metal for Hobby Users\nðŸŸ¢\nStarting March 28th, 2025\nAll new deploys on services \nwith a \nvolume\n by Pro & Enterprise users will use Railway Metal by default.\nðŸŸ¢\nStarting May 2nd, 2025\nWe will begin migrating services to Railway metal for Pro Users\nðŸŸ¢\nStarting June 6th, 2025\nWe will begin migrating services to Railway metal for Enterprise Users\nðŸŸ \n\n\nThe migration is aimed to be completed by the 4th of July, 2025.\n\n\nPricing Updates\n\n\nIf you migrate 80 percent of your workloads to Railway Metal, you'll benefit from significantly reduced costs:\n\n\n\n\nEgress Fees\n: Reduced by 50%, from $0.10/GB to $0.05/GB.\n\n\nDisk Storage\n: Reduced from $0.25/GB to $0.15/GB.\n\n\n\n\nThese pricing updates are automatically applied once 80 percent of your workloads are running on Railway Metal.\n\n\nFAQ\n\n\nIs this a free upgrade?\n\n\nYes.\n\n\nHow do I receive the upgrade sooner?\n\n\nGo to your service's \nSettings -> Deploy -> Regions\n, and select any region\nwith the \nMetal (New)\n tag.\n\n\n\n\nRefer to \nRegions & Availability\n to see the regions\navailable for Railway Metal.\n\n\nHow do I know if I'm on Railway Metal?\n\n\nTo check if your service is running on Railway Metal, go to your service's\n\nSettings -> Deploy -> Regions\n. If you are on Railway Metal, you will see a\n\nMetal (New)\n tag next to the region.\n\n\n\n\nIs Railway Metal stable?\n\n\nYes. We have been running a growing amount of deployments on it for the past\nseveral months. As of the time of this writing, there are ~40,000 deployments\non Railway Metal, and we have not seen any significant issues.\n\n\nIs there downtime if I upgrade?\n\n\nUpgrading to Railway Metal re-deploys your service. This may cause a brief\nperiod of downtime as your new deploy is being set up. You can set up\n\nHealth Checks\n to prevent this.\n\n\nWhat is the difference between Railway Metal and regions?\n\n\nRailway Metal refers to our own hardware and infrastructure. Regions refer to\nthe physical location of the datacenter where the hardware is located.\n\n\nI'm experiencing slow network performance after switching to US West (California) Railway Metal region. What should I do?\n\n\nYou may experience increased latency if your application is communicating with\nother services (such as databases) in \nUS West (Oregon)\n. This is caused by the\nphysical distance between Oregon (our current region) and California\n(Railway Metal region).\n\n\nWe recommend switching back to the \nUS West (Oregon)\n region if you are\nexperiencing increased latency after upgrading to \nUS West (California)\n.\nSee \nManual rollback\n for instructions.\n\n\nWill Railway stay on GCP?\n\n\nNo. We are migrating completely onto Railway managed hardware. For customers who would like Railway to deploy into their public cloud, you can contact sales via our \nAWS Marketplace listing.\n\n\nHelp! After migrating, why do I have increased latency?\n\n\nIt's likely that your database, or service with a volume, isn't migrated over to Metal. Stateful Metal is available starting March 2025. Users who migrate to a different region other than their stateful workload will see increased latency due to the additional physical distance from your service's region. Migrate when your desired region has stateful workloads available after March 2025.\n\n\nWhy did my costs increase when moving to Metal?\n\n\nAlthough not intended, Railway Metal, has a different metrics sampler than our legacy hardware. This means that metrics will be quicker to come in, this also meant that legacy was undercounting the amount of resources on the previous hardware. As a result, some metrics like CPU will increase, others, like RAM will usually decrease.\n\n\nHow do I opt-out?\n\n\nThere is no way to opt-out of Railway Metal. Please \nreach out to us\n\nif you have any concerns.\n\n\nHow do I get the new Pro plan?\n\n\nOn your invoice close date, if 80 percent of your usage costs come from Railway Metal instances, Railway waives all seat costs on the platform.\n\n\nGetting Help\n\n\nPlease reach out to us \non our Central Station\n if you run into any issues. You can also reach out to us over \nSlack\n if you are\na Pro or \nBusiness Class / Enterprise\n\ncustomer.\nPrev\n \nQuick Start\nNext\n \nAbout Railway\nEdit this file on GitHub\nOn This Page\nWhy?\nMetal Edge Network (Beta)\nRegions & Availability\nGradual Upgrade\nRollback\nManual rollback\nTimeline\nPricing Updates\nFAQ\nIs this a free upgrade?\nHow do I receive the upgrade sooner?\nHow do I know if I'm on Railway Metal?\nIs Railway Metal stable?\nIs there downtime if I upgrade?\nWhat is the difference between Railway Metal and regions?\nI'm experiencing slow network performance after switching to US West (California) Railway Metal region. What should I do?\nWill Railway stay on GCP?\nHelp! After migrating, why do I have increased latency?\nWhy did my costs increase when moving to Metal?\nHow do I opt-out?\nHow do I get the new Pro plan?\nGetting Help"
  },
  {
    "url": "https://docs.railway.app/reference/app-sleeping",
    "title": "Serverless | Railway Docs",
    "content": "Serverless\nNote: This feature is formerly called: App-Sleeping\n\n\nServerless allows you to increase the efficiency of resource utilization on Railway and may reduce the usage cost of a \nservice\n, by ensuring it is running only when necessary.\n\n\nHow it Works\n\n\nWhen Serverless is enabled for a service, Railway automatically detects inactivity based on outbound traffic.\n\n\nInactive Service Detection\n\n\nInactivity is based on the detection of any outbound packets, which could include network requests, database connections, or even NTP. If no packets are sent from the service for over 10 minutes, the service is considered inactive.\n\n\nSome things than can prevent a service from being put to sleep -\n\n\n\n\nKeeping active database connections open, such as a database connection pooler.\n\n\nFrameworks that report telemetry to their respective services, such as \nNext.js\n.\n\n\nMaking requests to other services in the same \nproject\n over the \nprivate network\n.\n\n\nMaking requests to other Railway services over the public internet.\n\n\nMaking requests to external services over the public internet.\n\n\nReceiving traffic from other services in the same project over the private network.\n\n\nReceiving traffic from other Railway services over the public internet.\n\n\nReceiving traffic from external services over the public internet.\n\n\n\n\nIt's important to note that the networking graph in the metrics tab only displays public internet traffic. If you're using a private network to communicate with other services, this traffic won't appear in the metrics tab. However, it's still counted as outbound traffic and will prevent the service from being put to sleep.\n\n\nWaking a Service Up\n\n\nA service is woken when it receives traffic from the internet or from another service in the same project through the \nprivate network\n.\n\n\nThe first request made to a slept service wakes it. It may take a small amount of time for the service to spin up again on the first request (commonly known as \"cold boot time\").\n\n\nCaveats\n\n\n\n\nThere will be a small delay in the response time of the first request sent to a slept service (commonly known as \"cold boot times\")\n\n\nFor Railway to put a service to sleep, a service must not send \noutbound\n traffic for at least 10 minutes. Outbound traffic can include telemetry, database connections, NTP, etc. Inbound traffic is excluded from considering when to sleep a service.\n\n\nEnabling Serverless will apply the setting across all \nReplicas\n\n\nSlept services still consume a slot on our infrastructure, enabling Serverless de-prioritizes your workload and in remote cases, may require a rebuild to re-live the service.\n\n\n\n\nSupport\n\n\nFor information on how to enable Serverless on your services refer to the \nhow to guide\n.\nPrev\n \nFunctions\nNext\n \nBuild and Start Commands\nEdit this file on GitHub\nOn This Page\nHow it Works\nInactive Service Detection\nWaking a Service Up\nCaveats\nSupport"
  },
  {
    "url": "https://docs.railway.app/reference/backups",
    "title": "Backups | Railway Docs",
    "content": "Backups\nThe backup feature enables data recovery for all content stored in \nvolumes\n. This includes both our database offerings and any other data stored within a volume, such as an SQLite database.\n\n\nHow it works\n\n\nWhen a \nvolume\n is mounted to a service, backups can be manually created, deleted and restored. And they can also be scheduled to run on a Daily / Weekly / Monthly schedule.\n\n\nBackup Schedules\n\n\nBackups can be scheduled to run on a daily, weekly or monthly basis. They will be kept for a number of days / months based on the schedule.\n\n\nYou can set the schedule in the service settings panel, under the Backups tab.\n\n\n\n\nDaily\n - Backed up every 24 hours, kept for 6 days\n\n\nWeekly\n - Backed up every 7 days, kept for 1 month\n\n\nMonthly\n - Backed up every 30 days, kept for 3 months\n\n\n\n\nYou can select multiple backup schedules for a single volume. These schedules can be modified at any time, and you can also manually trigger backups as needed.\n\n\nHow to restore a backup\n\n\nThe available backups for a volume are listed in the attached \nservice's\n Backups tab.\n\n\n\n\nTo restore a backup, first locate the backup you want to restore via its date stamp, then click the \nRestore\n button on the backup.\n\n\nNote:\n Depending on the size of the backup, this may take a few seconds to a few minutes to complete.\n\n\nOnce completed, we will \nstage the change\n for you to review, click the \nDetails\n button at the top of the \nproject canvas\n to view the changes.\n\n\nDuring this process, you will see a new \nvolume\n mounted to the same location as the original volume, its name will be the date stamp of the backup.\n\n\nThe previous volume will be retained but has been unmounted from the service, it will have the original volume name such as \nsilk-volume\n.\n\n\nNote:\n Restoring a backup will remove any newer backups you may have created after the backup you are restoring, you will still have access to backups older than the one you are restoring.\n\n\nIf everything looks good and you're ready to proceed, click the \nDeploy\n button to complete the restore.\n\n\nThe changes will be applied and your service will be redeployed.\n\n\nPricing\n\n\nBackups are incremental and Copy-on-Write, we only charge for the data exclusive to them, that aren't from other snapshots or the volume itself.\n\n\nYou are only billed for the incremental size of the backup at a rate per GB / minutely, and invoiced monthly. Backups follow the same pricing as Volumes. You can find \nspecific per-minute pricing here\n.\n\n\nCaveats\n\n\nBackups are a newer feature that is still under development. Here are some limitations of which we are currently aware:\n\n\n\n\nBackup incremental sizes are cached for a couple of hours when listed in the frontend, so they may show slightly stale data.\n\n\nWiping a volume deletes all backups.\n\n\nBackups can only be restored into the same project + environment.\n\n\nPrev\n \nHealthchecks\nNext\n \nIntegrations\nEdit this file on GitHub\nOn This Page\nHow it works\nBackup Schedules\nHow to restore a backup\nPricing\nCaveats"
  },
  {
    "url": "https://docs.railway.app/reference/build-and-start-commands",
    "title": "Build and Start Commands | Railway Docs",
    "content": "Build and Start Commands\nRailway uses \nNixpacks\n to build and deploy your code with zero configuration.  Build and Start commands are automatically detected when an image is built and deployed to a \nservice\n in Railway.\n\n\nIf necessary, build and start commands can be manually configured.\n\n\nHow it Works\n\n\nOverrides are exposed in the service configuration to enable customizing the Build and Start commands.  When an override is configured, Railway uses the commands specified to build and start the service.\n\n\nBuild Command\n\n\nThe command to build the service, for example \nyarn run build\n. Override the detected build command by setting a value in your service settings.\n\n\n\n\nStart Command\n\n\nRailway automatically configures the start command based on the code being deployed.\n\n\nIf your service deploys with a \nDockerfile\n or from an \nimage\n, the start command defaults to the \nENTRYPOINT\n and / or \nCMD\n defined in the Dockerfile.\n\n\nOverride the detected start command by setting a value in your service settings.\n\n\n\n\nIf you need to use environment variables in the start command for services deployed from a Dockerfile or image you will need to wrap your command in a shell -\n\n\n/bin/sh -c \n\"exec python main.py --port \n$PORT\n\"\n\n\nThis is because commands ran in exec form do not support variable expansion.\n\n\nSupport\n\n\nFor more information on how to configure builds, check out the \nBuilds\n guide section.\n\n\nFor more information on how to configure a service's deployment lifecycle, like the Start command, check out the \nDeployments\n guide section.\nPrev\n \nApp Sleeping\nNext\n \nConfig as Code\nEdit this file on GitHub\nOn This Page\nHow it Works\nBuild Command\nStart Command\nSupport"
  },
  {
    "url": "https://docs.railway.app/reference/cli-api",
    "title": "CLI Reference | Railway Docs",
    "content": "CLI Reference\nThe Railway Command Line Interface (CLI) lets you interact with your\nRailway project from the command line.\n\n\nThis document describes the commands available in the CLI.\n\n\nFor information on how to install the CLI and more examples of usage, see the \nCLI guide\n.\n\n\nAdd\n\n\nAdd a service to your project\n\n\n~ railway add --help\n\nAdd a service to your project\n\nUsage: railway add [OPTIONS]\n\nOptions:\n  -d, --database <DATABASE>\n          The name of the database to add\n\n          [possible values: postgres, mysql, redis, mongo]\n\n  -s, --service [<SERVICE>]\n          The name of the service to create (leave blank for randomly generated)\n\n  -r, --repo <REPO>\n          The repo to link to the service\n\n  -i, --image <IMAGE>\n          The docker image to link to the service\n\n  -v, --variables <VARIABLES>\n          The \"{key}={value}\" environment variable pair to set the service variables. Example:\n\n          railway add --service --variables \"MY_SPECIAL_ENV_VAR=1\" --variables \"BACKEND_PORT=3000\"\n\n      --json\n          Output in JSON format\n\n  -h, --help\n          Print help (see a summary with '-h')\n\n  -V, --version\n          Print version\n\n\nCompletion\n\n\nGenerate a shell-completions for the following shells: \nbash\n, \nelvish\n, \nfish\n, and \npowershell\n\n\n~ railway completion --help\n\nGenerate completion script\n\nUsage: railway completion [OPTIONS] <SHELL>\n\nArguments:\n  <SHELL>  [possible values: bash, elvish, fish, powershell, zsh]\n\nOptions:\n      --json     Output in JSON format\n  -h, --help     Print help\n  -V, --version  Print version\n\n\nConnect\n\n\nConnect to a database's shell (\npsql\n for Postgres, \nmongosh\n for MongoDB, etc.)\n\n\n~ railway connect --help\n\nConnect to a database's shell (psql for Postgres, mongosh for MongoDB, etc.)\n\nUsage: railway connect [OPTIONS] [SERVICE_NAME]\n\nArguments:\n  [SERVICE_NAME]  The name of the database to connect to\n\nOptions:\n  -e, --environment <ENVIRONMENT>  Environment to pull variables from (defaults to linked environment)\n      --json                       Output in JSON format\n  -h, --help                       Print help\n  -V, --version                    Print version\n\n\nThis requires you to have the database's appropriate shell/client installed in your \n$PATH\n:\n\n\n\n\nPostgres: \npsql\n (\nhttps://www.postgresql.org/docs/current/app-psql.html\n)\n\n\nRedis: \nredis-cli\n (\nhttps://redis.io/docs/ui/cli/\n)\n\n\nMongoDB: \nmongosh\n (\nhttps://www.mongodb.com/docs/mongodb-shell/\n)\n\n\nMySQL: \nmysql\n (\nhttps://dev.mysql.com/doc/refman/8.0/en/mysql.html\n)\n\n\n\n\nDeploy\n\n\nDeploy a template into your project\n\n\nrailway deploy --help\n\nProvisions a template into your project\n\nUsage: railway deploy [OPTIONS]\n\nOptions:\n  -t, --template <TEMPLATE>  The code of the template to deploy\n  -v, --variable <VARIABLE>  The \"{key}={value}\" environment variable pair to set the template variables\n          To specify the variable for a single service prefix it with \"{service}.\" Example:\n          bash railway deploy -t postgres -v \"MY_SPECIAL_ENV_VAR=1\" -v \"Backend.Port=3000\"\n\n      --json                 Output in JSON format\n  -h, --help                 Print help (see a summary with '-h')\n  -V, --version              Print version\n\n\nDomain\n\n\nCreate a domain for a service\n\n\n~ railway domain --help\n\nAdd a custom domain or generate a railway provided domain for a service\n\nUsage: railway domain [OPTIONS] [DOMAIN]\n\nArguments:\n  [DOMAIN]  Optionally, specify a custom domain to use. If not specified, a domain will be generated\n\nOptions:\n  -p, --port <PORT>        The port to connect to the domain\n  -s, --service <SERVICE>  The name of the service to generate the domain for\n      --json               Output in JSON format\n  -h, --help               Print help (see more with '--help')\n  -V, --version            Print version\n\n\nDocs\n\n\nOpen the Railway documentation site in the default browser\n\n\n~ railway docs --help\n\nOpen Railway Documentation in default browser\n\nUsage: railway docs [OPTIONS]\n\nOptions:\n      --json     Output in JSON format\n  -h, --help     Print help\n  -V, --version  Print version```\n\n\nDown\n\n\nRemove the most recent deployment\n\n\n~ railway down --help\n\nRemove the most recent deployment\n\nUsage: railway down [OPTIONS]\n\nOptions:\n  -y, --yes      Skip confirmation dialog\n      --json     Output in JSON format\n  -h, --help     Print help\n  -V, --version  Print version\n\n\nEnvironment\n\n\nCreate, delete or link an environment\n\n\n~ railway [env]ironment --help\n\nCreate, delete or link an environment\n\nUsage: railway environment [OPTIONS] [ENVIRONMENT] [COMMAND]\n\nCommands:\n  new     Create a new environment\n  delete  Delete an environment [aliases: remove, rm]\n  help    Print this message or the help of the given subcommand(s)\n\nArguments:\n  [ENVIRONMENT]  The environment to link to\n\nOptions:\n      --json     Output in JSON format\n  -h, --help     Print help\n  -V, --version  Print version\n\n\nView \nenvironment docs\n for more information.\n\n\nIf you run \nrailway environment\n without specifying a name, you will be prompted\nwith an environment selector that lists all your environments for the project.\n\n\nrailway environment new\n\n\nCreate a new environment\n\n\n~ railway [env]ironment new --help\n\nCreate a new environment\n\nUsage: railway environment new [OPTIONS] [NAME]\n\nArguments:\n  [NAME]\n          The name of the environment to create\n\nOptions:\n  -d, --duplicate <DUPLICATE>\n          The name of the environment to duplicate\n\n          [aliases: copy]\n          [short aliases: c]\n\n  -v, --service-variable <SERVICE> <VARIABLE>\n          Variables to assign in the new environment\n\n          Note: This will only work if the environment is being duplicated, and that the service specified is present in the original environment\n\n          Examples:\n\n          railway environment new foo --duplicate bar --service-variable <service name/service uuid> BACKEND_PORT=3000\n\n      --json\n          Output in JSON format\n\n  -h, --help\n          Print help (see a summary with '-h')\n\n  -V, --version\n          Print version\n\n\nrailway environment delete\n\n\nDelete an environment\n\n\n~ railway [env]ironment delete --help\n\nDelete an environment\n\nUsage: railway environment delete [OPTIONS] [ENVIRONMENT]\n\nArguments:\n  [ENVIRONMENT]  The environment to delete\n\nOptions:\n  -y, --yes      Skip confirmation dialog\n      --json     Output in JSON format\n  -h, --help     Print help\n  -V, --version  Print version\n\n\nNote\n: \nrailway environment delete\n will not work if an account has 2FA and the terminal is not being run interactively.\n\n\nInit\n\n\nCreate a new Project from the CLI\n\n\n~ railway init --help\n\nCreate a new project\n\nUsage: railway init [OPTIONS]\n\nOptions:\n  -n, --name <NAME>  Project name\n      --json         Output in JSON format\n  -h, --help         Print help\n  -V, --version      Print version\n\n\nLink\n\n\nConnect to an existing Railway project\n\n\n~ railway link --help\n\nAssociate existing project with current directory, may specify projectId as an argument\n\nUsage: railway link [OPTIONS]\n\nOptions:\n  -e, --environment <ENVIRONMENT>  Environment to link to\n  -p, --project <PROJECT>          Project to link to\n  -s, --service <SERVICE>          The service to link to\n  -t, --team <TEAM>                The team to link to. Use \"personal\" for your personal account\n      --json                       Output in JSON format\n  -h, --help                       Print help\n  -V, --version                    Print version\n\n\nRunning \nlink\n with no project ID will prompt you to select a team and project.\n\n\nList\n\n\nList all projects in your Railway account\n\n\n~ railway list --help\n\nList all projects in your Railway account\n\nUsage: railway list [OPTIONS]\n\nOptions:\n      --json     Output in JSON format\n  -h, --help     Print help\n  -V, --version  Print version\n\n\nLogin\n\n\nLogin to your Railway account\n\n\n~ railway login --help\n\nLogin to your Railway account\n\nUsage: railway login [OPTIONS]\n\nOptions:\n  -b, --browserless  Browserless login\n      --json         Output in JSON format\n  -h, --help         Print help\n  -V, --version      Print version\n\n\nThis will open the browser to \nhttps://railway.com/cli-login\n.\n\n\nBrowserless\n\n\nIf you are in an environment where the terminal cannot open a web browser, (i.e.\nSSH session or \nCodespaces\n), you can\nperform a \nbrowserless\n login.\n\n\n~ railway login --browserless\n\nBrowserless Login\nPlease visit:\n  https://railway.com/cli-login?d=SGVsbG8sIGtpbmQgc3RyYW5nZXIhIFRoYW5rcyBmb3IgcmVhZGluZyB0aGUgZG9jdW1lbnRhdGlvbiEgSSBob3BlIHlvdSdyZSBoYXZpbmcgYSB3b25kZXJmdWwgZGF5IDopCg==\nYour pairing code is: friendly-malicious-electric-soup\n\nLogged in as Nebula (nebula@railway.com)\n\n\nThis will prompt you to go to a URL (you can copy and paste) and present you\nwith a 4 word code that you need to verify. If the codes match, click \"Verify\"\nand you will be logged in.\n\n\nLogout\n\n\nLogout of your Railway account\n\n\n~ railway logout --help\n\nLogout of your Railway account\n\nUsage: railway logout [OPTIONS]\n\nOptions:\n      --json     Output in JSON format\n  -h, --help     Print help\n  -V, --version  Print version\n\n\nLogs\n\n\nView logs for the most recent deployment\n\n\n~ railway logs --help\n\nView the most-recent deploy's logs\n\nUsage: railway logs [OPTIONS]\n\nOptions:\n  -d, --deployment  Show deployment logs\n  -b, --build       Show build logs\n      --json        Output in JSON format\n  -h, --help        Print help\n  -V, --version     Print version\n\n\nOpen\n\n\nOpen your current Railway project in the browser\n\n\n~ railway open --help\n\nOpen your project dashboard\n\nUsage: railway open [OPTIONS]\n\nOptions:\n      --json     Output in JSON format\n  -h, --help     Print help\n  -V, --version  Print version\n\n\nRun\n\n\nRun a command using the Railway environment\n\n\n~ railway run --help\n\nRun a local command using variables from the active environment\n\nUsage: railway run [OPTIONS] [ARGS]...\n\nArguments:\n  [ARGS]...  Args to pass to the command\n\nOptions:\n  -s, --service <SERVICE>          Service to pull variables from (defaults to linked service)\n  -e, --environment <ENVIRONMENT>  Environment to pull variables from (defaults to linked environment)\n      --json                       Output in JSON format\n  -h, --help                       Print help\n  -V, --version                    Print version\n\n\nThis also injects all environment variables associated with the databases you have\ninstalled in your project.\n\n\nService\n\n\nLink a service to the current project\n\n\n~ railway service --help\n\nLink a service to the current project\n\nUsage: railway service [OPTIONS] [SERVICE]\n\nArguments:\n  [SERVICE]  The service to link\n\nOptions:\n      --json     Output in JSON format\n  -h, --help     Print help\n  -V, --version  Print version\n\n\nShell\n\n\nCreate a subshell (based on \n$SHELL\n) with all the variables from your project/environment/service loaded and accessible\n\n\n~ railway shell --help\n\nOpen a subshell with Railway variables available\n\nUsage: railway shell [OPTIONS]\n\nOptions:\n  -s, --service <SERVICE>  Service to pull variables from (defaults to linked service)\n      --json               Output in JSON format\n  -h, --help               Print help\n  -V, --version            Print version\n\n\nSSH\n\n\nSSH into a project/service\n\n\n~ railway ssh --help\n\nConnect to a service via SSH\n\nUsage: railway ssh [OPTIONS] [COMMAND]...\n\nArguments:\n  [COMMAND]...  Command to execute instead of starting an interactive shell\n\nOptions:\n  -p, --project <PROJECT>\n          Project to connect to (defaults to linked project)\n  -s, --service <SERVICE>\n          Service to connect to (defaults to linked service)\n  -e, --environment <ENVIRONMENT>\n          Environment to connect to (defaults to linked environment)\n  -d, --deployment-instance <deployment-instance-id>\n          Deployment instance ID to connect to (defaults to first active instance)\n      --json\n          Output in JSON format\n  -h, --help\n          Print help\n  -V, --version\n          Print version\n\n\nStatus\n\n\nView the status of your Railway project and user\n\n\n~ railway status --help\n\nShow information about the current project\n\nUsage: railway status [OPTIONS]\n\nOptions:\n      --json     Output in JSON format\n  -h, --help     Print help\n  -V, --version  Print version\n\n\nUnlink\n\n\nDisconnects the current directory from Railway\n\n\n~ Disassociate project from current directory\n\n\nUsage: railway unlink [OPTIONS]\n\nOptions:\n  -s, --service  Unlink a service\n      --json     Output in JSON format\n  -h, --help     Print help\n  -V, --version  Print version\n\n\nYou will need to rerun \nrailway link\n to use \nrailway\n in this directory again.\n\n\nUp\n\n\nDeploy a directory to your Railway project\n\n\n~ railway up --help\n\nUpload and deploy project from the current directory\n\nUsage: railway up [OPTIONS] [PATH]\n\nArguments:\n  [PATH]\n\nOptions:\n  -d, --detach                     Don't attach to the log stream\n  -c, --ci                         Only stream build logs and exit after it's done\n  -s, --service <SERVICE>          Service to deploy to (defaults to linked service)\n  -e, --environment <ENVIRONMENT>  Environment to deploy to (defaults to linked environment)\n      --no-gitignore               Don't ignore paths from .gitignore\n      --verbose                    Verbose output\n      --json                       Output in JSON format\n  -h, --help                       Print help\n  -V, --version                    Print version\n\n\nIf no path is provided, the top linked directory is deployed. The currently selected environment is used.\n\n\nVariables\n\n\nView a table of all the environment variables associated with your project and environment\n\n\n~ railway variables --help\n\nShow variables for active environment\n\nUsage: railway variables [OPTIONS]\n\nOptions:\n  -s, --service <SERVICE>          The service to show/set variables for\n  -e, --environment <ENVIRONMENT>  The environment to show/set variables for\n  -k, --kv                         Show variables in KV format\n      --set <SET>                  The \"{key}={value}\" environment variable pair to set the service variables. Example:\n                                      railway variables --set \"MY_SPECIAL_ENV_VAR=1\" --set \"BACKEND_PORT=3000\"\n      --json                       Output in JSON format\n  -h, --help                       Print help (see a summary with '-h')\n  -V, --version                    Print version\n\n\nWhoami\n\n\nView what user is currently authenticated with Railway\n\n\n~ railway whoami --help\n\nGet the current logged in user\n\nUsage: railway whoami [OPTIONS]\n\nOptions:\n      --json     Output in JSON format\n  -h, --help     Print help\n  -V, --version  Print version\n\n\nVolume\n\n\nManage project volumes with options to list, add, delete, update, attach, and detach volumes\n\n\n~ railway volume --help\n\nManage project volumes\n\nUsage: railway volume [OPTIONS] <COMMAND>\n\nCommands:\n  list    List volumes\n  add     Add a new volume\n  delete  Delete a volume\n  update  Update a volume\n  detach  Detach a volume from a service\n  attach  Attach a volume to a service\n  help    Print this message or the help of the given subcommand(s)\n\nOptions:\n  -s, --service <SERVICE>          Service ID\n  -e, --environment <ENVIRONMENT>  Environment ID\n      --json                       Output in JSON format\n  -h, --help                       Print help\n  -V, --version                    Print version\n\n\nRedeploy\n\n\nRedeploy the currently deployed version of a service\n\n\n~ railway redeploy --help\n\nRedeploy the latest deployment of a service\n\nUsage: railway redeploy [OPTIONS]\n\nOptions:\n  -s, --service <SERVICE>  The service ID/name to redeploy from\n  -y, --yes                Skip confirmation dialog\n      --json               Output in JSON format\n  -h, --help               Print help\n  -V, --version            Print version\n\n\nHelp\n\n\nHelp command reference\n\n\n~ railway help\n\nInteract with Railway via CLI\n\nUsage: railway [OPTIONS] <COMMAND>\n\nCommands:\n  add          Add a service to your project\n  completion   Generate completion script\n  connect      Connect to a database's shell (psql for Postgres, mongosh for MongoDB, etc.)\n  deploy       Provisions a template into your project\n  domain       Generates a domain for a service if there is not a railway provided domain\n  docs         Open Railway Documentation in default browser\n  down         Remove the most recent deployment\n  environment  Change the active environment\n  init         Create a new project\n  link         Associate existing project with current directory, may specify projectId as an argument\n  list         List all projects in your Railway account\n  login        Login to your Railway account\n  logout       Logout of your Railway account\n  logs         View a deploy's logs\n  open         Open your project dashboard\n  run          Run a local command using variables from the active environment\n  service      Link a service to the current project\n  shell        Open a local subshell with Railway variables available\n  status       Show information about the current project\n  unlink       Disassociate project from current directory\n  up           Upload and deploy project from the current directory\n  variables    Show variables for active environment\n  whoami       Get the current logged in user\n  volume       Manage project volumes\n  redeploy     Redeploy the latest deployment of a service\n  help         Print this message or the help of the given subcommand(s)\n\nOptions:\n      --json     Output in JSON format\n  -h, --help     Print help\n  -V, --version  Print version\nPrev\n \nUsage Limits\nNext\n \nPublic API\nEdit this file on GitHub\nOn This Page\nAdd\nCompletion\nConnect\nDeploy\nDomain\nDocs\nDown\nEnvironment\nrailway environment new\nrailway environment delete\nInit\nLink\nList\nLogin\nBrowserless\nLogout\nLogs\nOpen\nRun\nService\nShell\nSSH\nStatus\nUnlink\nUp\nVariables\nWhoami\nVolume\nRedeploy\nHelp"
  },
  {
    "url": "https://docs.railway.app/reference/config-as-code",
    "title": "Config as Code | Railway Docs",
    "content": "Config as Code\nRailway supports defining the configuration for a single deployment in a file\nalongside your code. By default, we will look for a \nrailway.toml\n or\n\nrailway.json\n file.\n\n\nEverything in the build and deploy sections of the service\nsettings can be specified in this configuration file.\n\n\nHow does it work?\n\n\nWhen a new deployment is triggered, Railway will look for any config files in your\ncode and combine these values with the settings from the dashboard.\n\n\nThe resulting build and deploy config will be used \nonly for the current deployment\n.\n\n\nThe settings in the dashboard will not be updated with the settings defined in\ncode.\n\n\nConfiguration defined in code will always override values from the\ndashboard.\n\n\nConfig Source Location\n\n\nOn the deployment details page, all the settings that a deployment went out with are shown. For settings that come from a configuration file, there is a little file icon. Hovering over the icon will show exactly what part of the file the values originated from.\n\n\n\n\nConfigurable Settings\n\n\n\n\nSpecify the Builder\n\n\nSet the builder for the deployment.\n\n\n{\n\n\n  \n\"$schema\"\n:\n \n\"https://railway.com/railway.schema.json\"\n,\n\n\n  \n\"build\"\n:\n \n{\n\n\n    \n\"builder\"\n:\n \n\"NIXPACKS\"\n\n\n  \n}\n\n\n}\n\n\nPossible values are:\n\n\n\n\nNIXPACKS\n\n\nDOCKERFILE\n\n\n\n\nNote: Railway will always build with a Dockerfile if it finds one. To build with nixpacks, you can remove or rename the Dockerfile.\n\n\nRead more about Builds \nhere\n.\n\n\nWatch Patterns\n\n\nArray of patterns used to conditionally trigger a deploys.\n\n\n{\n\n\n  \n\"$schema\"\n:\n \n\"https://railway.com/railway.schema.json\"\n,\n\n\n  \n\"build\"\n:\n \n{\n\n\n    \n\"watchPatterns\"\n:\n \n[\n\"src/**\"\n]\n\n\n  \n}\n\n\n}\n\n\nRead more about watch patterns \nhere\n.\n\n\nBuild Command\n\n\nBuild command to pass to the Nixpacks builder.\n\n\n{\n\n\n  \n\"$schema\"\n:\n \n\"https://railway.com/railway.schema.json\"\n,\n\n\n  \n\"build\"\n:\n \n{\n\n\n    \n\"buildCommand\"\n:\n \n\"yarn run build\"\n\n\n  \n}\n\n\n}\n\n\nThis field can be set to \nnull\n.\n\n\nRead more about the build command \nhere\n.\n\n\nDockerfile Path\n\n\nLocation of non-standard Dockerfile.\n\n\n{\n\n\n  \n\"$schema\"\n:\n \n\"https://railway.com/railway.schema.json\"\n,\n\n\n  \n\"build\"\n:\n \n{\n\n\n    \n\"dockerfilePath\"\n:\n \n\"Dockerfile.backend\"\n\n\n  \n}\n\n\n}\n\n\nThis field can be set to \nnull\n.\n\n\nMore about building from a Dockerfile \nhere\n.\n\n\nNixpacks Config Path\n\n\nLocation of a non-standard \nNixpacks\n config file.\n\n\n{\n\n\n  \n\"$schema\"\n:\n \n\"https://railway.com/railway.schema.json\"\n,\n\n\n  \n\"build\"\n:\n \n{\n\n\n    \n\"nixpacksConfigPath\"\n:\n \n\"backend_nixpacks.toml\"\n\n\n  \n}\n\n\n}\n\n\nThis field can be set to \nnull\n.\n\n\nNixpacks Plan\n\n\nFull nixpacks plan. See \nthe Nixpacks documentation\n for more info.\n\n\n{\n\n\n  \n\"$schema\"\n:\n \n\"https://railway.com/railway.schema.json\"\n,\n\n\n  \n\"build\"\n:\n \n{\n\n\n    \n\"nixpacksPlan\"\n:\n \n{\n\n\n      \n\"providers\"\n:\n \n[\n\"python\"\n,\n \n\"node\"\n]\n,\n\n\n      \n\"phases\"\n:\n \n{\n\n\n        \n\"install\"\n:\n \n{\n\n\n          \n\"dependsOn\"\n:\n \n[\n\"setup\"\n]\n,\n\n\n          \n\"cmds\"\n:\n \n[\n\"npm ci\"\n]\n\n\n        \n}\n\n\n      \n}\n\n\n    \n}\n\n\n  \n}\n\n\n}\n\n\nThis field can be set to \nnull\n.\n\n\nYou can also define specific options as follows.\n\n\nIn this example, we are adding ffmpeg to the setup phase.\n\n\n{\n\n\n  \n\"$schema\"\n:\n \n\"https://railway.com/railway.schema.json\"\n,\n\n\n  \n\"build\"\n:\n \n{\n\n\n    \n\"nixpacksPlan\"\n:\n \n{\n\n\n      \n\"phases\"\n:\n \n{\n\n\n        \n\"setup\"\n:\n \n{\n\n\n          \n\"nixPkgs\"\n:\n \n[\n\"...\"\n,\n \n\"ffmpeg\"\n]\n\n\n        \n}\n\n\n      \n}\n\n\n    \n}\n\n\n  \n}\n\n\n}\n\n\nCustom Install Command\n\n\nUse nixpacksPlan to configure a custom install command.\n\n\n{\n\n\n  \n\"$schema\"\n:\n \n\"https://railway.com/railway.schema.json\"\n,\n\n\n  \n\"build\"\n:\n \n{\n\n\n    \n\"nixpacksPlan\"\n:\n \n{\n\n\n      \n\"phases\"\n:\n \n{\n\n\n        \n\"install\"\n:\n \n{\n\n\n          \n\"dependsOn\"\n:\n \n[\n\"setup\"\n]\n,\n\n\n          \n\"cmds\"\n:\n \n[\n\"npm install --legacy-peer-deps\"\n]\n\n\n        \n}\n\n\n      \n}\n\n\n    \n}\n\n\n  \n}\n\n\n}\n\n\nNixpacks Version\n\n\nEXPERIMENTAL: USE AT YOUR OWN RISK!.\n\n\nVersion of Nixpacks to use. Must be a valid Nixpacks version.\n\n\n{\n\n\n  \n\"$schema\"\n:\n \n\"https://railway.com/railway.schema.json\"\n,\n\n\n  \n\"build\"\n:\n \n{\n\n\n    \n\"nixpacksVersion\"\n:\n \n\"1.29.1\"\n\n\n  \n}\n\n\n}\n\n\nThis field can be set to \nnull\n.\n\n\nYou can also use the \nNIXPACKS_VERSION\n \nconfiguration variable\n to set the Nixpacks version.\n\n\nStart Command\n\n\nThe command to run when starting the container.\n\n\n{\n\n\n  \n\"$schema\"\n:\n \n\"https://railway.com/railway.schema.json\"\n,\n\n\n  \n\"deploy\"\n:\n \n{\n\n\n    \n\"startCommand\"\n:\n \n\"node index.js\"\n\n\n  \n}\n\n\n}\n\n\nThis field can be set to \nnull\n.\n\n\nRead more about the start command \nhere\n.\n\n\nPre-deploy Command\n\n\nThe command to run before starting the container.\n\n\n{\n\n\n  \n\"$schema\"\n:\n \n\"https://railway.com/railway.schema.json\"\n,\n\n\n  \n\"deploy\"\n:\n \n{\n\n\n    \n\"preDeployCommand\"\n:\n \n[\n\"npm run db:migrate\"\n]\n\n\n  \n}\n\n\n}\n\n\nThis field can be ommitted.\n\n\nRead more about the pre-deploy command \nhere\n.\n\n\nMulti-region Configuration\n\n\nHorizontal scaling across multiple regions, with two replicas in each region.\n\n\n{\n\n\n  \n\"$schema\"\n:\n \n\"https://railway.com/railway.schema.json\"\n,\n\n\n  \n\"deploy\"\n:\n \n{\n\n\n    \n\"multiRegionConfig\"\n:\n \n{\n\n\n      \n\"us-west2\"\n:\n \n{\n\n\n        \n\"numReplicas\"\n:\n \n2\n\n\n      \n}\n,\n\n\n      \n\"us-east4-eqdc4a\"\n:\n \n{\n\n\n        \n\"numReplicas\"\n:\n \n2\n\n\n      \n}\n,\n\n\n      \n\"europe-west4-drams3a\"\n:\n \n{\n\n\n        \n\"numReplicas\"\n:\n \n2\n\n\n      \n}\n,\n\n\n      \n\"asia-southeast1-eqsg3a\"\n:\n \n{\n\n\n        \n\"numReplicas\"\n:\n \n2\n\n\n      \n}\n\n\n    \n}\n\n\n  \n}\n\n\n}\n\n\nThis field can be set to \nnull\n.\n\n\nRead more about horizontal scaling with multiple regions \nhere\n.\n\n\nHealthcheck Path\n\n\nPath to check after starting your deployment to ensure it is healthy.\n\n\n{\n\n\n  \n\"$schema\"\n:\n \n\"https://railway.com/railway.schema.json\"\n,\n\n\n  \n\"deploy\"\n:\n \n{\n\n\n    \n\"healthcheckPath\"\n:\n \n\"/health\"\n\n\n  \n}\n\n\n}\n\n\nThis field can be set to \nnull\n.\n\n\nRead more about the healthcheck path \nhere\n.\n\n\nHealthcheck Timeout\n\n\nNumber of seconds to wait for the healthcheck path to become healthy.\n\n\n{\n\n\n  \n\"$schema\"\n:\n \n\"https://railway.com/railway.schema.json\"\n,\n\n\n  \n\"deploy\"\n:\n \n{\n\n\n    \n\"healthcheckPath\"\n:\n \n\"/health\"\n,\n\n\n    \n\"healthcheckTimeout\"\n:\n \n300\n\n\n  \n}\n\n\n}\n\n\nThis field can be set to \nnull\n.\n\n\nRead more about the healthcheck timeout \nhere\n.\n\n\nRestart Policy Type\n\n\nHow to handle the deployment crashing.\n\n\n{\n\n\n  \n\"$schema\"\n:\n \n\"https://railway.com/railway.schema.json\"\n,\n\n\n  \n\"deploy\"\n:\n \n{\n\n\n    \n\"restartPolicyType\"\n:\n \n\"ALWAYS\"\n\n\n  \n}\n\n\n}\n\n\nPossible values are:\n\n\n\n\nON_FAILURE\n\n\nALWAYS\n\n\nNEVER\n\n\n\n\nRead more about the Restart policy \nhere\n.\n\n\nRestart Policy Max Retries\n\n\nSet the max number of retries for the restart policy.\n\n\n{\n\n\n  \n\"$schema\"\n:\n \n\"https://railway.com/railway.schema.json\"\n,\n\n\n  \n\"deploy\"\n:\n \n{\n\n\n    \n\"restartPolicyType\"\n:\n \n\"ALWAYS\"\n,\n\n\n    \n\"restartPolicyMaxRetries\"\n:\n \n5\n\n\n  \n}\n\n\n}\n\n\nThis field can be set to \nnull\n.\n\n\nRead more about the Restart policy \nhere\n.\n\n\nCron Schedule\n\n\nCron schedule\n of the deployed service.\n\n\n{\n\n\n  \n\"$schema\"\n:\n \n\"https://railway.com/railway.schema.json\"\n,\n\n\n  \n\"deploy\"\n:\n \n{\n\n\n    \n\"cronSchedule\"\n:\n \n\"*/15 * * * *\"\n\n\n  \n}\n\n\n}\n\n\nThis field can be set to \nnull\n.\n\n\nSetting Environment Overrides\n\n\nConfiguration can be overridden for a specific environment by nesting it in a\n\nenvironments.[name]\n block.\n\n\nWhen resolving the settings for a deployment, Railway will use this priority order:\n\n\n\n\nEnvironment specific config in code\n\n\nBase config in code\n\n\nService settings\n\n\n\n\nThe following example changes the start command just in the production\nenvironment.\n\n\n{\n\n\n  \n\"$schema\"\n:\n \n\"https://railway.com/railway.schema.json\"\n,\n\n\n  \n\"environments\"\n:\n \n{\n\n\n    \n\"staging\"\n:\n \n{\n\n\n      \n\"deploy\"\n:\n \n{\n\n\n        \n\"startCommand\"\n:\n \n\"npm run staging\"\n\n\n      \n}\n\n\n    \n}\n\n\n  \n}\n\n\n}\n\n\nPR Environment Overrides\n\n\nDeployments for pull requests can be configured using a special \npr\n environment. This configuration is applied only to deploys that belong to an ephemeral environment. When resolving the settings for a PR deployment, the following priority order is used:\n\n\n\n\nEnvironment with the name of the ephemeral environment\n\n\nEnvironment with the hardcoded name \"pr\"\n\n\nBase environment of the pull request\n\n\nBase config as code\n\n\nService settings\n\n\n\n\n{\n\n\n  \n\"$schema\"\n:\n \n\"https://railway.com/railway.schema.json\"\n,\n\n\n  \n\"environments\"\n:\n \n{\n\n\n    \n\"pr\"\n:\n \n{\n\n\n      \n\"deploy\"\n:\n \n{\n\n\n        \n\"startCommand\"\n:\n \n\"npm run pr\"\n\n\n      \n}\n\n\n    \n}\n\n\n  \n}\n\n\n}\n\n\nConfiguring a Build provider with Nixpacks\n\n\nTo define a build provider ahead of time, create a \nnixpacks.toml\n file and configure it like so:\n\n\nproviders\n \n=\n \n[\n\"...\"\n,\n \n\"python\"\n]\nPrev\n \nBuild and Start Commands\nNext\n \nCron Jobs\nEdit this file on GitHub\nOn This Page\nHow does it work?\nConfig Source Location\nConfigurable Settings\nSpecify the Builder\nWatch Patterns\nBuild Command\nDockerfile Path\nNixpacks Config Path\nNixpacks Plan\nCustom Install Command\nNixpacks Version\nStart Command\nPre-deploy Command\nMulti-region Configuration\nHealthcheck Path\nHealthcheck Timeout\nRestart Policy Type\nRestart Policy Max Retries\nCron Schedule\nSetting Environment Overrides\nPR Environment Overrides\nConfiguring a Build provider with Nixpacks"
  },
  {
    "url": "https://docs.railway.app/reference/deployment-regions",
    "title": "Deployment Regions | Railway Docs",
    "content": "Deployment Regions\nRailway's infrastructure spans multiple regions across the globe. This allows you to deploy your applications closer to your users no matter where they are located. \nThis feature is only available to Pro plan workspaces.\n\n\nConsider factors like compliance needs and proximity to your users when choosing a region.\n\n\nRegion Options\n\n\nRailway has deploy regions in the Americas, Europe, and Asia-Pacific to provide broad coverage around the world.\n\n\nWithin the service settings, you can select one of the following regions -\n\n\nName\nLocation\nRegion Identifier\nUS West\nOregon, USA\nus-west1\nUS West Metal\nCalifornia, USA\nus-west2\nUS East\nVirginia, USA\nus-east4\nUS East Metal\nNorth Carolina, USA\nus-east4-eqdc4a\nEU West\nAmsterdam, Netherlands\neurope-west4\nEU West Metal\nAmsterdam, Netherlands\neurope-west4-drams3a\nSoutheast Asia\nSingapore\nasia-southeast1\nSoutheast Asia Metal\nSingapore\nasia-southeast1-eqsg3a\n\n\nAdditional regions may be added in the future as Railway continues expanding its infrastructure footprint.\n\n\nNote:\n The region identifier is the value that can be used in your \nConfig as Code file\n.\n\n\nBy default, Railway deploys to your preferred region, you can change this in your \nAccount Settings\n.\n\n\nAll regions provide the same experience, performance, and reliability you expect from Railway.\n\n\nImpact of Region Changes\n\n\nThe region of a service can be changed at any time, without any changes to your domain, private networking, etc.\n\n\nThere will be no downtime when changing the region of a service, except if it has a volume attached to it (see below).\n\n\nVolumes\n\n\nVolumes follow the region of the service to which they are attached.\n\n\nIf you change the region of a service with an attached volume, the volume will need to be migrated to the new region.\n\n\n\n\nNote that this migration can take a while depending on the size of the volume, and will cause downtime of your service during that time.\n\n\n\n\nThe same is true if you attach a detached volume to a service in a different region. It will need to be migrated to the new region, which can take a while and cause downtime.\nPrev\n \nDeployments\nNext\n \nDockerfiles\nEdit this file on GitHub\nOn This Page\nRegion Options\nImpact of Region Changes\nVolumes"
  },
  {
    "url": "https://docs.railway.app/reference/deployments",
    "title": "Deployments | Railway Docs",
    "content": "Deployments\nDeployments are attempts to build and deliver your \nservice\n.\n\n\nAll deployments will appear in the deployments view on your selected service.\n\n\n\n\nHow it Works\n\n\nUpon service creation, or when changes are detected in the service source, Railway will build the service and package it into a container with \nNixpacks\n or a \nDockerfile\n if present. If the source is a Docker Image, the build step is skipped.\n\n\nRailway then starts the service using either the detected or configured \nStart Command\n.\n\n\nThis cycle represents a deployment in Railway.\n\n\nDeployment States\n\n\nA comprehensive up to date list of statues can be found in \nRailway's GraphQL playground\n under DeploymentStatus (\nscreenshot\n).\n\n\nDeployments can be in any of the following states:\n\n\nInitializing\n\n\nEvery Deployment in Railway begins as \nInitializing\n - once it has been accepted into our build queue, the status will change to \nBuilding\n.\n\n\nBuilding\n\n\nWhile a Deployment is \nBuilding\n, Railway will attempt to create a deployable Docker image containing your code and configuration (see \nBuilds\n).\n\n\nDeploying\n\n\nOnce the build succeeds, Railway will attempt to deploy your image and the Deployment's status becomes \nDeploying\n. If a \nhealthcheck\n is configured, Railway will wait for it to succeed before proceeding to the next step.\n\n\nFailed\n\n\nIf an error occurs during the build or deploy process, the Deployment will stop and the status will become \nFailed\n.\n\n\nActive\n\n\nRailway will determine the deployment's active state with the following logic -\n\n\n\n\n\n\nIf the deployment \nhas\n a \nhealthcheck\n configured, Railway will mark the deployment as \nActive\n when the healthcheck succeeds.\n\n\n\n\n\n\nIf the deployment \ndoes not\n have a healthcheck configured, Railway will mark the deployment as \nActive\n after starting the container.\n\n\n\n\n\n\nCompleted\n\n\nThis is the status of the Deployment when the running app exits with a non-zero exit code.\n\n\nCrashed\n\n\nA Deployment will remain in the \nActive\n state unless it \ncrashes\n, at which point it will become \nCrashed\n.\n\n\nRemoved\n\n\nWhen a new \nDeployment\n is triggered, older deploys in a \nActive\n, \nCompleted\n, or a \nCrashed\n state are eventually removed - first having their status updated to \nRemoving\n before they are finally \nRemoved\n. Deployments may also be \nremoved manually\n.\n\n\nThe time from when a new deployment becomes \nActive\n until the previous deployment is removed can be controlled by setting a \nRAILWAY_DEPLOYMENT_OVERLAP_SECONDS\n \nservice variable\n.\n\n\nDeployment Menu\n\n\nThe deployment menu contains actions you can take on a deployment.\n\n\nNote:\n Some actions are only available on certain deployment states.\n\n\n\n\nView logs\n\n\nOpens the deployment up to the corresponding logs, during build the build logs will be shown, during deploy the deploy logs will be shown.\n\n\nRestart\n\n\nRestarts the process within the deployment's container, this is often used to bring a service back online after a crash or if you application has locked up.\n\n\nRedeploy\n\n\nRedeploys the selected deployment.\n\n\nThis is often used to bring a service back online after -\n\n\n\n\nA crash.\n\n\nA usage limit has been reached and raised.\n\n\nUpgrading to Hobby when trial credits were previously depleted.\n\n\nBeing demoted from Hobby to free and then upgrading again.\n\n\n\n\nNotes\n -\n\n\n\n\n\n\nThe redeploy will use the source code from the selected deployment.\n\n\n\n\n\n\nRailway only retains deployment images for 2 weeks. You can only redeploy a deployment that is 2 weeks old or newer. Older deployments will not be available for redeployment.\n\n\n\n\n\n\nRollback\n\n\nRedeploys the selected deployment.\n\n\nNotes\n -\n\n\n\n\n\n\nThe rollback will use the source code from the selected deployment.\n\n\n\n\n\n\nRailway only retains deployment images for 2 weeks. You can only roll back to a deployment that is 2 weeks old or newer. Older deployments will not be available for rollback.\n\n\n\n\n\n\nRemove\n\n\nStops the currently running deployment, this also marks the deployment as \nREMOVED\n and moves it into the history section.\n\n\nAbort\n\n\nCancels the selected \ninitializing\n or \nbuilding\n deployment, this also marks the deployment as \nREMOVED\n and moves it into the history section.\n\n\nEphemeral Storage\n\n\nEvery service deployment has access to 10GB of ephemeral storage. If a service deployment consumes more than 10GB, it can be forcefully stopped and redeployed.\n\n\nIf your service requires data to persist between deployments, or needs more than 10GB of storage, you should add a \nvolume\n.\n\n\nSingleton Deploys\n\n\nBy default, Railway maintains only one deploy per service.\n\n\nIn practice, this means that if you trigger a new deploy either \nmanually\n or \nautomatically\n, the old version will be stopped and removed with a slight overlap for zero downtime.\n\n\nOnce the new deployment is online, the old deployment is sent a SIGTERM signal and given 3 seconds to gracefully shutdown before being forcefully stopped with a SIGKILL. We do not send any other signals under any circumstances.\n\n\nThe time given to gracefully shutdown can be controlled by setting a \nRAILWAY_DEPLOYMENT_DRAINING_SECONDS\n \nservice variable\n.\n\n\nRailway Initiated Deployments\n\n\nOccasionally, Railway will initiate a new deployment to migrate your service from one host to another. \nThis is primarily for your service's security and performance.\n\n\nWe perform these migrations when implementing security patches or platform upgrades to the underlying infrastructure where your service was previously running. During platform-wide upgrades, your service might be redeployed multiple times as we roll out changes across our infrastructure. These deployments are mandatory and cannot be opted out of.\n\n\nThese Railway-initiated deployments will display with a banner above the Active deployment to clearly identify them.\n\n\nSupport\n\n\nFor information on how to manage your deployments, explore \nthe guides in this section\n.\nPrev\n \nCron Jobs\nNext\n \nDeployment Regions\nEdit this file on GitHub\nOn This Page\nHow it Works\nDeployment States\nInitializing\nBuilding\nDeploying\nFailed\nActive\nCompleted\nCrashed\nRemoved\nDeployment Menu\nView logs\nRestart\nRedeploy\nRollback\nRemove\nAbort\nEphemeral Storage\nSingleton Deploys\nRailway Initiated Deployments\nSupport"
  },
  {
    "url": "https://docs.railway.app/reference/dockerfiles",
    "title": "Dockerfiles | Railway Docs",
    "content": "Dockerfiles\nUse a Dockerfile to instruct Railway how to build a service.\n\n\nHow it works\n\n\nWhen building a service, Railway will look for and use a \nDockerfile\n at the root of the source directory.\n\n\nNote:\n For the automatic Dockerfile detection to work, the Dockerfile must be named \nDockerfile\n with a capital D, otherwise Railway will not use it by default.\n\n\nRailway notifies you when it's using the \nDockerfile\n in the build process with the following message in the logs:\n\n\n==\n==\n==\n==\n==\n==\n==\n==\n==\n==\n==\n==\n==\n\n\nUsing detected Dockerfile\n!\n\n\n==\n==\n==\n==\n==\n==\n==\n==\n==\n==\n==\n==\n==\n\n\nSupport\n\n\nFor more information, refer to the guide on \nhow to use Dockerfiles\n.\nPrev\n \nDeployment Regions\nNext\n \nHealthchecks\nEdit this file on GitHub\nOn This Page\nHow it works\nSupport"
  },
  {
    "url": "https://docs.railway.app/reference/environments",
    "title": "Environments | Railway Docs",
    "content": "Environments\nRailway environments give you an isolated instance of all services in a project.\n\n\nHow it Works\n\n\nAll projects in Railway are created with a \nproduction\n environment by default.  Once a project has been created, new environments can be created and configured to complement any development workflow.\n\n\nTypes of Environments\n\n\nPersistent Environments\n\n\nPersistent environments are intended to persist but remain isolated from production with regard to their configuration.\n\n\nFor example, it is a common pattern to maintain a \nstaging\n environment that is configured to auto-deploy from a \nstaging\n branch and with variables relevant to \nstaging\n.\n\n\nPR Environments\n\n\nPR Environments\n are temporary.  They are created when a Pull Request is opened on a branch and are deleted as soon as the PR is merged or closed.\n\n\nEnvironment Isolation\n\n\nAll changes made to a service are scoped to a single environment. This means that you can make changes to a service in an environment without affecting other environments.\n\n\nUse Cases\n\n\nEnvironments are generally used for isolating changes from the production environment, to iterate and test before pushing to production.\n\n\n\n\nHave development environments for each team member that are identical to the\nproduction environment\n\n\nHave separate staging and production environments that auto-deploy when changes are made to different branches in a code repository.\n\n\n\n\nSupport\n\n\nExplore the \nEnvironments\n guide for more information on how to use and manage environments.\nPrev\n \nDatabases\nNext\n \nProjects\nEdit this file on GitHub\nOn This Page\nHow it Works\nTypes of Environments\nPersistent Environments\nPR Environments\nEnvironment Isolation\nUse Cases\nSupport"
  },
  {
    "url": "https://docs.railway.app/reference/errors",
    "title": "Errors | Railway Docs",
    "content": "Errors\n\n\nWhen deploying to Railway, you may encounter some errors that prevent your\napplication from working as expected.\n\n\nThese are pages that describe and provide solutions to errors that users commonly encounter.\n\n\n\n\n\n\nApplication Failed to Respond\n\n\n\n\n\n\nNo Start Command Could Be Found\n\n\n\n\n\n\n405 Method Not Allowed\n\n\n\n\n\n\nNixpacks Was Unable to Generate a Build Plan for This App\n\n\n\n\n\n\nENOTFOUND redis.railway.internal\n\n\n\n\nPrev\n \nSelf Hosted Runners\nNext\n \nApplication Failed to Respond\nEdit this file on GitHub"
  },
  {
    "url": "https://docs.railway.app/reference/errors/405-method-not-allowed",
    "title": "405 Method Not Allowed | Railway Docs",
    "content": "405 Method Not Allowed\nWhat This Error Means\n\n\nThis error is returned by your application when you attempt to make a POST request to your application, but the request is redirected to a GET request.\n\n\nDepending on the application, this may result in your application returning either a 405 Method Not Allowed or a 404 Not Found status code.\n\n\nSeemingly POST requests are being turned into GET requests.\n\n\nWhy This Error Can Occur\n\n\nThis occurs because your request was made using HTTP. Railway will attempt to redirect your insecure request with a 301 Moved Permanently status code.\n\n\nWhen an HTTP client encounters a 301 Moved Permanently redirect, the client will follow the redirect. However, according to the \nHTTP/1.1 specifications\n, the client will typically change the request method from POST to GET when it follows the redirect to the new URL.\n\n\nSolution\n\n\nEnsure you are explicitly using \nhttps://\n when calling your Railway-hosted services.\n\n\nFor example, if you are using \ncurl\n to test your application, you should use the following command:\n\n\ncurl\n -X POST https://your-app.railway.app/api\n\n\nNotice the \nhttps://\n prefix.\n\n\nThis ensures that the request is made using HTTPS, avoiding the 405 Method Not Allowed error that your application would otherwise return.\nPrev\n \nNo Start Command Could Be Found\nNext\n \nUnable to Generate a Build Plan\nEdit this file on GitHub\nOn This Page\nWhat This Error Means\nWhy This Error Can Occur\nSolution"
  },
  {
    "url": "https://docs.railway.app/reference/errors/application-failed-to-respond",
    "title": "Application Failed to Respond | Railway Docs",
    "content": "Application Failed to Respond\n\n\nWhat This Error Means\n\n\nSeeing that your application failed to respond means that Railway's Edge Proxy cannot communicate with your application, causing your request to fail with a 502 (Bad Gateway) status code.\n\n\nWhy This Error Can Occur\n\n\nThere are a few reasons why this error can occur, the most common being that your application is not listening on the correct host or port.\n\n\nAnother common reason is that your \ntarget port\n is set to an incorrect value.\n\n\nIn some far less common cases this error can also occur if your application is under heavy load and is not able to respond to the incoming request.\n\n\nPossible Solutions\n\n\nThe correct solution depends on the cause of the error.\n\n\nTarget port set to the incorrect value\n\n\nIf your domain is using a \ntarget port\n, ensure that the target port for your public domain matches the port your application is listening on.\n\n\nThis setting can be found within your \nservice settings\n.\n\n\n\n\nIn the screenshot above, the domain was previously incorrectly configured with port 3000, when the application was actually listening on port 8080.\n\n\nApplication Not Listening on the Correct Host or Port\n\n\nYour web server should bind to the host \n0.0.0.0\n and listen on the port specified by the \nPORT\n environment variable, which Railway automatically injects into your application.\n\n\nStart your application's server using:\n\n\n\n\nHost = \n0.0.0.0\n\n\nPort = Value of the \nPORT\n environment variable provided by Railway.\n\n\n\n\nBelow are some solution examples for common languages and frameworks.\n\n\nNode / Express\n\n\n// Use PORT provided in environment or default to 3000\n\n\nconst\n port \n=\n process\n.\nenv\n.\nPORT\n \n||\n \n3000\n;\n\n\n\n\n// Listen on `port` and 0.0.0.0\n\n\napp\n.\nlisten\n(\nport\n,\n \n\"0.0.0.0\"\n,\n \nfunction\n \n(\n)\n \n{\n\n\n  \n// ...\n\n\n}\n)\n;\n\n\nNode / Nest\n\n\n// Use `PORT` provided in environment or default to 3000\n\n\nconst\n port \n=\n process\n.\nenv\n.\nPORT\n \n||\n \n3000\n;\n\n\n\n\n// Listen on `port` and 0.0.0.0\n\n\nasync\n \nfunction\n \nbootstrap\n(\n)\n \n{\n\n\n  \n// ...\n\n\n  \nawait\n app\n.\nlisten\n(\nport\n,\n \n\"0.0.0.0\"\n)\n;\n\n\n}\n\n\nNode / Next\n\n\nNext needs an additional flag to listen on \nPORT\n:\n\n\nnext start --port \n${PORT-3000}\n\n\nPython / Gunicorn\n\n\ngunicorn\n listens on \n0.0.0.0\n and the \nPORT\n environment variable by default:\n\n\ngunicorn main:app\n\n\nPython / Uvicorn\n\n\nuvicorn\n needs additional configuration flags to listen on \n0.0.0.0\n and \nPORT\n:\n\n\nuvicorn main:app --host \n0.0\n.0.0 --port \n$PORT\n\n\nGo / net/http\n\n\nThis example is for \nnet/http\n in the Go standard library, but you can also apply this to other frameworks:\n\n\nfunc\n \nmain\n(\n)\n \n{\n\n\n  \n// ...\n\n\n  \n// Use `PORT` provided in environment or default to 3000\n\n\n  port \n:=\n cmp\n.\nOr\n(\nos\n.\nGetenv\n(\n\"PORT\"\n)\n,\n \n3000\n)\n\n\n\n\n  log\n.\nFatal\n(\nhttp\n.\nListenAndServe\n(\n(\n\":\"\n \n+\n port\n)\n,\n handler\n)\n)\n\n\n  \n// ...\n\n\n}\n\n\nApplication Under Heavy Load\n\n\nIf you think your application could be under heavy load, you can confirm this by checking the \nMetrics\n tab within your service panel.\n\n\nFor example, if you are running a Node.js application, and see that your vCPU usage has peaked at any point to around 1 vCPU, this is a good indication that your application is under heavy load given Node's single-threaded nature.\n\n\nIf this is the case, you can scale your application horizontally to handle more requests.\n\n\nHorizontal scaling\n can easily be done by adding more instances to one or more regions.\nPrev\n \nErrors\nNext\n \nNo Start Command Could Be Found\nEdit this file on GitHub\nOn This Page\nWhat This Error Means\nWhy This Error Can Occur\nPossible Solutions\nTarget port set to the incorrect value\nApplication Not Listening on the Correct Host or Port\nNode / Express\nNode / Nest\nNode / Next\nPython / Gunicorn\nPython / Uvicorn\nGo / net/http\nApplication Under Heavy Load"
  },
  {
    "url": "https://docs.railway.app/reference/errors/enotfound-redis-railway-internal",
    "title": "ENOTFOUND redis.railway.internal | Railway Docs",
    "content": "ENOTFOUND redis.railway.internal\nWhat This Error Means\n\n\nThe error code \nENOTFOUND\n means that your application could not resolve the \nredis.railway.internal\n hostname to an IP address when trying to connect to the Redis database.\n\n\nWhy This Error Can Occur\n\n\nThis error can occur for a few different reasons, but the main reason is because your application uses the \nioredis\n package to connect to the Redis database, or uses a package that uses ioredis as a dependency such as \nbullmq\n.\n\n\nBy default, ioredis will only do an IPv4 (A record) lookup for the \nredis.railway.internal\n hostname.\n\n\nThat presents a problem given that Railway's private network uses only IPv6 (AAAA records).\n\n\nThe lookup will fail because the A records for \nredis.railway.internal\n do not exist.\n\n\nSome other reasons that this error can occur would be -\n\n\n\n\n\n\nYour application and Redis database are in different projects.\n\n\n\n\n\n\nYou are trying to connect to a Redis database locally with the private hostname and port.\n\n\n\n\n\n\nFor either of these reasons, the issue arises because the private network is scoped to a single environment within a \nproject\n, and would not be accessible from your local machine or other projects.\n\n\nIf the Redis database is in the same project as your application, and you are not trying to connect to a Redis database locally, \nioredis\n is the likely cause of the error.\n\n\nSolutions\n\n\nThe solution depends on the package you are using to connect to the Redis database, though the solution is the same for both.\n\n\nioredis\n\n\nUsing ioredis directly in your application\n\n\nioredis\n has an option to do a dual stack lookup, which will try to resolve the \nredis.railway.internal\n hostname using both IPv4 and IPv6 addresses (A and AAAA records).\n\n\nTo enable this, in your \nREDIS_URL\n environment variable, you can set the \nfamily\n to \n0\n to enable dual stack lookup.\n\n\nimport\n Redis \nfrom\n \n'ioredis'\n;\n\n\n\n\nconst\n redis \n=\n \nnew\n \nRedis\n(\nprocess\n.\nenv\n.\nREDIS_URL\n \n+\n \n'?family=0'\n)\n;\n\n\n\n\nconst\n ping \n=\n \nawait\n redis\n.\nping\n(\n)\n;\n\n\nUsing bullmq\n\n\nSimilarly, for \nbullmq\n since it uses \nioredis\n as a dependency, you can set the \nfamily\n option to \n0\n in your connection object.\n\n\nimport\n \n{\n Queue \n}\n \nfrom\n \n\"bullmq\"\n;\n\n\n\n\nconst\n redisURL \n=\n \nnew\n \nURL\n(\nprocess\n.\nenv\n.\nREDIS_URL\n)\n;\n\n\n\n\nconst\n queue \n=\n \nnew\n \nQueue\n(\n\"Queue\"\n,\n \n{\n\n\n    \nconnection\n:\n \n{\n\n\n        \nfamily\n:\n \n0\n,\n\n\n        \nhost\n:\n redisURL\n.\nhostname\n,\n\n\n        \nport\n:\n redisURL\n.\nport\n,\n\n\n        \nusername\n:\n redisURL\n.\nusername\n,\n\n\n        \npassword\n:\n redisURL\n.\npassword\n\n    \n}\n\n\n}\n)\n;\n\n\n\n\nconst\n jobs \n=\n \nawait\n queue\n.\ngetJobs\n(\n)\n;\n\n\n\n\nconsole\n.\nlog\n(\njobs\n)\n;\n\n\nOther packages\n\n\nAbove we covered the two most common packages that can cause this error, but there are other packages that use \nioredis\n as a dependency that may also cause this error.\n\n\nIf you are using a package that uses \nioredis\n as a dependency, you can try to find a way to set the \nfamily\n option to \n0\n either in your connection object or in your \nREDIS_URL\n environment variable. Similar to the examples above.\n\n\nRedis database in a different project\n\n\nCreate a \nnew Redis database\n in the same \nproject\n as your application, and connect it to the Redis database using the private network as shown in the examples above.\n\n\nRead about best pracices to get the most out of the platform \nhere\n.\n\n\nConnecting to a Redis database locally\n\n\nThe easiest way to connect to a Redis database locally is to use the public network.\n\n\nYou can do this is by using the \nREDIS_PUBLIC_URL\n environment variable to connect to the Redis database.\n\n\nimport\n Redis \nfrom\n \n'ioredis'\n;\n\n\n\n\nconst\n redis \n=\n \nnew\n \nRedis\n(\nprocess\n.\nenv\n.\nREDIS_PUBLIC_URL\n)\n;\n\n\n\n\nconst\n ping \n=\n \nawait\n redis\n.\nping\n(\n)\n;\nNext\n \nHome\nEdit this file on GitHub\nOn This Page\nWhat This Error Means\nWhy This Error Can Occur\nSolutions\nioredis\nUsing ioredis directly in your application\nUsing bullmq\nOther packages\nRedis database in a different project\nConnecting to a Redis database locally"
  },
  {
    "url": "https://docs.railway.app/reference/errors/nixpacks-was-unable-to-generate-a-build-plan",
    "title": "Nixpacks Was Unable to Generate a Build Plan for This App | Railway Docs",
    "content": "Nixpacks Was Unable to Generate a Build Plan for This App\nWhat This Error Means\n\n\nRailway uses \nNixpacks\n to analyze your application's files to generate a container image for your application.\n\n\nSeeing the \nNixpacks was unable to generate a build plan for this app\n error means that Nixpacks was unable to corelate your application's files with a supported build plan.\n\n\nA build plan is a set of pre defined instructions that Nixpacks uses to build and run your application on the Railway platform.\n\n\nA list of supported build plans can be found \nhere\n under the \nLanguage Support\n section.\n\n\nWhy This Error Can Occur\n\n\nThis error can occur for a variety of reasons, here are some common ones and what the failed build logs could look like for each scenario -\n\n\n\n\n\n\nYou are attempting to deploy a monorepo.\n\n\nThe contents of the app directory are:\n\n\n\n/frontend\n\n/backend\n\n\nNixpacks doesn't know which directory you want to deploy from.\n\n\n\n\n\n\nYour application's files and or directory structure do not match any of the supported build plans.\n\n\nThe contents of the app directory are:\n\n\n\nweb.py\n\nrequirements.txt\n\n\nThis is obviously Python, a supported language, but Nixpacks doesn't know exactly to do with just a \nweb.py\n file since it was never explicitly programmed to handle this.\n\n\n\n\n\n\nYour application is using a language or framework that is not supported by Nixpacks.\n\n\nThe contents of the app directory are:\n\n\n\nmain.nim\n\nnimble.nimble\n\n\nThis is \nNim\n, but unfortunately, Nixpacks doesn't have a build plan for Nim.\n\n\n\n\n\n\nPossible Solutions\n\n\nMonorepo Without Root Directory\n\n\nIf you are attempting to deploy a monorepo, you will need to set a \nroot directory\n in your \nservice settings\n under the source repository section.\n\n\nFor a comprehensive guide on how to deploy a monorepo, please refer to our \nDeploying a Monorepo\n guide.\n\n\nUnsupported Project Layout or Directory Structure\n\n\nWhile you may be using a language or framework that is supported by Nixpacks, the project layout or directory structure of your application may not be natively supported.\n\n\nFor example, if you are using Python but Python was not automatically detected, you can write your own \nbuild plan\n.\n\n\nIn a \nnixpacks.toml\n file -\n\n\nproviders\n \n=\n \n[\n\"python\"\n]\n \n# Tell Nixpacks to use the Python build plan\n\n\n\n\n[\nstart\n]\n\n\ncmd\n \n=\n \n\"python web.py\"\n \n# Tell Nixpacks to start your web.py file\n\n\nOf course, this is just an example, but you can see how you can write your own build plan to support your application.\n\n\nSupported Languages (Providers) can be found \nhere\n under the \nLanguage Support\n section.\n\n\nIf writing your own build plan is not an option, you can try to deploy your application using a \nDockerfile\n.\n\n\nLanguage or Framework Not Supported\n\n\nIf you believe your application should be supported, please \ncreate an issue\n on the Nixpacks GitHub repository.\n\n\nTo unblock yourself, you can try to deploy your application using a \nDockerfile\n.\n\n\nIf your project contains a \nDockerfile\n Railway will automatically use it to build your application.\n\n\nRead more about \nusing a Dockerfile\n.\nNext\n \nHome\nEdit this file on GitHub\nOn This Page\nWhat This Error Means\nWhy This Error Can Occur\nPossible Solutions\nMonorepo Without Root Directory\nUnsupported Project Layout or Directory Structure\nLanguage or Framework Not Supported"
  },
  {
    "url": "https://docs.railway.app/reference/errors/no-start-command-could-be-found",
    "title": "No Start Command Could be Found | Railway Docs",
    "content": "No Start Command Could be Found\nWhat This Error Means\n\n\nRailway uses \nNixpacks\n to analyze your application's files to generate a container image for your application.s\n\n\nSeeing the \nNo start command could be found\n error means that \nNixpacks\n was unable to automatically find an appropriate start command for your application.\n\n\nA start command is a command that will be executed by Railway to run your application.\n\n\nWhy This Error Can Occur\n\n\nBy default, Railway uses \nNixpacks\n to build and run your application. Nixpacks will try its best to find an appropriate start command for your application.\n\n\nSome limited examples of start commands that Nixpacks will try are -\n\n\nFor Node based apps it will try to use \nnpm start\n, \nyarn start\n, \npnpm start\n, or \nbun start\n if a start script is present in your \npackage.json\n file.\n\n\nFor Python apps it will try to use \npython main.py\n if a \nmain.py\n file is present, or \npython manage.py migrate && gunicorn {app_name}.wsgi\n if a Django application is detected.\n\n\nFor Ruby apps it will try to use \nbundle exec rails server -b 0.0.0.0\n if a Rails application is detected.\n\n\nFailing the automatic detection, Nixpacks will return the \nNo start command could be found\n error.\n\n\nPossible Solutions\n\n\nSince Nixpacks was unable to find a start command, you will need to specify a start command yourself.\n\n\nYou can do this in the \nservice settings\n under the \nStart Command\n field.\n\n\nSome common start commands for various frameworks and languages are -\n\n\nNode.js\n\n\nnode\n main.js\n\n\nWhere \nmain.js\n is the entry point for your application, could be \nindex.js\n, \nserver.js\n, \napp.js\n, etc.\n\n\nNext.js\n\n\nnpx next start --port \n$PORT\n\n\nNote: The \n--port\n flag is needed to ensure that Next.js listens on the correct port.\n\n\nNuxt.js\n\n\nnode\n .output/server/index.mjs\n\n\nThis will run Nuxt.js in production mode using its built-in Nitro server.\n\n\nFastAPI\n\n\nuvicorn main:app --host \n0.0\n.0.0 --port \n$PORT\n\n\nWhere \nmain\n is the name of the file that contains the \napp\n variable from FastAPI.\n\n\nNote: The \n--host\n and \n--port\n flags are needed to ensure that FastAPI listens on the correct host and port.\n\n\nFlask\n\n\ngunicorn main:app\n\n\nWhere \nmain\n is the name of the file that contains the \napp\n variable from Flask.\n\n\nDjango\n\n\ngunicorn myproject.wsgi\n\n\nWhere \nmyproject\n is the name of the folder that contains your \nwsgi.py\n file.\n\n\nRuby on Rails\n\n\nbundle \nexec\n rails server -b \n0.0\n.0.0 -p \n$PORT\n\n\nNote: The \n-b\n and \n-p\n flags are needed to ensure that Rails listens on the correct host and port.\n\n\nVite\n\n\nserve --single --listen \n$PORT\n dist\n\n\nNote: The \nserve\n command is needed to serve the static site files and can be installed by running \nnpm install serve\n locally.\n\n\nCreate React App\n\n\nserve --single --listen \n$PORT\n build\n\n\nNote: The \nserve\n command is needed to serve the static site files and can be installed by running \nnpm install serve\n locally.\nPrev\n \nApplication Failed to Respond\nNext\n \n405 Method Not Allowed\nEdit this file on GitHub\nOn This Page\nWhat This Error Means\nWhy This Error Can Occur\nPossible Solutions\nNode.js\nNext.js\nNuxt.js\nFastAPI\nFlask\nDjango\nRuby on Rails\nVite\nCreate React App"
  },
  {
    "url": "https://docs.railway.app/reference/healthchecks",
    "title": "Healthchecks | Railway Docs",
    "content": "Healthchecks\nHealthchecks can be used to guarantee zero-downtime \ndeployments\n of your \nservice\n by ensuring the new version is live and able to handle requests.\n\n\nHow it Works\n\n\nWhen a new deployment is triggered for a service, if a healthcheck endpoint is configured, Railway will query the endpoint until it receives an HTTP \n200\n response.  Only then will the new deployment be made active and the previous deployment inactive.\n\n\nNote About Continuous Monitoring\n\n\nThe healthcheck endpoint is currently \nnot intended for continuous monitoring\n as it is only called at the start of the deployment, to ensure it is healthy prior to routing traffic to it.\n\n\nIf you are looking for a quick way to setup continuous monitoring of your service(s), check out the \nUptime Kuma template\n in our template marketplace.\n\n\nHealthcheck Timeout\n\n\nThe default timeout on healthchecks is 300 seconds (5 minutes). If your application fails to serve a \n200\n status code during this allotted time, the deploy will be marked as failed.\n\n\nThis timeout is configurable in the service settings.\n\n\nSupport\n\n\nFor information on how to configure healthchecks, click \nhere\n.\nPrev\n \nDockerfiles\nNext\n \nBackups\nEdit this file on GitHub\nOn This Page\nHow it Works\nNote About Continuous Monitoring\nHealthcheck Timeout\nSupport"
  },
  {
    "url": "https://docs.railway.app/reference/metrics",
    "title": "Metrics | Railway Docs",
    "content": "Metrics\nRailway provides resource usage information on deployments within a service, which can be used to diagnose issues with a project's performance.\n\n\nHow it Works\n\n\nFor each service, Railway captures metric data. These metrics are then made available in graphs within a service's panel, under the metrics tab.\n\n\nHow it works - with multiple replicas\n\n\nWhen a service has multiple replicas, the metrics from all replicas are summed up and displayed in the metrics tab, for example, if you have 2 replicas, each using 100 MB of memory, the memory usage displayed in the metrics tab will be 200 MB.\n\n\nProvided Metrics\n\n\nThe following metrics are provided:\n\n\n\n\nCPU\n\n\nMemory\n\n\nDisk Usage\n\n\nNetwork\n\n\n\n\nViewing Metrics\n\n\nFor information on how to view and read metrics, visit \nthis guide\n.\nPrev\n \nLogging\nNext\n \nWebhooks\nEdit this file on GitHub\nOn This Page\nHow it Works\nHow it works - with multiple replicas\nProvided Metrics\nViewing Metrics"
  },
  {
    "url": "https://docs.railway.app/reference/migrate-to-railway-metal",
    "title": "Migrate to Railway Metal | Railway Docs",
    "content": "Migrate to Railway Metal\nThis page will describe in detail the migration process when a service moves to Railway Metal.\n\n\nWe will cover: how to initiate a migration, how to best prepare for a migration, and what mechanically happens when you initiate a migration of your services to Railway Metal.\n\n\nWhat is Railway Metal?\n\n\nRailway Metal is the next generation of Railway's underlying infrastructure. It is built on hardware that we own and operate in datacenters around the world. You can get more information about Railway Metal on the parent \ndocumentation page here.\n\n\nWe announced on December 26th that we would be moving users to Railway Metal over a 6 month migration timeline.\n\n\nWe expect all user workloads to be on Railway Metal by July 4th, 2025.\n\n\nRailway is \ncurrently\n initating migrations of user workloads to Railway Metal regions at off-peak times per region.\n\n\nAs such, we advise our customers to move all of their workloads to Railway Metal to avoid Railway initiated downtime.\n\n\nWhat does a migration to Railway Metal entail?\n\n\nA migration to Railway Metal is just like any deployment on Railway that would happen if you changed the region setting to a different value.\n\n\nRailway is built region agnostically, meaning, the choice of region doesn't impact the availibility of products or features depending on the region. In doing so, user workloads can be deployed into different geographic regions at will.\n\n\nA migration to Railway Metal is a simple region change.\n\n\nFor Stateless deployments, meaning, a deployment with no volume- there is no downtime. Stateless deployments are just landing into a new region.\n\n\nFor services with a volume attached, or Stateful deployments, there is a brief 30-45 second period of downtime as the volume re-mounts into the new deployment. \nThis is exactly the same as the existing cross region deployment functionality that exists in Railway today.\n\n\nInitiating a migration\n\n\nYou can initate a migration by selecting a region in the service settings pane with any label that has: \nMetal (New)\n\n\nAfter you select the region, you will get the Staged Change anchored modal at the center top position of the project canvas.\n\n\nBy pressing: \"Deploy\", you initiate a migration to Railway Metal.\n\n\nWhat happens when my service is migrating?\n\n\nWhen you change the value of the region within the service settings page, Railway is told to deploy into that region when the environment applies the staged change. In Railway's system, we process a deployment request from our queue triggering a build.\n\n\nDepending on if the service is Stateful or Stateless- we then initiate one of two bespoke migration processes.\n\n\nFor Stateless:\n Railway rebuilds your application onto our Metal region, and after the container image is built, then is landed on a running host in one of our datacenters.\n\n\nFor Stateful:\n Railway detects if a volume is mounted to your service, if a volume is detected, Railway initates a volume migration and holds the deployment until the volume is ready to be mounted within the new region. The process is as follows:\n\n\n\n\nRailway initates a backup of the volume for internal and customer use.\n\n\nRailway makes the backup of the volume accessible on the project canvas in the original region.\n\n\nRailway then copies the volume into the new region.\n\n\n(Optional) If there are backups in the volume, we also copy those backups into the new region. \nDepending on the number and size of backups, this incurs a time penalty on the migration.\n\n\nRailway then confirms the integrity of data.\n\n\nRailway attempts a build of the deployment after the volume is confirmed to be accessible in the new region.\n\n\nRailway mounts to the volume in the new region after a successful build.\n\n\n\n\nDuring the process, as of 2025/05/13 - Railway is able to report the transfer speed and progress of the volume migration to users.\n\n\nWhat happens to writes on the DB on migrations that I initated?\n\n\nBecause Railway is copying the volume primitive using the same primitive that we use for the volume backup feature, writes persist until we unmount the running deployment of the DB. As such, you don't need to plan for downtime of your database except for the 30 to 40 seconds when a deployment remounts into the database.\n\n\nPreparing for migration\n\n\nFor production applications on Railway, we advise customers to make sure your service has configuration to ensure it's online between deployments. Railway by default, attempts to only deploy a new instance of your service only when your application is live and healthy. However, there are a number of additional measures you can take to increase resilience.\n\n\nBefore initiating a migration we recommend that users configure the following:\n\n\n\n\nHealthchecks\n\n\nBuild and start commands\n\n\nVolume Backups\n\n\nDeployment overlap\n\n\n\n\nConfigured by setting \nRAILWAY_DEPLOYMENT_OVERLAP_SECONDS\n within the Railway service variable settings\n\n\n\n\n\n\n\n\nWe also advise users to make sure that:\n\n\n\n\nData is being written to disk instead of the ephermeral container storage\n\n\n\n\nIf unsure, you can check by SSHing into the container via the Railway CLI and running \nls\n on the mount point.\n\n\n\n\n\n\nOn your DB, that the version is pinned to a major version instead of \n:latest\n on the image source\n\n\nYou are able to backup and restore your data\n\n\nYou test in a development environment before you migrate your production environment\n\n\n\n\nRailway is not responsible for data loss that occurs on re-deployment for data on the container's ephermeral disk.\n\n\nPost-migration\n\n\nThe Railway team throughout this period is checking in with all customers to ensure:\n\n\n\n\nThey recieve their Metal seat discount\n\n\nApplication performance is within customer expectations\n\n\nA great experience migrating with adequate communication\n\n\n\n\nRollback\n\n\nIf you encounter any issues with your service after a Railway initated upgrade, you can\nrollback to the previous version by clicking \nRollback\n button in the banner\nabove.\n\n\n\n\nManual rollback\n\n\nTo rollback manually, modify your service's \nSettings -> Deploy -> Regions\n\nand select regions without the \nMetal (New)\n tag.\n\n\n\n\nThe Railway team during this period has doubled the amount of staffing around on-call and support to ensure this transition goes smoothly for our users.\n\n\nAny issues, comments, and concerns- \nraise a thread on Station.\nPrev\n \nAWS Marketplace\nNext\n \nProduction Readiness Checklist\nEdit this file on GitHub\nOn This Page\nWhat is Railway Metal?\nWhat does a migration to Railway Metal entail?\nInitiating a migration\nWhat happens when my service is migrating?\nWhat happens to writes on the DB on migrations that I initated?\nPreparing for migration\nPost-migration\nRollback\nManual rollback"
  },
  {
    "url": "https://docs.railway.app/reference/nixpacks",
    "title": "Nixpacks | Railway Docs",
    "content": "Nixpacks\nRailway uses \nNixpacks\n to build and deploy your code with\nzero configuration.\n\n\nSupported Languages\n\n\nCurrently, we support the following languages out of the box:\n\n\n\n\nBun\n (Experimental)\n\n\nClojure\n\n\nCobol\n\n\nCrystal\n\n\nC#/.NET\n\n\nDart\n\n\nDeno\n\n\nElixir\n\n\nF#\n\n\nGleam\n\n\nGo\n\n\nHaskell\n\n\nJava\n\n\nLunatic\n\n\nNode\n\n\nPHP\n\n\nPython\n\n\nRuby\n\n\nRust\n\n\nScheme\n\n\nStaticfile\n\n\nSwift\n\n\nScala\n\n\nZig\n\n\n\n\nThe Build Table / Build Plan\n\n\nWhen Railway builds your app with Nixpacks a Build Plan will be printed \nat the top\n of the build logs.\n\n\nThis table displays a list of packages and commands that will be used in the build (and start) process for your application.\n\n\n\n\nSupport\n\n\nIf you have a language or feature that you want us to support, please don't hesitate to\nreach out on \nDiscord\n or on the \nNixpacks repo\n.\nPrev\n \nIntegrations\nNext\n \nPrivate Networking\nEdit this file on GitHub\nOn This Page\nSupported Languages\nThe Build Table / Build Plan\nSupport"
  },
  {
    "url": "https://docs.railway.app/reference/pricing",
    "title": "Pricing Plans | Railway Docs",
    "content": "Pricing Plans\nRailway plans and pricing are designed to give you maximum resources while only charging you for your usage. We charge a base subscription price, which goes towards your resources and usage.\n\n\n\n\nNEW\n Effective March 3rd, 2025, Railway is updating its pricing structure with reduced rates for network egress and volume storage, along with new benefits for Metal instance users.\n\n\n\n\nPlans\n\n\nRailway offers three plans in addition to a \nFree Trial\n:\n\n\nHobby\nFor indie hackers and developers to build and deploy personal projects\nPro\nFor professional developers and their teams shipping to production\nEnterprise\nFor teams building and deploying production applications with the need for enterprise features related to compliance, SLAs, and account management\n\n\nSubscription Pricing\n\n\nEach Railway account needs an active subscription. The base subscription fee allows you to use the Railway platform and features included in the tier of your subscription. The subscription fee goes towards your usage-costs on the platform.\n\n\nPlan\nPrice\nHobby\n$5 / month\nPro\n$20 / month\nEnterprise\nCustom\n\n\n\n\nNote:\n For users with at least 80 percent usage on Railway hosted metal instances, all seat costs will be waived.\n\n\n\n\nRead more about our plans at \nrailway.com/pricing\n.\n\n\nDefault Plan Resources\n\n\nDepending on the plan you are on, you are allowed to use up these resources per service.\n\n\nPlan\nRAM\nCPU\nEphemeral Storage\nVolume Storage\nImage Size\nTrial\n0.5 GB\n2 vCPU\n1 GB\n0.5 GB\n4 GB\nHobby\n8 GB\n8 vCPU\n10 GB\n5 GB\n100 GB\nPro\n32 GB\n32 vCPU\n100 GB\n50 GB**\n100 GB\nEnterprise\n64 GB\n64 vCPU\n100 GB\n2 TB**\n100 GB\n\n\nNote that these are initial values and users on the Pro and Enterprise plans can request limit increases.\n\n\n**For Volumes, Pro users and above can self-serve to increase their volume up to 250 GB. Check out \nthis guide\n for information.\n\n\nResource Usage Pricing\n\n\nOn top of the base subscription fee above, Railway charges for the resources that you consume.\n\n\nYou are only charged for the resources you actually use, which helps prevent runaway cloud costs and provides assurances that you're always getting the best deal possible on your cloud spend.\n\n\nResource\nResource Price\nRAM\n$10 / GB / month ($0.000231 / GB / minute)\nCPU\n$20 / vCPU / month ($0.000463 / vCPU / minute)\nNetwork Egress\n$0.05 / GB ($0.000000047683716 / KB)\nVolume Storage\n$0.15 / GB / month ($0.000003472222222 / GB / minute)\n\n\nTo learn more about controlling your resource usage costs, read our FAQ on \nHow do I prevent spending more than I want to?\n\n\nIncluded Usage\n\n\nThe Hobby plan includes $5 of resource usage per month.\n\n\nIf your total resource usage at the end of your billing period is $5 or less, you will not be charged for resource usage. If your total resource usage exceeds $5 in any given billing period, you will be charged the delta.\n\n\nIncluded resource usage is reset at the end of every billing cycle and does not accumulate over time.\n\n\nExamples\n:\n\n\n\n\nIf your resource usage is $3, your total bill for the cycle will be $5. You are only charged the subscription fee because your resource usage is below $5 and therefore included in your subscription\n\n\nIf your resource usage is $7, your total bill for the cycle will be $7 ($5 subscription fee + $2 of usage), because your resource usage exceeds the included resource usage\n\n\n\n\nThe Pro plan \ndoes not include any usage credits\n. You will be billed for resource usage on top of the full subscription fee.\n\n\nAdditional Services\n\n\nRailway offers \nBusiness Class Support\n as an add-on service to the Pro plan. Business Class Support is included with Enterprise. \nContact us\n to get started.\n\n\nCommitted Spend Tiers\n\n\nRailway offers committed spend tiers for customers with consistent usage needs. Instead of negotiated contract pricing, customers can commit to a specific monthly spend level to unlock additional features and services.\n\n\nFor example, customers who commit to a $10,000/month spend rate can access dedicated hosts, with all pricing going towards their usage. This approach provides more flexibility and transparency compared to traditional contract pricing.\n\n\nFeature\nCommitment Spend\nDescription\n2 TB RAM / 112 vCPU\n$500/month\nAccess to increased computing resources at a committed monthly spend level.\nRBAC\n$500/month\nRole-Based Access Control to manage user permissions and access.\nSLOs\n$500/month\nService Level Objectives to ensure and track application performance.\n90-day log history\n$500/month\nExtended log retention for better historical analysis and auditing.\nBusiness Class Support\n$500/month\nImproved support SLOs and response times. \nContact us\n to get started.\nHIPAA BAAs\n$1,000/month\nHIPAA Business Associate Agreements for compliant health data handling. Requires a year commitment paid monthly.\nDedicated Hosts\n$10,000/month\nCustom dedicated infrastructure for enhanced performance and control.\n\n\nTo learn more about committed spend tiers, please \ncontact our team\n.\n\n\nPurchasing Credits\n\n\nIf you are already on the Pre-Paid plan, you can purchase credits from your Workspace's \nUsage page\n.\n\n\nOne-time Grant of Credits on the Free Trial\n\n\nUsers who create a new Trial account receive a free one-time grant of $5. Railway will expend any free credit before consuming any purchased credits. Trial plan users are unable to purchase credits without upgrading to the Hobby plan.\n\n\nLearn more about Railway's Free Trial \nhere\n.\n\n\nPartial Month Charges\n\n\nIn some cases, your billing method may be charged for the partial amount of your bill earlier in the billing cycle.\nThis ensures that your account remains in good standing, and helps us mitigate risk and fraud.\n\n\nFAQs\n\n\nWhich plan is right for me?\n\n\n\n\nHobby\n is for indie hackers and developers to build and deploy personal projects\n\n\nPro\n is for professional developers and their teams shipping to production\n\n\nEnterprise\n is for dev teams building and deploying production applications with the need for enterprise features related to compliance, SLAs, and account management\n\n\n\n\nCan I upgrade or downgrade at any time?\n\n\nYou can upgrade any time, and when you do, you will get to the features of your new plan, as well as access to more powerful resources, immediately. When you downgrade, the changes will take effect at the beginning of your next billing cycle.\n\n\nWhat is the difference between subscription and resource usage?\n\n\nThere are two main components to your bill:\n\n\nComponent\nDescription\nSubscription\nCost of the plan you're on: \n[cost per seat] x [purchased seats]\nResource Usage\nCost of the resources you've consumed: \n[cost per unit] x [used units]\n\n\nSubscription is a flat fee you pay monthly for the tier you're subscribed to, and Resource Usage varies according to your resource consumption for the month.\n\n\nCan I add collaborators to my project?\n\n\nRailway's Pro and Enterprise plans are designed for collaboration. These plans allow you to add members to your team and manage their permissions.\n\n\nRead more about adding members to your Pro or Enterprise team \nhere\n.\n\n\nHow long does Railway keep my volume data if I am no longer on a paid plan?\n\n\nFor Trial, Railway will delete your volumes 30 days after your Trial credits runout.\n\n\nFor Hobby and Pro, Railway will retain your volumes for 90 days and then delete them from the platform after sufficient warning.\n\n\nIs the Hobby Plan free?\n\n\nNo. The Hobby Plan is $5 a month, and it includes a resource usage credit of $5. Even if you do not use the $5 in usage (CPU, Memory, egress), you always pay the $5 subscription fee.\n\n\nCan I get the Hobby plan subscription fee waived?\n\n\nRailway waives the monthly Hobby plan subscription fee for a small set of active builders on the platform.\n\n\nEligibility is automatically assessed based on several factors, including your usage on the platform, your GitHub account, and more. If you qualify, you will be notified in the Dashboard or when you upgrade to the Hobby plan. If you do not qualify, you will not be eligible for the waiver.\n\n\nThis is a fully automated process, and Railway does not respond to requests for waiver.\n\n\nI prefer to prepay. Is that possible?\n\n\nNot anymore as of March 30th, Railway requires the use of a post-paid card.\n\n\nWhat happens if I use credits as a payment method and my account runs out of credits?\n\n\nIf you are using credits as a payment method and your credit balance reaches zero, your subscription will be cancelled. You will no longer be able to deploy to Railway and we will stop all of your workloads. To resolve this, you will need to sign up for a new subscription after topping up sufficient credits.\n\n\nWhy was I charged for a partial month of usage?\n\n\nRailway has an automated system in place which can result in a partial amount of your bill being charged to your payment method, earlier in the billing cycle.\n\n\nThis is intended to ensure that your account remains in good standing, and helps us to mitigate risk and fraud.\nPrev\n \nTemplates\nNext\n \nFree Trial\nEdit this file on GitHub\nOn This Page\nPlans\nSubscription Pricing\nDefault Plan Resources\nResource Usage Pricing\nIncluded Usage\nAdditional Services\nCommitted Spend Tiers\nPurchasing Credits\nOne-time Grant of Credits on the Free Trial\nPartial Month Charges\nFAQs\nWhich plan is right for me?\nCan I upgrade or downgrade at any time?\nWhat is the difference between subscription and resource usage?\nCan I add collaborators to my project?\nHow long does Railway keep my volume data if I am no longer on a paid plan?\nIs the Hobby Plan free?\nCan I get the Hobby plan subscription fee waived?\nI prefer to prepay. Is that possible?\nWhat happens if I use credits as a payment method and my account runs out of credits?\nWhy was I charged for a partial month of usage?"
  },
  {
    "url": "https://docs.railway.app/reference/pricing/aws-marketplace",
    "title": "AWS Marketplace | Railway Docs",
    "content": "AWS Marketplace\nRailway is available through the AWS Marketplace, allowing you to purchase and manage Railway through your AWS account.\n\n\nOffering\n\n\nRailway offers solutions, peering templates and deployment to AWS- while using your AWS vendor relationship. For large Enterprises, Railway can be an option for large engineering teams to significantly reduce operational overhead.\n\n\nPricing Structure\n\n\nPricing for Railway through AWS Marketplace is based on contract duration. You can pay upfront or in installments according to your contract terms with the vendor. The contract includes:\n\n\n\n\nA specified quantity of usage for the contract duration\n\n\nUsage-based pricing for any usage exceeding the entitled amount\n\n\nAdditional charges applied on top of the contract price for overages\n\n\n\n\nContract Terms\n\n\n12-Month Contract\n\n\nThe standard offering is a 12-month contract with the following terms:\n\n\n\n\nBase price: $10,000.00 per 12 months\n\n\nOverage rate: $1.00 per unit\n\n\nPrivate pricing agreements available through the Railway sales team\n\n\n\n\nRefund Policy\n\n\nAll fees are non-refundable and non-cancellable except as required by law.\n\n\nGetting Started\n\n\nTo purchase Railway through AWS Marketplace:\n\n\n\n\nVisit the Railway listing on AWS Marketplace\n\n\nClick \"View purchase options\"\n\n\nContact the Railway sales team\n\n\nComplete the purchase through your AWS account\n\n\n\n\nSupport\n\n\nFor questions about AWS Marketplace purchases or to discuss private pricing agreements, \nplease contact our sales team.\nPrev\n \nRefunds\nNext\n \nMigrate to Railway Metal\nEdit this file on GitHub\nOn This Page\nOffering\nPricing Structure\nContract Terms\n12-Month Contract\nRefund Policy\nGetting Started\nSupport"
  },
  {
    "url": "https://docs.railway.app/reference/pricing/plans",
    "title": "Pricing Plans | Railway Docs",
    "content": "Pricing Plans\nRailway plans and pricing are designed to give you maximum resources while only charging you for your usage. We charge a base subscription price, which goes towards your resources and usage.\n\n\n\n\nNEW\n Effective March 3rd, 2025, Railway is updating its pricing structure with reduced rates for network egress and volume storage, along with new benefits for Metal instance users.\n\n\n\n\nPlans\n\n\nRailway offers three plans in addition to a \nFree Trial\n:\n\n\nHobby\nFor indie hackers and developers to build and deploy personal projects\nPro\nFor professional developers and their teams shipping to production\nEnterprise\nFor teams building and deploying production applications with the need for enterprise features related to compliance, SLAs, and account management\n\n\nSubscription Pricing\n\n\nEach Railway account needs an active subscription. The base subscription fee allows you to use the Railway platform and features included in the tier of your subscription. The subscription fee goes towards your usage-costs on the platform.\n\n\nPlan\nPrice\nHobby\n$5 / month\nPro\n$20 / month\nEnterprise\nCustom\n\n\n\n\nNote:\n For users with at least 80 percent usage on Railway hosted metal instances, all seat costs will be waived.\n\n\n\n\nRead more about our plans at \nrailway.com/pricing\n.\n\n\nDefault Plan Resources\n\n\nDepending on the plan you are on, you are allowed to use up these resources per service.\n\n\nPlan\nRAM\nCPU\nEphemeral Storage\nVolume Storage\nImage Size\nTrial\n0.5 GB\n2 vCPU\n1 GB\n0.5 GB\n4 GB\nHobby\n8 GB\n8 vCPU\n10 GB\n5 GB\n100 GB\nPro\n32 GB\n32 vCPU\n100 GB\n50 GB**\n100 GB\nEnterprise\n64 GB\n64 vCPU\n100 GB\n2 TB**\n100 GB\n\n\nNote that these are initial values and users on the Pro and Enterprise plans can request limit increases.\n\n\n**For Volumes, Pro users and above can self-serve to increase their volume up to 250 GB. Check out \nthis guide\n for information.\n\n\nResource Usage Pricing\n\n\nOn top of the base subscription fee above, Railway charges for the resources that you consume.\n\n\nYou are only charged for the resources you actually use, which helps prevent runaway cloud costs and provides assurances that you're always getting the best deal possible on your cloud spend.\n\n\nResource\nResource Price\nRAM\n$10 / GB / month ($0.000231 / GB / minute)\nCPU\n$20 / vCPU / month ($0.000463 / vCPU / minute)\nNetwork Egress\n$0.05 / GB ($0.000000047683716 / KB)\nVolume Storage\n$0.15 / GB / month ($0.000003472222222 / GB / minute)\n\n\nTo learn more about controlling your resource usage costs, read our FAQ on \nHow do I prevent spending more than I want to?\n\n\nIncluded Usage\n\n\nThe Hobby plan includes $5 of resource usage per month.\n\n\nIf your total resource usage at the end of your billing period is $5 or less, you will not be charged for resource usage. If your total resource usage exceeds $5 in any given billing period, you will be charged the delta.\n\n\nIncluded resource usage is reset at the end of every billing cycle and does not accumulate over time.\n\n\nExamples\n:\n\n\n\n\nIf your resource usage is $3, your total bill for the cycle will be $5. You are only charged the subscription fee because your resource usage is below $5 and therefore included in your subscription\n\n\nIf your resource usage is $7, your total bill for the cycle will be $7 ($5 subscription fee + $2 of usage), because your resource usage exceeds the included resource usage\n\n\n\n\nThe Pro plan \ndoes not include any usage credits\n. You will be billed for resource usage on top of the full subscription fee.\n\n\nAdditional Services\n\n\nRailway offers \nBusiness Class Support\n as an add-on service to the Pro plan. Business Class Support is included with Enterprise. \nContact us\n to get started.\n\n\nCommitted Spend Tiers\n\n\nRailway offers committed spend tiers for customers with consistent usage needs. Instead of negotiated contract pricing, customers can commit to a specific monthly spend level to unlock additional features and services.\n\n\nFor example, customers who commit to a $10,000/month spend rate can access dedicated hosts, with all pricing going towards their usage. This approach provides more flexibility and transparency compared to traditional contract pricing.\n\n\nFeature\nCommitment Spend\nDescription\n2 TB RAM / 112 vCPU\n$500/month\nAccess to increased computing resources at a committed monthly spend level.\nRBAC\n$500/month\nRole-Based Access Control to manage user permissions and access.\nSLOs\n$500/month\nService Level Objectives to ensure and track application performance.\n90-day log history\n$500/month\nExtended log retention for better historical analysis and auditing.\nBusiness Class Support\n$500/month\nImproved support SLOs and response times. \nContact us\n to get started.\nHIPAA BAAs\n$1,000/month\nHIPAA Business Associate Agreements for compliant health data handling. Requires a year commitment paid monthly.\nDedicated Hosts\n$10,000/month\nCustom dedicated infrastructure for enhanced performance and control.\n\n\nTo learn more about committed spend tiers, please \ncontact our team\n.\n\n\nPurchasing Credits\n\n\nIf you are already on the Pre-Paid plan, you can purchase credits from your Workspace's \nUsage page\n.\n\n\nOne-time Grant of Credits on the Free Trial\n\n\nUsers who create a new Trial account receive a free one-time grant of $5. Railway will expend any free credit before consuming any purchased credits. Trial plan users are unable to purchase credits without upgrading to the Hobby plan.\n\n\nLearn more about Railway's Free Trial \nhere\n.\n\n\nPartial Month Charges\n\n\nIn some cases, your billing method may be charged for the partial amount of your bill earlier in the billing cycle.\nThis ensures that your account remains in good standing, and helps us mitigate risk and fraud.\n\n\nFAQs\n\n\nWhich plan is right for me?\n\n\n\n\nHobby\n is for indie hackers and developers to build and deploy personal projects\n\n\nPro\n is for professional developers and their teams shipping to production\n\n\nEnterprise\n is for dev teams building and deploying production applications with the need for enterprise features related to compliance, SLAs, and account management\n\n\n\n\nCan I upgrade or downgrade at any time?\n\n\nYou can upgrade any time, and when you do, you will get to the features of your new plan, as well as access to more powerful resources, immediately. When you downgrade, the changes will take effect at the beginning of your next billing cycle.\n\n\nWhat is the difference between subscription and resource usage?\n\n\nThere are two main components to your bill:\n\n\nComponent\nDescription\nSubscription\nCost of the plan you're on: \n[cost per seat] x [purchased seats]\nResource Usage\nCost of the resources you've consumed: \n[cost per unit] x [used units]\n\n\nSubscription is a flat fee you pay monthly for the tier you're subscribed to, and Resource Usage varies according to your resource consumption for the month.\n\n\nCan I add collaborators to my project?\n\n\nRailway's Pro and Enterprise plans are designed for collaboration. These plans allow you to add members to your team and manage their permissions.\n\n\nRead more about adding members to your Pro or Enterprise team \nhere\n.\n\n\nHow long does Railway keep my volume data if I am no longer on a paid plan?\n\n\nFor Trial, Railway will delete your volumes 30 days after your Trial credits runout.\n\n\nFor Hobby and Pro, Railway will retain your volumes for 90 days and then delete them from the platform after sufficient warning.\n\n\nIs the Hobby Plan free?\n\n\nNo. The Hobby Plan is $5 a month, and it includes a resource usage credit of $5. Even if you do not use the $5 in usage (CPU, Memory, egress), you always pay the $5 subscription fee.\n\n\nCan I get the Hobby plan subscription fee waived?\n\n\nRailway waives the monthly Hobby plan subscription fee for a small set of active builders on the platform.\n\n\nEligibility is automatically assessed based on several factors, including your usage on the platform, your GitHub account, and more. If you qualify, you will be notified in the Dashboard or when you upgrade to the Hobby plan. If you do not qualify, you will not be eligible for the waiver.\n\n\nThis is a fully automated process, and Railway does not respond to requests for waiver.\n\n\nI prefer to prepay. Is that possible?\n\n\nNot anymore as of March 30th, Railway requires the use of a post-paid card.\n\n\nWhat happens if I use credits as a payment method and my account runs out of credits?\n\n\nIf you are using credits as a payment method and your credit balance reaches zero, your subscription will be cancelled. You will no longer be able to deploy to Railway and we will stop all of your workloads. To resolve this, you will need to sign up for a new subscription after topping up sufficient credits.\n\n\nWhy was I charged for a partial month of usage?\n\n\nRailway has an automated system in place which can result in a partial amount of your bill being charged to your payment method, earlier in the billing cycle.\n\n\nThis is intended to ensure that your account remains in good standing, and helps us to mitigate risk and fraud.\nPrev\n \nTemplates\nNext\n \nFree Trial\nEdit this file on GitHub\nOn This Page\nPlans\nSubscription Pricing\nDefault Plan Resources\nResource Usage Pricing\nIncluded Usage\nAdditional Services\nCommitted Spend Tiers\nPurchasing Credits\nOne-time Grant of Credits on the Free Trial\nPartial Month Charges\nFAQs\nWhich plan is right for me?\nCan I upgrade or downgrade at any time?\nWhat is the difference between subscription and resource usage?\nCan I add collaborators to my project?\nHow long does Railway keep my volume data if I am no longer on a paid plan?\nIs the Hobby Plan free?\nCan I get the Hobby plan subscription fee waived?\nI prefer to prepay. Is that possible?\nWhat happens if I use credits as a payment method and my account runs out of credits?\nWhy was I charged for a partial month of usage?"
  },
  {
    "url": "https://docs.railway.app/reference/private-networking",
    "title": "Private Networking | Railway Docs",
    "content": "Private Networking\nPrivate Networking refers to a feature within Railway that enables private communication between services in a project and environment. This is helpful for situations where you want to have a public gateway for your API but leave internal communication private.\n\n\nHow it works\n\n\nUnder the hood, Railway is using encrypted Wireguard tunnels to create an IPv6 mesh network between all services within an environment. This allows traffic to route between services without exposing ports publicly.\n\n\nNote: You cannot use private networking to communicate with services in other environments.\n\n\nInternal DNS\n\n\nEvery service in a project and environment gets an internal DNS name under the \nrailway.internal\n domain that resolves to the internal IP address of the service.\n\n\nThis allows communication between services in an environment without exposing any ports publicly. Any valid IPv6 traffic is allowed, UDP, TCP and HTTP.\n\n\n\n\nCaveats\n\n\nDuring the feature development process we found a few caveats that you should be aware of:\n\n\n\n\nPrivate networking is not available during the build phase.\n\n\nYou will need to bind to a IPv6 port to receive traffic on the private network.\n\n\nWe don't support IPv4 private networking.\n\n\nPrivate networking does not function between \nenvironments\n.\n\n\n\n\nSupport\n\n\nFor information on how to use Private Networking, check out \nthis guide\n.\nPrev\n \nNixpacks\nNext\n \nPublic Networking\nEdit this file on GitHub\nOn This Page\nHow it works\nInternal DNS\nCaveats\nSupport"
  },
  {
    "url": "https://docs.railway.app/reference/production-readiness-checklist",
    "title": "Production Readiness Checklist | Railway Docs",
    "content": "Production Readiness Checklist\nIs your application ready for production?\n\n\nIn this page, we'll explore key areas for production readiness, suggesting actions to take to address each one:\n\n\n\n\nPerformance and Reliability\n\n\nObservability and Monitoring\n\n\nQuality Assurance\n\n\nSecurity\n\n\nDisaster Recovery\n\n\n\n\n\n\nPerformance and Reliability\n\n\nEnsuring your application is performant and reliable under changing conditions like load and external latency is critical for production-readiness.  Consider taking the following actions to ensure your application is performant and reliable -\n\n\nâœ“ Serve your application from the right region\n\n\n\n\n\n\nDeploying your application as close to your users as possible minimizes the number of network hops, reducing latency and improving performance.\n\n\nRailway offers multiple \ndeployment regions\n around the globe.\n\n\nYou may also consider implementing a CDN to cache server responses on an edge network.\n\n\n\n\n\n\nâœ“ Use private networking between services\n\n\n\n\n\n\nWhen communicating between services over the public network, latency is introduced by the network hops that requests must make to reach their destination.\n\n\nTo reduce latency, ensure communication between services in the same project and environment happens over the \nprivate network\n.\n\n\n\n\n\n\nâœ“ Configure a restart policy\n\n\n\n\n\n\nServices can crash for different reasons, frequently due to unhandled exceptions in code, and it is important to implement a strategy to mitigate performance degredation and user impact.\n\n\nEnsure that you have properly configured your services \nrestart policy\n.\n\n\n\n\n\n\nâœ“ Configure at least 2 replicas\n\n\n\n\n\n\nIf a service crashes or becomes unavailable due to a long-running request, your application could experience downtime or degraded performance.\n\n\nIncrease the \nnumber of replicas\n to at least 2, so if one instance of your service crashes or becomes unavailable, there is another to continue handling requests.\n\n\n\n\n\n\nâœ“ Confirm your compute capacity\n\n\n\n\n\n\nThe vCPU and memory capacity of your services greatly impacts their ability to perform efficiently.\n\n\nThe compute allocation for your services is handled automatically by Railway, and the limits are determined by your chosen subscription \nplan\n.  You should review your plan limits and consider if upgrading is necessary to achieve the desired compute.\n\n\n\n\n\n\nâœ“ Consider deploying a database cluster or replica set\n\n\n\n\n\n\nData is critical to most applications, and you should ensure that the data layer in your stack is highly available and fault tolerant.\n\n\nConsider implementing a cluster or replica set, similar to the \nRedis HA with Sentinel\n template, to ensure that your data remains available even if one node becomes unstable.\n\n\nWe are hard at work developing other templated solutions for more production-ready datastores, keep an eye on the template marketplace for more to become available.\n\n\n\n\n\n\n\n\nObservability and Monitoring\n\n\nObservability and monitoring refers to tracking the health and performance of your application.  Consider taking the following actions to ensure you are able to track your application health -\n\n\nâœ“ Get familiar with the log explorer\n\n\n\n\n\n\nWhen researching an application issue across multiple services, it can be disruptive and time-consuming to move between log views for each service individually.\n\n\nFamiliarize yourself with the \nLog Explorer\n so you can query logs across all of your services in one place.\n\n\n\n\n\n\nâœ“ Setup webhooks and email notifications\n\n\n\n\n\n\nEnsure you are alerted if the \ndeployment status\n of your services change.\n\n\nEnable email notifications in you Account Settings to receive these alerts via email.\n\n\nSetup \nwebhooks\n to have the alerts sent to another system, like Slack or Discord.\n\n\n\n\n\n\nWhat's next for observability features in Railway?  We have a ton of ideas, but we would love to hear yours in our \ncommunity forums\n.\n\n\n\n\nQuality Assurance\n\n\nQuality assurance involves following practices to ensure changes to your application code meet quality standards before they are deployed to production.  Consider the following actions to ensure you're set up for success -\n\n\nâœ“ Implement check suites\n\n\n\n\n\n\nCommon practice is to run a suite of tests, scans, or other automated jobs against your code before it is merged into production.  You may want to configure your deployments to wait until those jobs have completed successfully before triggering a build.\n\n\nEnable \ncheck suites\n to have Railway wait for your GitHub workflows to complete successfully before triggering a deployment.\n\n\n\n\n\n\nâœ“ Use environments\n\n\n\n\n\n\nMaintaining separate environments for production and development is good practice for controlling changes in a production environment.\n\n\nConsider setting up \nenvironments\n to properly test changes before merging to production.\n\n\nAdditionally, \nPR environments\n can be enabled to create environments when PRs are opened on your production branch.\n\n\n\n\n\n\nâœ“ Use config as code\n\n\n\n\n\n\nAlong with your source code, you can maintain your Railway configuration in a \njson\n or \ntoml\n file, enabling you to keep track of changes, just as you do with your source code.\n\n\nTake advantage of \nconfig as code\n to control and track changes to your Railway configuration.\n\n\n\n\n\n\nâœ“ Understand the deployment rollback feature\n\n\n\n\n\n\nIntroducing breaking changes to your application code is sometimes unavoidable, and it can be a headache reverting to previous commits.\n\n\nBe sure to check out the \ndeployment rollback feature\n, in case you need to rollback to a previous deployment.\n\n\n\n\n\n\n\n\nSecurity\n\n\nProtecting your application and user data from malicious threats and vulnerabilities is mission-critical in production applications.  Consider the following for peace of mind -\n\n\nâœ“ Use private networking\n\n\n\n\n\n\nThe easiest way to protect your services from malicious threats, is to keep them unexposed to the public network.\n\n\nSecure communication between services in the same project and environment by using the \nprivate network\n.\n\n\n\n\n\n\nâœ“ Implement a security layer\n\n\n\n\n\n\nWhile Railway does have protections in place at the platform level, we do not currently offer a configurable service for users' applications.\n\n\nConsider using a service like Cloudflare that offers both WAF and DDoS mitigation, to protect your services against web threats and ensure availability and performance.\n\n\nIn the future, we would love to offer a native security solution.  If you agree, \nlet us know\n.\n\n\n\n\n\n\n\n\nDisaster Recovery\n\n\nBeing prepared for major and unexpected issues helps minimize downtime and data loss.  Consider taking the following actions to ensure you are prepared -\n\n\nâœ“ Set up an instance of your application in two regions\n\n\n\n\n\n\nIn the event of a major disaster, an entire region may become unavailable.\n\n\nUsing \ndeployment regions\n, you can deploy an entire instance of your application in another region.\n\n\nTo save on cost of running a separate instance of your application, use \nApp Sleep\n to turn down resource usage on the inactive services.\n\n\n\n\n\n\nâœ“ Regularly back up your data\n\n\n\n\n\n\nData is critical to preserve in many applications.  You should ensure you have a backup strategy in place for your data.\n\n\nEnable and configure \nbackups\n for your services with volumes to ensure you can restore your data in case of any data loss.\n\n\n\n\n\n\n\n\nConclusion\n\n\nUsing a mix of native features and external tools, we hope you can feel confident that your applications on Railway meet the highest standards of performance, reliability, and security.\n\n\nRemember, our team is always here to assist you with solutions.  Reach out in \nDiscord\n or over email at \nteam@railway.com\n for assistance.\n\n\nFinally, as suggested on several sections above, we are working tirelessly to give you the best experience imaginable on Railway.  If you have requests or suggestions, please \nlet us know\n!\nPrev\n \nMigrate to Railway Metal\nNext\n \nPhilosophy\nEdit this file on GitHub\nOn This Page\nPerformance and Reliability\nObservability and Monitoring\nQuality Assurance\nSecurity\nDisaster Recovery\nConclusion"
  },
  {
    "url": "https://docs.railway.app/reference/project-members",
    "title": "Project Members | Railway Docs",
    "content": "Project Members\nProject members can be invited to access any project.\n\n\n\n\nScope of Permissions\n\n\nThere are three scopes for project members -\n\n\n\n\n\n\nOwner\n: full administration of the project.\n\n\n\n\n\n\nEditor\n: Can create deployments, change project settings and add Editor and Viewer members.\n\n\nNote:\n Editors can not do destructive actions such as deleting services or deleting the project itself.\n\n\n\n\n\n\nViewer\n: Read only access to the project. Viewers can not make deploys or see environment variables.\n\n\n\n\n\n\nThe Project Owner is charged for the project's usage.\nPrev\n \nPriority Boarding\nNext\n \nProject Usage\nEdit this file on GitHub\nOn This Page\nScope of Permissions"
  },
  {
    "url": "https://docs.railway.app/reference/public-api",
    "title": "Public API Reference | Railway Docs",
    "content": "Public API Reference\nThe Railway public API is built with GraphQL and is the same API that powers the Railway dashboard.\n\n\nEndpoint\n\n\nThe public API is accessible at the following endpoint:\n\n\nhttps://backboard.railway.com/graphql/v2\n\n\nAuthentication\n\n\nTo use the API, you will need an API token. There are three types of tokens you can create.\n\n\nTeam Token and Personal Token\n\n\nYou can create an API token by visiting the \ntokens page\n in your account settings.\n\n\n\n\nTeam tokens\n are tied to a team and will have access to all the team's resources. This token cannot be used to access your personal resources on Railway so feel free to share it with your teammates.\n\n\nNon-team tokens\n will be tied to your Railway account and will have access to all your resources. Do not share this token with anyone else.\n\n\n\n\ncurl\n --request POST \n\\\n\n\n  --url https://backboard.railway.com/graphql/v2 \n\\\n\n\n  --header \n'Authorization: Bearer <API_TOKEN_GOES_HERE>'\n \n\\\n\n\n  --header \n'Content-Type: application/json'\n \n\\\n\n\n  --data \n'{\"query\":\"query { me { name email } }\"}'\n\n\nProject Token\n\n\nYou can create a project token by visiting the tokens page in your project settings.\n\n\nProject tokens are scoped to a specific environment within a project and can only be used to authenticate requests to that environment.\n\n\ncurl\n --request POST \n\\\n\n\n  --url https://backboard.railway.com/graphql/v2 \n\\\n\n\n  --header \n'Project-Access-Token: <PROJECT_TOKEN_GOES_HERE>'\n \n\\\n\n\n  --header \n'Content-Type: application/json'\n \n\\\n\n\n  --data \n'{\"query\":\"query { projectToken { projectId environmentId } }\"}'\n\n\nSchema\n\n\nThe Railway API supports introspection meaning you can use popular tools like \nPostman\n or \nInsomnia\n to query the schema.  Simply set up your connection with the endpoint and Authorization token, and fetch the schema.\n\n\nAPI Collection File\n\n\nWe provide a collection file which can be imported into your preferred API client.  Once imported, you should only need to add your API token to get connected and start executing queries in the collection. Click \nhere\n to download it.\n\n\nGraphiQL Playground\n\n\nUse our \nGraphiQL playground\n to view the schema and test your queries.\n\n\nMake sure to set an Authorization header with an \nauth token\n. Click the \"Headers\" tab at the bottom of the GraphiQL page and enter this json, using your own token:\n\n\n{\n\"Authorization\"\n:\n \n\"Bearer <API_TOKEN_GOES_HERE>\"\n}\n\n\nRate Limits\n\n\nIn order to protect the Railway API from spam and misusage, we have established some basic rate limits. The current limit is \n1000\n requests per \nhour\n to the API. To help you keep track of your usage, Railway sends a few headers with the response on each request.\n\n\nHeader\nDescription\nX-RateLimit-Limit\nThe maximum number of API requests allowed per day.\nX-RateLimit-Remaining\nThe number of API requests your token can make in the current window.\nX-RateLimit-Reset\nThe time at which the current window ends and your remaining requests reset.\nRetry-After\nThe amount of time after which you can make another request. This header is only sent once you've used up all your requests in the current window.\n\n\nSupport\n\n\nFor more information on how to use the Public API and for examples of queries, view the \nPublic API guide\n.\n\n\nIf you run into problems using the API or have any suggestions, feel free to join our \nDiscord server\n where you can interact with the engineers working on the API directly.\nPrev\n \nCLI API\nNext\n \nTemplates\nEdit this file on GitHub\nOn This Page\nEndpoint\nAuthentication\nTeam Token and Personal Token\nProject Token\nSchema\nAPI Collection File\nGraphiQL Playground\nRate Limits\nSupport"
  },
  {
    "url": "https://docs.railway.app/reference/public-domains",
    "title": "Public Domains | Railway Docs",
    "content": "Public Domains\nRailway can provide a public domain to any service that is listening for traffic.  You are also free to use your own custom domain.\n\n\nHow it Works\n\n\nRailway can detect a deployment is listening for traffic.  When detected, you will be asked if you would like to assign a domain to the service. Then you can simply follow the prompts to generate a domain and your app will be exposed to the internet.\n\n\nSupport\n\n\nFor information on how to use domains as well as setting up a custom domain, refer to \nthis guide\n.\nNext\n \nHome\nEdit this file on GitHub\nOn This Page\nHow it Works\nSupport"
  },
  {
    "url": "https://docs.railway.app/reference/services",
    "title": "Services | Railway Docs",
    "content": "Services\nA Railway service is a deployment target.  Under the hood, services are containers deployed from an image.\n\n\nEach service keeps a log of \ndeployment attempts\n and \nperformance metrics\n.\n\n\nVariables\n, source references (e.g. GitHub repository URI), and relevant \nstart and build commands\n are also stored in the service, among other configuration.\n\n\nTypes of Services\n\n\nPersistent Services\n\n\nServices that are always running.  Examples include web applications, backend APIs, message queues, database services, etc.\n\n\nScheduled Jobs\n\n\nServices that are run until completion, on a defined schedule, also called \nCron Jobs\n.\n\n\nService Source\n\n\nA service source can be any of the following - Docker Image, GitHub or Local repository.\n\n\nIf a \nDockerfile\n is found within the source repository, Railway will automatically use it to build an image for the service.\n\n\nDocker Image\n\n\nServices can be deployed directly from a Docker image from Docker Hub, GitHub Container Registry, GitLab Container Registry, or Quay.io.  The images can be public or private.\n\n\nGitHub Repository\n\n\nServices can be connected to a GitHub repo and automatically deployed on each commit.\n\n\nLocal Repository\n\n\nServices can be deployed from a local machine by using the \nRailway CLI\n.\n\n\nEphemeral Storage\n\n\nEvery service deployment has access to 10GB of ephemeral storage.  If a service deployment consumes more than 10GB, it can be forcefully stopped and redeployed.\n\n\nIf your service requires data to persist between deployments, or needs more than 10GB of storage, you should add a \nvolume\n.\n\n\nTemplates\n\n\nA \ntemplate\n is a pre-configured group of services. A template can be used to start a project or to expand an existing project.\n\n\nConstraints\n\n\n\n\nService names have a max length of 32 characters.\n\n\nPrev\n \nProjects\nNext\n \nVariables\nEdit this file on GitHub\nOn This Page\nTypes of Services\nPersistent Services\nScheduled Jobs\nService Source\nDocker Image\nGitHub Repository\nLocal Repository\nEphemeral Storage\nTemplates\nConstraints"
  },
  {
    "url": "https://docs.railway.app/reference/support",
    "title": "Support | Railway Docs",
    "content": "Support\nRailway offers numerous tiers of support for our users.\n\n\nSupport Tiers\n\n\nWe prioritize support requests based on the plan you're on and the urgency of your request.\n\n\nTrial & Hobby\n\n\nTrial & Hobby plan users are only eligible for community support over \nCentral Station\n or \nDiscord\n. Railway may respond to community threads, but a response is not guaranteed.\n\n\nPro & Business Class\n\n\nPro & \nBusiness Class\n customers can select the urgency of their request when creating a new thread in \nCentral Station\n or \nSlack\n.\n\n\nLevel\nDescription\nEligibility\nLow\nQuestions about how to use Railway or general feedback\nPro\nNormal\nIssues with Railway, such as bugs or unexpected behavior\nPro\nHigh\nIssues that are blocking you from using Railway\nPro\nCritical\nProduction outage or platform issues blocking your team from using Railway\nBusiness Class\n\n\nCentral Station\n\n\nRailway conducts its support over our \nCentral Station\n platform.\n\n\nIt hosts our community of 500,000+ users and developers. It is where you can find answers to common questions, ask questions, and get in touch with the Railway team.\n\n\n\n\nPlease ensure that you've searched for your issue before creating a new thread, follow the guidelines in \nHow To Ask For Help\n, and abide by our \nCode of Conduct\n.\n\n\nVisibility\n\n\nFor Pro plan users, threads created in the \nCentral Station\n are treated as \nHigh Priority\n. These threads are guaranteed a response from the Railway team within 1 business day (if community members are unable to help).\n\n\nWe pay special attention to threads created by Pro users and ensure that questions or concerns are resolved in a timely manner.\n\n\n\n\nFor teams and companies requiring SLOs and higher-priority support over chat, sign up for \nBusiness Class\n.\n\n\nPrivate Threads\n\n\nYou create a \nPrivate Thread\n on \nCentral Station\n if you need to share sensitive information, such as invoices or personal data. Private Threads are only visible to you and Railway employees.\n\n\n\n\nPrivate Threads have a slower response time because only Railway employees can\nsee them. We recommend you to only create a Private Thread if you need to share\nsensitive information.\n\n\nWe may make the thread public for community involvement if we determine that\nthere is no sensitive information in your thread.\n\n\nDiscord\n\n\nWe have a vibrant Discord community of over 20,000+ users and developers. You can find the Railway Discord at \nhttps://discord.gg/railway\n.\n\n\nPlease ask your questions in the \nâœ‹ ï½œ help\n channel, and refrain from pinging anyone with the \nTeam\n or \nConductor\n roles.\n\n\nSlack\n\n\nRailway offers Slack channels to companies and prospective customers. Customers can raise issues, coordinate their migration over to Railway, and provide feedback within a Slack Connect channel.\n\n\n\n\nAll teams can create a Slack channel within the Team settings page:\n\n\n\n\nUsers in a Slack Connect channel can invite their team members using the Slack interface or by pressing the \nJoin Slack\n button again to initiate new invites.\n\n\nSlack Account Linking\n\n\nWe highly recommend connecting your Slack account if you have a shared Slack Connect channel with us. Doing so allows us to get insight into issues affecting your workloads without having to ask for additional information.\n\n\nTo link your Slack account to your Railway account, navigate to your team's \nsettings page\n on Railway.\n\n\nRailway only asks for permissions to link your Slack account's ID and your Slack Workspace's ID. Our integration can only see messages within the shared Slack Connect channel\n.\n\n\nHow To Ask For Help\n\n\nWhen you reach out for help, it's important that you help us help you! Please include as much information as you can, including but not limited to:\n\n\n\n\nDescription of the issue you're facing\n\n\nIDs (Project ID, Service Name/ID, Deployment ID, etc.)\n\n\nRailway environment of your service/deployment\n\n\nError messages and descriptions\n\n\nLogs (build and/or deploy)\n\n\nLink to GitHub repo/code or template you're using, if applicable\n\n\n\n\nBusiness Class\n\n\nFor teams and companies who need dedicated support, we offer Business Class.\n\n\nBusiness Class is support and success designed for those who need the full attention of Railway. Business Class support is a dedicated support channel with SLOs for your company. Workspaces become eligible for Business Class response times after $500/mo in spend.\n\n\nReach out to us at \nteam@railway.com\n to enable your SLO.\n\n\nBusiness Class SLOs\n\n\nWe prioritize Business Class customers over all other support requests.\n\n\nSeverity\nAcknowledgement Time\nP1 (Outages, Escalations)\nOne hour - 24/7\nP2 (Bugs)\nSame Business Day\nP3 (Integrations, General Questions)\nTwo Business Days\n\n\nFor Business Class customers with a shared Slack Connect channel with us, you have access to\n\"Critical\" urgency level support requests:\n\n\n\n\nThis allows you to page our support on-call directly for an immediate response.\nPlease only use this for production outages or critical platform issues\npreventing your team from using Railway.\n\n\nDefinition of Priorities\n\n\nPriority\nSurface Areas\n1\nOutages that impact production\n. This covers the following components: incidents declared on \nstatus.railway.com\n including and especially incidents with end-customer impact (e.g. inability to login to the Dashboard), customer workload-impacting issues due to high load requiring intervention from Railway (e.g. requiring additional resources beyond your current limits).\n2\nIssues related to Railway features\n. This covers features offered by Railway, including but not limited to our Dashboard, CLI, and platform-level features such as Deployments, Environments, Private Networking, Volumes.\n3\nIntegration work and general questions related to Railway\n. This covers customer-related requests involving integrating Railway with other services (e.g. fronting your Railway workload with a DDoS protection service), leveraging tools to use Railway the way you like (e.g. IaC provisioning/Terraform), or questions about Railway features or its platform.\n\n\nBusiness Class Response Hours\n\n\nWe offer support during business hours, and prioritize requests from Business Class customers:\n\n\n\n\nBusiness hours are Monday through Friday, 9am to 9pm Pacific Time\n\n\nExceptions apply to our business hours during P1 outages where the team will be on-call 24/7\n\n\nThe team may reply outside of business hours, but we do not guarantee a response outside of business hours\n\n\n\n\nBusiness Class Resource Limits\n\n\nFor Business Class customers, Railway increases resource limits beyond the standard limits on a need-based basis. Contact the team through your dedicated communication channel to increase limits.\n\n\nUptime Calculation\n\n\nAs part of this offering, we agree to provide a monthly summary on the uptime of the components of Railway. Customers are provided an RCA to any outages on the Routing Layer.\n\n\nAudits\n\n\nSecurity audits can be provided by request.\n\n\nEnterprise\n\n\nFor enterprises, we offer everything in \nBusiness Class\n along with custom support tailored to your needs. Railway can enter into a contractual SLA under our negotiated pricing offering. Reach out to us at \nteam@railway.com\n for more information.\nPrev\n \nProject Usage\nNext\n \nTeams\nEdit this file on GitHub\nOn This Page\nSupport Tiers\nTrial & Hobby\nPro & Business Class\nCentral Station\nVisibility\nPrivate Threads\nDiscord\nSlack\nSlack Account Linking\nHow To Ask For Help\nBusiness Class\nBusiness Class SLOs\nDefinition of Priorities\nBusiness Class Response Hours\nBusiness Class Resource Limits\nUptime Calculation\nAudits\nEnterprise"
  },
  {
    "url": "https://docs.railway.app/reference/tcp-proxy",
    "title": "TCP Proxy | Railway Docs",
    "content": "TCP Proxy\nProxy TCP traffic to a service by creating a TCP proxy.\n\n\nHow it works\n\n\nEnabling TCP Proxy on a service requires specification of a port to which the traffic should be proxied.  Railway then generates a domain and proxy port, and all traffic sent to \ndomain:port\n will be proxied to the service.\n\n\n\n\nLoad Balancing\n\n\nCurrently we use a random load balancing strategy for TCP traffic.\n\n\nUse Cases\n\n\nTCP Proxy is useful for services that don't support HTTP, such as databases.\n\n\nSupport\n\n\nFor more information on how to set it up, refer to the TCP Proxy section of the \nPublic Networking guide\n.\nPrev\n \nScaling\nNext\n \nLogging\nEdit this file on GitHub\nOn This Page\nHow it works\nLoad Balancing\nUse Cases\nSupport"
  },
  {
    "url": "https://docs.railway.app/reference/teams",
    "title": "Workspaces | Railway Docs",
    "content": "Workspaces\nWorkspaces are how organizations are represented within Railway. A default workspaces is made with your account, and new ones can be created via the Pro or Enterprise plans.\n\n\nFor more information, visit our \ndocumentation on pricing\n or \nrailway.com/pricing\n.\n\n\n\n\nNote:\n Effective March 3rd, 2025, for users on Railway hosted metal instances, all seat costs will be waived.\n\n\n\n\nCreating a Workspace\n\n\nOrganizations can create a workspace by heading to the \nCreate Workspace\n page and entering the required information.\n\n\nManaging Workspaces\n\n\nYou can open your workspace's settings page to manage members and see billing information by clicking the gear icon next to the name of your workspace on the dashboard.\n\n\nInviting Members\n\n\nUnder the People tab of the settings page, you can invite members.\n\n\nThere are three roles for Workspace members:\n\n\n\n\nAdmin: Full administration of the Workspace and all Workspace projects\n\n\nMember: Access to all Workspace projects\n\n\nDeployer: View projects and deploy through commits to repos via GitHub integration.\n\n\n\n\nNote\n: Changes that trigger a deployment will skip the approval requirement when the author has a Deployer role (or higher) and their GitHub account is connected.\n\n\nTrusted Domains\n\n\nTrusted domains may be configured on the workspace settings page. Note that workspace members added via trusted domain will be billed at the normal rate.\n\n\n\n\nYou can automate the onboarding of new workspace members with trusted domains. Railway users that sign up with one of the trusted domains associated with your workspace will automatically be granted access to the workspace with the specified role (see above).\n\n\nFor example, new users with \nexample.com\n email addresses will automatically be added to your workspaces that have the \nexample.com\n trusted domain.\n\n\nWe verify that you have administrative access to the domain by looking for services in your workspace that use this domain or a subdomain. Make sure to \nsetup a custom domain\n on your service before adding it as a trusted domain.\n\n\nTransferring Projects\n\n\nTransfer projects from another Workspace or Hobby workspace easily. Detailed instructions can be found \nhere\n.\n\n\nInvoicing and Billing\n\n\nRailway offers a consumption-based pricing model for your projects. You don't get charged for resources you don't use, instead, Railway charges by the minute for each vCPU and memory resource your service uses.\n\n\nHowever, if you expect to use a consistent amount of resources for large companies, you can contact us for a quote and demo. Railway will work with you to find a solution that works for your needs. We are willing to offer Purchase Orders and concierge onboarding for large companies.\n\n\nCommitted Spend Tiers\n\n\nRailway offers committed spend tiers for customers with consistent usage needs. Instead of negotiated contract pricing, customers can commit to a specific monthly threshold to \nunlock additional features and services.\n\n\nMonthly thresholds for addons is found in our \ncommited spend pricing\n.\n\n\nReach out to us at \nteam@railway.com\n for more information.\n\n\nFAQs\n\n\nHow do I get my Pro seat costs waived?\n\n\nAs of March 3rd, 2025, Railway waives all seat costs for users on Railway hosted metal instances. To qualify for this benefit:\n\n\n\n\nYour workspace must be on the Pro plan\n\n\nYour services must be quality for metal pricing and run on Railway hosted metal instances\n\n\nThis waiver will be automatically applied for your next monthly invoice\n\n\n\n\nIf you're interested in moving to Railway hosted metal instances to take advantage of this benefit, please \ncontact our team\n to discuss your requirements and set up a dedicated host solution.\n\n\nThe seat cost waiver provides significant savings for workspaces of all sizes, especially as your workspace grows. This is part of our commitment to providing more flexible and cost-effective pricing options for our customers.\nPrev\n \nSupport\nNext\n \nUsage Limits\nEdit this file on GitHub\nOn This Page\nCreating a Workspace\nManaging Workspaces\nInviting Members\nTrusted Domains\nTransferring Projects\nInvoicing and Billing\nCommitted Spend Tiers\nFAQs\nHow do I get my Pro seat costs waived?"
  },
  {
    "url": "https://docs.railway.app/reference/templates",
    "title": "Templates | Railway Docs",
    "content": "Templates\nTemplates provide a way to jumpstart a project by giving users the means to package a service or set of services into a reusable and distributable format.\n\n\nAs a user in Railway, you can create and publish templates for others to use, or you can deploy templates from our \ntemplate marketplace\n.\n\n\nFor information on how to create, publish, and deploy templates, visit our \nTemplates guides\n.\n\n\nKickback program\n\n\nIf you publish a template, and it is deployed into other users' projects, you are immediately eligible for a 50% kickback of the usage cost incurred, in the form of Railway credits.\n\n\nIf a user deploys your template, and the usage of the services cost the user $100, you would receive $50 in Railway credits or $50 in cash (USD).\n\n\nRead more about the kickback program \nhere\n.\n\n\nKickback Eligibility Requirements\n\n\n\n\n\n\nYour template must be published to the marketplace to be eligible for kickback.\n\n\n\n\n\n\nFor Hobby users with a $5 discount, only usage in excess of the discount is counted in the kickback.\n\n\n\n\n\n\nAll service types and resource usage of those services (compute, volume, egress, etc) \ndo count\n towards the kickback.\n\n\n\n\n\n\nPlatform fees are not included in the kickback, but usage fees of the platform are included. Examples of platform fees are:\n\n\n\n\nCost of Subscription Plan ($5 for Hobby, $20 for Pro)\n\n\nAdditional Team Seats\n\n\n\n\nAs an example, if a user pays $20 in platform fees, then incurs $200 of usage from your template, you are eligible for a $100 kickback (50% of $200).\n\n\n\n\n\n\nThe minimum kickback our program supports is $0.01, meaning usage of your template must incur at least $0.04 in usage after discounts and/or platform fees.\n\n\n\n\n\n\nAll service types and resource usage of those services (compute, volume, egress, etc) \ndo count\n towards the kickback.\n\n\n\n\n\n\nEarnings and Withdrawals\n\n\nBy default, your template kickbacks are automatically converted into Railway Credits. But we also offer cash wishdrawals. Visit the \n/earnings\n tab inside your account settings for more details. There you can add your details and request a withdrawal.\n\n\nFAQ\n\n\nHow do I start earning cash?\n\n\n\n\nSimply flip the switch on the Earnings page marked \nDirect Deposit to Railway Credits\n. This will stop auto-depositing your earnings into our Credits system. You will then begin accruing cash in your \nAvailable Balance\n.\n\n\n\n\nHow do I request a withdrawal?\n\n\n\n\nFollow the instructions inside the \nEarnings\n tab. We currently allow withdrawals to GitHub Sponsors and Buy Me a Coffee. After adding your account details you will request a withdrawal. Out team will receive the request and process it right away.\n\n\n\n\nCan I make manual withdrawals to credits too?\n\n\n\n\nYes! Choose the \nCredits\n checkbox and then make your withdrawal request.\n\n\n\n\nI have earned a lot of kickbacks from a template, but this page says my available balance is 0. Why?\n\n\n\n\nCash withdrawals are a new feature. The current kickback method is to automatically apply your kickbacks as Railway Credits. You can opt out of this if you wish to start accruing cash.\n\n\n\n\nCan I still use the older, automatic-credits setting?\n\n\n\n\nYes. This behavior is enabled by default. You can opt out of it, and back in to it, at any time. Simply use the switch on the Earnings page marked \nDirect Deposit to Railway Credits\n.\n\n\n\n\nWhat is the minimum withdrawal amount?\n\n\n\n\nFor now, withdrawals may be made in $100 - $500 increments.\n\n\n\n\nUpdatable Templates\n\n\nWhen you deploy any services from a template based on a GitHub repo, every time you visit the project in Railway, we will check to see if the project it is based on has been updated by its creator.\n\n\nIf it has received an upstream update, we will create a branch on the GitHub repo that was created when deploying the template, allowing for you to test it out within a PR deploy.\n\n\nIf you are happy with the changes, you can merge the pull request, and we will automatically deploy it to your production environment.\n\n\nIf you're curious, you can read more about how we built updatable templates in this \nblog post\n.\n\n\nNote that this feature only works for services based on GitHub repositories. At this time, we do not have a mechanism to check for updates to Docker images from which services may be sourced.\nPrev\n \nPublic API\nNext\n \nPlans\nEdit this file on GitHub\nOn This Page\nKickback program\nKickback Eligibility Requirements\nEarnings and Withdrawals\nFAQ\nHow do I start earning cash?\nHow do I request a withdrawal?\nCan I make manual withdrawals to credits too?\nI have earned a lot of kickbacks from a template, but this page says my available balance is 0. Why?\nCan I still use the older, automatic-credits setting?\nWhat is the minimum withdrawal amount?\nUpdatable Templates"
  },
  {
    "url": "https://docs.railway.app/reference/usage-limits",
    "title": "Usage Limits | Railway Docs",
    "content": "Usage Limits\nUsage Limits allow you to set a maximum limit on your usage for a billing cycle. If your resource usage for the billing cycle exceeds the limit you configured, we will shut down your workloads to prevent them from incurring further resource usage.\n\n\nConfiguring Usage Limits\n\n\n\n\nVisit your \nWorkspace Usage page\n to set the usage limits. Once you click the \nSet Usage Limits\n button, you will see a modal above where you can set a \nCustom email alert\n and a \nHard limit\n.\n\n\nThe link above takes you to the usage page for your personal account. If you want to set a usage limit for your team, you can use the account switcher in the top left corner of your dashboard to access the team's usage page.\n\n\nCustom Email Alert\n\n\nYou can think of this as a \nsoft limit\n. When your resource usage reaches the specified amount, we will email you that this threshold has been met. Your resources will remain unaffected.\n\n\nHard Limit\n\n\nOnce your resource usage hits the specified hard limit, all your workloads will be taken offline to prevent them from incurring further resource usage. Think of the hard limit as the absolute maximum amount you're willing to spend on your infrastructure.\n\n\nWe will send you multiple reminders as your usage approaches your hard limit:\n\n\n\n\nWhen your usage reaches 75% of your hard limit\n\n\nWhen your usage reaches 90% of your hard limit\n\n\n\n\nWe will send you another email if your workloads are taken down due to your specified usage limits.\n\n\nSetting a hard limit is a possibly destructive action as you're risking having all your resources shut down once your usage crosses the specified amount.\n\n\nFAQ\n\n\nCan I set a usage limit?\nUsage limits are available for all users on the Pro plan and for users on the automatic payment Hobby plan model.\nUsage limits are not available for users on the prepaid plans. Instead, the amount of credits you load determines the hard limit.\n\n\nDo I need to set a hard limit to set a custom email alert?\nNo. You can leave the hard limit blank if you simply want to be notified at a particular amount of usage.\n\n\nWhat is the minimum hard limit?\nThe minimum amount you can specify as the hard limit is $10.\n\n\nHow can I restart my resources if I hit my usage limit?\nTo restart your resources, you can either increase your usage limit or remove it entirely.\nFor guidance on restarting your resources, please refer to our \nFAQ\n section.\n\n\nWill my resources be automatically started during the next billing cycle?\nNo. Once your resources are shut down, it is your responsibility to restart them.\nPrev\n \nTeams\nNext\n \nCLI API\nEdit this file on GitHub\nOn This Page\nConfiguring Usage Limits\nCustom Email Alert\nHard Limit\nFAQ"
  },
  {
    "url": "https://docs.railway.app/reference/variables",
    "title": "Variables | Railway Docs",
    "content": "Variables\nVariables provide a powerful way to manage configuration and secrets across services in Railway.\n\n\nHow it Works\n\n\nWhen defined, variables are made available to your application as environment variables in the following scenarios:\n\n\n\n\nThe build process for each service deployment.\n\n\nThe running service deployment.\n\n\nThe command invoked by \nrailway run <COMMAND>\n\n\nThe local shell via \nrailway shell\n\n\n\n\nIn Railway, there is also a notion of configuration variables which allow you to control the behavior of the platform.\n\n\nTemplate Syntax\n\n\nRailway's templating syntax gives you flexibility in managing variables:\n\n\n${{NAMESPACE.VAR}}\n\n\n\n\nNAMESPACE\n - The value for NAMESPACE is determined by the location of the variable being referenced. For a shared variable, the namespace is \"shared\". For a variable defined in another service, the namespace is the name of the service, e.g. \"Postgres\" or \"backend-api\".\n\n\nVAR\n - The value for VAR is the name, or key, of the variable being referenced.\n\n\n\n\nYou can also combine additional text or even other variables, to construct the values that you need:\n\n\nDOMAIN=${{shared.DOMAIN}}\n\nGRAPHQL_PATH=/v1/gql\n\nGRAPHQL_ENDPOINT=https://${{DOMAIN}}/${{GRAPHQL_PATH}}\n\n\nTypes of Variables\n\n\nIn Railway, there is a notion of service variables, shared variables, reference variables, sealed variables, and a few kinds of reserved variables.\n\n\nService Variables\n\n\nService variables are scoped to a specific service. They can be referenced in other services by using a Reference Variable.\n\n\nShared Variables\n\n\nShared variables are scoped to a project and environment. They help reduce duplication of variables across multiple services within the same project.\n\n\nReference Variables\n\n\nReference variables are those defined by referencing variables in other services, shared variables, or even variables in the same service. This is useful for ease of maintenance, allowing you to set a variable in a single place and reference it as needed.\n\n\nReference variables use Railway's \ntemplate syntax\n.\n\n\nSealed Variables\n\n\nSealed variables are scoped to a specific service. Once a variable is sealed, its value is not visible via the UI or the Railway API.\n\n\nVariable Functions\n\n\nTemplate variable functions\n allow you to dynamically generate variables (or parts of a variable) on demand when the template is deployed.\n\n\nRailway-Provided Variables\n\n\nRailway provides the following additional system environment variables to all\nbuilds and deployments.\n\n\nName\nDescription\nRAILWAY_PUBLIC_DOMAIN\nThe public service or customer domain, of the form \nexample.up.railway.app\nRAILWAY_PRIVATE_DOMAIN\nThe private DNS name of the service.\nRAILWAY_TCP_PROXY_DOMAIN\n(see \nTCP Proxy\n for details) The public TCP proxy domain for the service, if applicable. Example: \nroundhouse.proxy.rlwy.net\nRAILWAY_TCP_PROXY_PORT\n(see \nTCP Proxy\n for details) The external port for the TCP Proxy, if applicable. Example: \n11105\nRAILWAY_TCP_APPLICATION_PORT\n(see \nTCP Proxy\n for details) The internal port for the TCP Proxy, if applicable. Example: \n25565\nRAILWAY_PROJECT_NAME\nThe project name the service belongs to.\nRAILWAY_PROJECT_ID\nThe project id the service belongs to.\nRAILWAY_ENVIRONMENT_NAME\nThe environment name of the service instance.\nRAILWAY_ENVIRONMENT_ID\nThe environment id of the service instance.\nRAILWAY_SERVICE_NAME\nThe service name.\nRAILWAY_SERVICE_ID\nThe service id.\nRAILWAY_REPLICA_ID\nThe replica ID for the deployment.\nRAILWAY_REPLICA_REGION\nThe region where the replica is deployed. Example: \nus-west1\nRAILWAY_DEPLOYMENT_ID\nThe ID for the deployment.\nRAILWAY_SNAPSHOT_ID\nThe snapshot ID for the deployment.\nRAILWAY_VOLUME_NAME\nThe name of the attached volume, if any. Example: \nfoobar\nRAILWAY_VOLUME_MOUNT_PATH\nThe mount path of the attached volume, if any. Example: \n/data\n\n\nGit Variables\n\n\nThese variables are provided if the deploy originated from a GitHub trigger.\n\n\nName\nDescription\nRAILWAY_GIT_COMMIT_SHA\nThe git \nSHA\n of the commit that triggered the deployment. Example: \nd0beb8f5c55b36df7d674d55965a23b8d54ad69b\nRAILWAY_GIT_AUTHOR\nThe user of the commit that triggered the deployment. Example: \ngschier\nRAILWAY_GIT_BRANCH\nThe branch that triggered the deployment. Example: \nmain\nRAILWAY_GIT_REPO_NAME\nThe name of the repository that triggered the deployment. Example: \nmyproject\nRAILWAY_GIT_REPO_OWNER\nThe name of the repository owner that triggered the deployment. Example: \nmycompany\nRAILWAY_GIT_COMMIT_MESSAGE\nThe message of the commit that triggered the deployment. Example: \nFixed a few bugs\n\n\nUser-Provided Configuration Variables\n\n\nUsers can use the following environment variables to configure Railway's behavior.\n\n\nName\nDescription\nRAILWAY_DEPLOYMENT_OVERLAP_SECONDS\nHow long the old deploy will overlap with the newest one being deployed, its default value is \n20\n. Example: \n0\nRAILWAY_DOCKERFILE_PATH\nThe path to the Dockerfile to be used by the service, its default value is \nDockerfile\n. Example: \nRailway.dockerfile\nNIXPACKS_CONFIG_FILE\nThe path to the Nixpacks configuration file relative to the root of the app, its default value is \nnixpacks.toml\n. Example: \nfrontend.nixpacks.toml\nNIXPACKS_VERSION\nThe \nversion\n of Nixpacks to use, if unspecfied a default version will be used. Example: \n1.29.1\nRAILWAY_HEALTHCHECK_TIMEOUT_SEC\nThe timeout length (in seconds) of healthchecks. Example: \n300\nRAILWAY_DEPLOYMENT_DRAINING_SECONDS\nThe SIGTERM to SIGKILL buffer time (in seconds), its default value is 3. Example: \n30\nRAILWAY_RUN_UID\nThe UID of the user which should run the main process inside the container. Set to \n0\n to explicitly run as root.\nRAILWAY_SHM_SIZE_BYTES\nThis variable accepts a value in binary bytes, with a default value of 67108864 bytes (64 MB)\n\n\nSupport\n\n\nFor information on how to use variables refer to the \nVariables guide\n.\nPrev\n \nServices\nNext\n \nVolumes\nEdit this file on GitHub\nOn This Page\nHow it Works\nTemplate Syntax\nTypes of Variables\nService Variables\nShared Variables\nReference Variables\nSealed Variables\nVariable Functions\nRailway-Provided Variables\nGit Variables\nUser-Provided Configuration Variables\nSupport"
  },
  {
    "url": "https://docs.railway.app/reference/volumes",
    "title": "Volumes | Railway Docs",
    "content": "Volumes\nVolumes are a feature that enables persistent data for \nservices\n on Railway.\n\n\nHow it works\n\n\nWhen mounting a volume to a service, a volume is made available to the service on the specified mount path.\n\n\nSize Limits\n\n\nVolumes have a default size based on the \nsubscription plan\n.\n\n\n\n\nFree and Trial plans: \n0.5GB\n\n\nHobby plans: \n5GB\n\n\nPro and team plans: \n50GB\n\n\n\n\nVolumes can be \"Grown\" after upgrading to a different plan.\n\n\nPro users and above can self-serve to increase their volume up to 250 GB.\n\n\nFor Pro and above users, please reach out to us on our \nCentral Station\n or \nSlack\n if you need more then 250GB.\n\n\nPricing\n\n\nVolumes are billed at a rate per GB / minutely, and invoiced monthly. You can find \nspecific per-minute pricing here\n.\n\n\nYou are only charged for the amount of storage used by your volumes. \nEach volume requires aprox 2-3% of the total storage to store metadata about the filesystem, so a new volume will always start with some used amount of space used depending on the size.\n\n\nBackups\n\n\nServices with volumes support manual and automated backups, backups are covered in the \nbackups\n reference guide.\n\n\nCaveats\n\n\nHere are some limitations of which we are currently aware:\n\n\n\n\nEach service can only have a single volume\n\n\nReplicas cannot be used with volumes\n\n\nThere is no built-in S/FTP support\n\n\nTo prevent data corruption, we prevent multiple deployments from being active\nand mounted to the same service. This means that there will be a small amount\nof downtime when re-deploying a service that has a volume attached, even if there is a healthcheck endpoint configured\n\n\nDown-sizing a volume is not currently supported, but increasing size is supported\n\n\nWhen resizing a volume, all deployments must be taken offline to prevent data\ncorruption\n\n\nThere is no file browser, or direct file download. To access your files,\nyou must do so via the attached service's mount point\n\n\nDocker images that run as a non-root UID by default will have permissions issues when performing operations within an attached volume. If you are affected by this, you can set \nRAILWAY_RUN_UID=0\n environment variable in your service.\n\n\n\n\nSupport\n\n\nRefer to the guide on \nhow to use volumes\n for more details on how to use the feature.\nPrev\n \nVariables\nNext\n \nFunctions\nEdit this file on GitHub\nOn This Page\nHow it works\nSize Limits\nPricing\nBackups\nCaveats\nSupport"
  },
  {
    "url": "https://docs.railway.app/support/business-class",
    "title": "Not Found",
    "content": "Page not found\nMaybe you were looking for one of the following\nHome\nGetting Started\nCLI Quick Start\nRailway Up"
  },
  {
    "url": "https://docs.railway.app/tutorials/getting-started",
    "title": "Welcome to Railway Tutorials! | Railway Docs",
    "content": "Welcome to Railway Tutorials!\nThe Railway Team and community provide content, like tutorials and blogs, on how to make the most out of Railway.\n\n\nExplore the pages in this section to learn or get inspired!\n\n\nAlso checkout our \nQuick Start Tutorial\n to deploy an app in minutes.\n\n\nContributing\n\n\nPull requests are welcome.  If you make a quality tutorial for other Railway users, we would really love to include it!\n\n\nIf there is a tutorial you hope to see, please create a post in \nForums\n!\nPrev\n \nConfig as Code\nNext\n \nMigrate From Heroku\nEdit this file on GitHub\nOn This Page\nContributing"
  },
  {
    "url": "https://docs.railway.app/tutorials/migrate-from-heroku",
    "title": "Migrate from Heroku | Railway Docs",
    "content": "Migrate from Heroku\nMigrating your app from Heroku to Railway is very simple.  We even support Procfiles out of the box. (Only a single process is supported for now).\n\n\nAll you need to do is create a project in Railway, push your code, and migrate your envionment variables.\n\n\nThis guide will step you through the process of migrating a simple web service, using the \nRailway CLI\n.\n\n\n\n\nWorking Directory\n\n\nIn your terminal, ensure your current working directory is the same directory where your service code is located.\n\n\nThis is important so that as you complete the following steps, the \nRailway CLI\n is properly linked.\n\n\n1. Login to Railway From the CLI\n\n\nEnsure your CLI is authenticated to your Railway account:\n\n\nrailway login\n\n\nThis command will prompt to open a browser to complete authentication.  Once authenticated, commands executed by the Railway CLI, will be performed in the context of your Railway account.\n\n\n2. Create a New Project\n\n\nNow, let's create a new \nproject\n:\n\n\nrailway init\n\n\nThis command will prompt you to define a name for your service.\n\n\n3. Deploy the Service\n\n\nOnce your project is created, you can push your code into the project and assign a domain.\n\n\nPush the Code\n\n\nPush the code into a \nservice\n in Railway:\n\n\nrailway up -d\n\n\nAt this point, the service is being deployed, but let's give it a domain.\n\n\nAssign a Domain\n\n\nThe service we are migrating is a web service that should be available over the Internet, so let's assign a domain:\n\n\nrailway domain\n\n\nNow the service will be available over the Internet via the provided domain.\n\n\n4. Migrate the Environment Variables\n\n\nFinally, we will import the environment variables from Heroku into Railway.\n\n\n\n\nOpen the Project in Railway\n\n\nLet's pop over to our new project in the \nRailway canvas\n.:\n\n\nrailway \nopen\n\n\nThis will open the project in your browser.\n\n\nAdd Heroku Variables to the Service\n\n\nFrom the project canvas, import the Heroku variables into the service:\n\n\n\n\nclick on the service\n\n\nclick \nVariables\n tab\n\n\nopen the command palette using \nCMD + K\n or \nCtrl + K\n.\n\n\nsearch for \nImport variables from Heroku\n\n\nconfirm the Heroku service and hit \nEnter\n\n\n\n\nYour Heroku variables will be imported into the service, and it will automatically redeploy.\n\n\nNote: The first time you import variables from Heroku, you will be prompted to Allow Railway to connect to your Heroku account.\n\n\nConclusion\n\n\nFollowing this guide, we have successfully migrated a simple web service from Heroku to Railway, including importing variables from Heroku into Railway.\n\n\nWe have completed the migration by pushing our code directly from our local machine into a service in Railway.  Once you are comfortable with Railway, you may want to integrate \ndeployments\n into your development workflow.\n\n\nFor more advanced operations, like migrating your databases from Heroku to Railway, the process will be a bit more involved, but we are happy to help work out a solution!\n\n\nNeed Help?\n\n\nIf you run into any issues, or would like help with your migrations, we would be more than happy to answer your questions on our \nDiscord\n or over email at \nteam@railway.com\n.\nPrev\n \nGetting Started\nNext\n \nSet Up a Datadog Agent\nEdit this file on GitHub\nOn This Page\nWorking Directory\n1. Login to Railway From the CLI\n2. Create a New Project\n3. Deploy the Service\nPush the Code\nAssign a Domain\n4. Migrate the Environment Variables\nOpen the Project in Railway\nAdd Heroku Variables to the Service\nConclusion\nNeed Help?"
  }
]